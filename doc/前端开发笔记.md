# Html

## 文档结构

```html
<!DOCTYPE html> #文档类型：html，h4以前的html版本需要特殊声明，h5直接声明为“html”
<html lang="en/ch"> #根标签，每个网页只有一个，lang="en/ch"网页中英文
  <!--注释文字，ctrl+/-->
  <head> 
    <meta charset="utf-8"> #编码方式，utf-8中英文通用
    <!--专门针对IE浏览器，以高版本IE浏览器来显示网页-->
    <meta http-equiv="X-UA-Compatibale" content="IE=edge">
     <!--专门针对移动端布局，开启理想视口-->
    <meta name="Viewport" content="width=device-width,initial-scale=1.0">
    <meta name="keywords" content="keywords1，keywords2，。。。"> #seo
    <meta name="description" content="网站描述。。。"> #seo
    <meta name="author" content="author name"> #定义作者
    <title>标题</title>
  </head>
  <body>
    测试第一个网页！
  </body>
</html>
```



### !DOCTYPE

- 声明文档类型
- 声明html版本，浏览器解析规则和解析代码
- 浏览器的加载模式：不写!DOCTYPE时才用兼容模式，声明正确且约束条件正确按照严格模式
  1. 严格模式（标准）：w3c规则
  2. 混杂模式（兼容）：浏览器自己规则
- h5既可严格模式，也可兼容模式



## 开发工具

- webstorm：插件全
- Hbuilder：一部分插件，vue推荐，边开发边浏览页面
- Vscode：主流，微软出品，前后端都可以使用，插件自己安装



### 插件

- Auto Rename Tag：自动将结尾标签更改，直接输入h1,回车直接补全<h1></h1>
- HTML CSS Support ：html代码中支持css提示
- HTML Snippets ：自动生成html代码，专门针对html代码格式
- Image preview：代码前预览图片缩略图
- IntelliSense for CSS class names in HTML：在html中提示css的class名
- live server：将vscode作为一台服务器，浏览器可以访问，实时更新
- open in browser：不同浏览器打开，更新需要刷新页面



### 创建文件

- 创建项目时先创建文件夹，在文件夹内创建具体文件
- 创建html，“<!”，HTML Snippets插件会自动填充html框架

## 标签

### 文本



1. h1-h6, 默认加粗，上下有间距 margin，独占一行

```html
<h1>text1</h1>
<h2>text2</h2>
...
<h6>text6</h6>

```

2. 段落标签，一个段落一个p标签，独占一行，上下有间距margin，段落标签里内容不能嵌套其他段落标签

```html
<p>
  段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容段落内容。
</p>
```

3. span,多个span同行显示

```html
<span>span1</span>
<span>span2</span>
```

4. label，与span类似，多个label同行显示，表单<input>元素一起使用。for为标签属性，“”内为属性值，‘’也可以

   - 如果用户点击 label 元素内的文本，则会切换到控件本身。
   - <label> 标签的 for 属性应该等于相关元素的 id 元素，以便将它们捆绑起来。

   ```html
   <label for="">label</label>
   ```

   ```html
   <div class="radio-inline">
   		  <input type="radio"  name="killOrder" id="killOrder1" value="1"/>
   		  <label for="killOrder1">是</label>
   		</div>
   		<div class="radio-inline">
   		  <input type="radio"  name="killOrder" id="killOrder2" value="0" checked/>
   		  <label for="killOrder2">否</label>
   		</div>
   ```

   

   5. 加粗，同行显示，推荐strong

```html
<b>加粗b</b>
<strong>加粗s</strong>
```

6. 加斜体，同行显示，推荐i

```html
<i>加粗b</i>
<em>加粗s</em>
```

7. 换行标签，单标签

```html
<br> #<br/> 也可以
```

8. 分割线，单标签

````html
<hr>
````



### 图片



1. img，单标签
2. 宽高只设置一个，等比变化，同时设置可能变形
3. 绝对路径，相对路径都可以。相对路径返回上一级：“../”,上两级：“../../”

```html
<img src="路径",alt="图片加载失败解释说明文字"，title=“鼠标悬停显示图片标题”，width=“”，height=“”> 
```



### 超链接



```html
<a href="url" target=“_selt/_blank”>texttexttexttext</a> #url绝对路径要带“http://”；相对路径同图片规则
```

1. a标签，双标签，路径推荐相对路径

2. _blank，新开窗口

3. <a href=""或<a href="#"，刷新当前页

4. 本页或其他页面跳转到指定位置（毛点），id在同一页面不可重复。

   ```html
   <p id="maodian">
   </p>
   #
   <a href="页面路径#maodian">texttexttexttext</a>
   ```



### 表格

1. table

```html
<table border=“1” width=“100%” height=“50px” align=“left/right/center” bgcolor=“pink” cellspacing=“5px“ cellpadding=“5px”>#三行四列，属性名及双引号一定英文的
  <tr height=“” align=“left/right/center” bgcolor=“”>#行，不能设置宽度，可以设置高度
    <th></th>#表头，默认加粗
     <th></th>
     <th></th>
    <th width=“” align=“left/right/center” bgcolour=“”></th>列，可以设置宽度，不可以设置高度
  </tr>
  <tr>
  <td>
    <table>
      <tr>
        <td></td>
        <td></td>
      </tr>
      <tr>
        <td colspan="2"></td>#合并列
        <td rowspan=“2”></td>#合并行
      </tr>
    </table>
    </td>
    <td style="src=;background=;width=;height="></td>
    <td></td>
    <td></td>
  </tr>
  <tr><td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>
```

2. cellpadding：边框到内容的间距，cellspacing：边框间的间距
3. td的背景颜色会覆盖tr 
4. table内只能用tr，tr内只能放td，表格嵌套只能在td内放table
5. table内可以放图片 标题 段落等标签及内容。
6. rowspan：合并行，colspan：合并列

### 表单



1. 表单标签

   ```html
   <h3>输入</h3>
   请输入姓名：
   <input type="text"> placeholder="请输入姓名" value="默认值"
   
   <h3>密码</h3>
   请输入密码：
   <input type="password">#输入默认为加密形式
   
   <h3>请选择性别/单选</h3>#name必须设置相同属性才可以绑定
   <input type="radio" name=“gender” id="nan"><label for="nan">男</label>
   <input type="radio" name=“gender”>女 #设置name属性则男/女只能选一个，属性值需要与后端设置保持一致，lable属性通过id绑定前面id属性获取焦点
   <h3>请选择性别/多选</h3>
   
   爱好：
   <input type="checkbox" checked>多选1#checked默认选中，单选也适用此属性
   <input type="checkbox">多选2
   <input type="checkbox">多选3
   
   证件：
   <select name="" id=“”>
   <option value=“”>身份证</option>
   <option value=“”>护照</option>
   <option value=“” selected>驾照</option>#selected属性为默认选中，不设置默认选择第一个且为单选，可以在select标签设置mutiple属性控制多选
   
   文本域：
   <textarea name="" id="" cols="10" rows="5"></textarea>
   
   按钮：
     
   <h3>按钮</h3>
   <input type="button" value=“普通按钮”>
   <input type="reset" value=“重置按钮”>
   <input type="submit" value=“提交按钮”>
     #reset和submit需要配合form标签
     
   <button type="button">value="普通按钮"</button>
   <button type="reset"></button>value="重置按钮"</button>
   <button type="submit"></button>value="提交按钮"</button>
   
   ```

   

   2. 表单form

   ```html
   <body>
     
   <form action="sucess.html" method=“get”>#设置提交服务器地址“sucess.html”，get从服务器获取数据，也可以提交数据，数据会显示在地址栏，不安全；还有一种方式是“post”，post不在链接上显示数据
     
   <h3>输入</h3>
   请输入姓名：
   <input type="text"> placeholder="请输入姓名" value="默认值 name="name1"#name1是此属性在数据库中此属性的字段
   
   <h3>密码</h3>
   请输入密码：
   <input type="password" name=“psw”>
   
   <h3>请选择性别/单选</h3>
   <input type="radio" name=“gender” id="nan"><label for="nan">男</label>
   <input type="radio" name=“gender”>女 
   <h3>请选择性别/多选</h3>
   
   爱好：
   <input type="checkbox" checked name=“hobby” value=“1”>#value为具体选中的值
   <input type="checkbox" name=“hobby” value=“2”>多选2
   <input type="checkbox" name=“hobby” value=“3”>多选3
   
   证件：
   <select name="zhengjian" id=“”>
   <option value=“shenfenzheng”>身份证</option>
   <option value=“huzhao”>护照</option>
   <option value=“jiazhao” selected>驾照</option>
   
   文本域：
   <textarea name="wenben" id="" cols="10" rows="5"></textarea>
   
   按钮：
     
   <h3>按钮</h3>
   <input type="button" value=“普通按钮”>
   <input type="reset" value=“重置按钮”>
   <input type="submit" value=“提交按钮”>
     
   <button type="button">普通按钮"</button>#按钮必须在form标签内才可以配合form提交，在form外则失效
   <button type="reset">重置按钮</button>
   <button type="submit">提交按钮</button>
   
   
   </form>
     
     </body>
   ```

   

### 列表

1. 无需列表ul-li

```html
<ul>#默认上下有16px间距，padding-left有40px，ul里只能放li，ul与li都是独占一行
  <li>java
    <ol>
      <li>
        <a href="http://www.baidu.com">j2ee</a>
      </li>
      <li>spring</li>
    </ol>ol>
  </li>
  <li>javascript</li>
  <li>python</li>
</ul>
```

2. 有序列表ol-li

```html
<ol>默认上下有16px间距，padding-left有40px，ul里只能放li，ul与li都是独占一行
  <li>database
    <ul>#默认上下有16px间距，padding-left有40px，ul里只能放li，ul与li都是独占一行
  <li>java</li>
  <li>javascript</li>
  <li>python</li>
</ul>
  </li>
  <li>haddop</li>
</ol>
```

- 有序列表与无需列表可以相互嵌套，比如li里可以放ol或ul

3. 定义列表dl

   ```html
   <dl>
     <dt>中国</dt>#指定名词
     <dd>中华人民共和国</dd>#针对名词解释说明
     <dt>美国</dt>
     <dd>美利坚何总过</dd>
   </dl>
   ```

   - dl，dt，dd都是独占一行

### 其他

1. Div标签

   ```html
   <div>
     文本文本
   </div>
   ```

   - 看作一个布局的容器，在容器里添加或组织网页的结构。

   - 独占一行。

   - 没有任何样式，可以通过css自己设置。

     

2. 跑马灯marquee，屏幕右边进入，滚动到左侧消失，循环播放

```html
<marquee behavior="" direction="">跑马灯内容</marquee>
```



3. iframe

```html
<iframe src="http://ww.baidu.com" frameborder="0" width="300px" height="200px">
</iframe>
```

- 网页中嵌套其他网页，可以在线，也可以本地
- 需要设置宽高，宽高不够，自动出现滚动条



4. 删除线

```html
<del>$998</del>
```



5. fieldset,可以设置边框的标题

```html
<fieldset>
  <legend>登陆</legend>#标题标签
  <form action="">
    username:<input type="test">
    password:<input type="password">
  </form>
</fieldset>
```

- 带边框的标签

# css

## 基本概念

- Cascading Style Sheets，层叠样式表，作用在标签上，控制标签显示样式。

- 样式表：css代码

## 网页中样式来源

- 所有的html标签默认无样式。

- 但浏览器默认会给这些标签显示样式，不同浏览器显示会稍有不同。

- 浏览器设置中也可手动调整样式，如果代码中设置样式与浏览器设置冲突，需要调整浏览器设置。


## 代码样式

### 内联样式



```html
<div style="color:red;backgroud-color=pink">
Cascading Style Sheets，层叠样式表，作用在标签上，控制标签显示样式。 
</div>
```

- 标签的开始标签里添加style属性，属性值中书写css样式代码。
- 属性：属性值。如果有多个，则写多个。
- 哪里需要写哪里，但需要写多个



### 内部样式



- 在<head></head>添加<style></style>，通过选择器匹配（标签选择等很多匹配方式）

- 标签选择器：<style>{css属性名1：css属性值1；css属性名2：css属性值2；}</style>

- 结构样式一定程度分离，结构清晰，只需要写一个批量设置

  ```html
  <head>
  <style>
  div{
  color:red;background-color: antiquewhite;
  }
  </style>
  </head>
  <body>
  		<div>
  		Cascading Style Sheets，层叠样式表，作用在标签上，控制标签显示样式。 
  		</div>
  	</body>
  ```

  

### 外部样式



- 先创建“.css”文件，再再head中通过<link>引入css文件。
- 样式与结构分离
- 可以压缩css文件。

```html
<head>
		<meta charset="utf-8">
		<title></title>
		<link rel="stylesheet" href="css/new_file.css"/>
	</head>
	<body>
		<div>
		Cascading Style Sheets，层叠样式表，作用在标签上，控制标签显示样式。 
		</div>
	</body>
</html>
```

<css/new_file.css>

```css
div{
color:red;background-color: antiquewhite;
}
```



### 样式优先级



- 内连样式>内部样式/外部样式
- 内部样式与外部样式看谁在页面的下方，按照**浏览器解析页面由上至下**，相同css属性后被解析的会覆盖前面设定的属性值——或者说离作用标签更近的起作用。
- 相同的属性只取优先级最大起作用，不同属性叠加都都起作用，最终在浏览器检查模式时显示统一一套样式。



### 标签选择器



- 通过指定标签名找到并加载样式
- 没有制定范围会找到所有相应标签

```html
<head>
		<meta charset="utf-8">
		<style>
			p{
				color:red;
				font-size: 16px;
			}
			h1{
				color:red;
			}
		</style>
		<title></title>
	</head>
	<body>
		<p class="op">p1</p>
		<p class="op">p2</p>
		<h1 class="op">h1</h1>
	</body>
```



### 类选择器（class选择器）



- 通过标签设置类名找到标签。
- 声明时需要注意在类名前加“.”——“.类名”
- 标签需要作用多个类选择器样式，可以设置多个类选择器，使用时用空格隔开即可。
- 名称相同选择器后面的样式覆盖前面的样式。
- 选择器中间无空格代表并且的意思，匹配既有属性1也有属性2的标签。

```html
<head>
		<meta charset="utf-8">
		<style>
			.op{
				color: blue;
			}
      .oa{
				background-color: pink;
			}
      .oa.op{
				font-size: 99%;
			}
      #p1{
				属性：属性值；
			}
		</style>
		<title></title>
	</head>
	<body>
		<p class="op oa" id=p1>p1</p>
		<p class="op">p2</p>
		<h1 class="op oa">h1</h1>
	</body>
```



### id选择器



- id选择器可以用来找到设置了id的唯一的标签，通过“#id名{}”声明，id=id名引用。
- 字母，数字，下划线构成，不能以数字开头，不能包括特殊符号。
- 注意：id是唯一，以后通过js操作标签上的id，慎用。

```html
<head>
		<meta charset="utf-8">
		<style>
			.op{
				color: blue;
			}
      .oa{
				background-color: pink;
			}
      .oa.op{
				font-size: 99%;
			}
      #p1{
				属性：属性值；
			}
		</style>
		<title></title>
	</head>
	<body>
		<p class="op oa" id=p1>p1</p>
		<p class="op">p2</p>
		<h1 class="op oa">h1</h1>
	</body>
```



### 选择器优先级

- id选择器>类选择器>标签选择器
- 优先级与位置以及内联或内部外部无关。

## 样式表



### 背景



```css
<style>
  .box{
    width:400px;
    height:400px;
    border:1px solid:red;#solid为加边框的意思，这里可以看作边框颜色
    background-color:pink;#或者是“#777777”这种16进制色值；或者rgb模式：rgb（255，0，0～255）
    background-image:url(背景图片路径)#图片默认从左上角平铺，尺寸不足会继续以水平和垂直方向按照同样规则补齐，相当于background-repeat：repeat
    background-repeat:repeat-x，以水平方向右平铺；repeat-y，以垂直方向向下平铺；no-repeat，不平铺，留白。
    background-position:left/right/center/top/bottom。两两搭配，egx:background-position:left top or background-position:right bottom
    background-position:50px 50px；,or 100% 50%；
    css3特有：
    background-size:contain#一边（宽/高）铺满，另一边不管
    background-size:cover#铺满，超出部分裁掉，图片可能显示不完整
    background-size:50px 100px/百分比，图片有可能变形。只设置一个值，系统认为此值是宽度值，高度会根据图片形状等比变化。
    background-attachment:scrol#默认，会随着滚动条滚动；fixed：固定在页面上。
复合属性：background:pink url() no-repeat 50% 50%/50px 100px fixed ; /前面代表图片显示位置，后面代表图片显示大小
    背景设置如果属性重复设置，则按照执行顺序执行，后执行覆盖前面相同属性。
</style>
```

- 设置样式属性值必须带单位
- 背景图片和背景颜色同时存在，图片会覆盖颜色。

```html
<div class="box">box</div>
```



#### 雪碧图



- 将多张图片组合在一起形成一张图片，减少请求服务器次数，从而优化网页。

- 原理：通过背景样式 background-image和background-position来实现

- 步骤：

  1.  设置一个宽高刚好显示指定图标大小的标签
  2. 通过background-image引入雪碧图
  3. 再通过background-position设置雪碧图的显示位置，调整到指定的图标

  - 注意：在开发中，x轴正方向是水平向右，y轴的正方向是水平向下。

  

  <!--css部分-->

```css
<style>
			.box{
				width: 45px;
				height: 40px;
				border: 1px solid:red;
				background-image: url(img/xuebi.png);
			}
			
			/* 方案一：图片不平铺：background-repeat: no-repeat */
			/* 显示第一个图标及鼠标滑动效果 */
			.box1{
				background-repeat: no-repeat;
			}
			.box1:hover{
				background-position: 0px -40px;
			}
			
			/* 显示第五个图标及鼠标滑动效果 */
			.box2{
				background-repeat: no-repeat;
				background-position: 225px 0px;
			}
			.box2:hover{
				background-position: 0px -40px;
      }
			/* 方案二：页面平铺:background-repeat: repeat 或不写background-repeat属性*/
			
			.box3{
				background-position: 45px 0px;
			}
			.box3:hover{
				background-position: 0px -40px;
			}
			
		</style>
```

<!--html部分-->

```html
<div class="box box1"></div>
<div class="box box2"></div>
<div class="box box3"></div>
```



### 文本样式



```html
<style>
			h1{
				color: red;#十六进制或rgb（0 255 0～255）
				text-align:left/right/center
			}
			p{
				text-align:left/right/center可以控制容器内内容及元素的对其方式，如div内包含的span内的内容也可以做到居中。
				line-height: 30px/100%;/2 /* 100%是与字体大小相同 */2为字体大小的倍数
				font-size: 16px;
				text-decoration:underline/* 下划线 *//line-through/* 中划线 *//overline/* 上划线 *//none;
				letter-spacing:20px ;/* 字符间距 */一个字母是一个字符，一个文字是一个字符，适合中文内容
				word-spacing: 20px;/* 字间距 */以空格为参照，空格隔开为一个字，适合英文内容
				text-indent:20px;/* 首行缩进 */
				text-transform: capitalize/uppercase/lowercase;none /* 首字母大写/全部大写/全部小写 */
				direction:rtl/ltr;/* 从右到左/从左到右 */
			}
			.box{
				width: 200px;
				height: 100px;
				border: 1px solid red;
				text-align: center;/* 水平居中 */
				line-height: 100px/100%; /* 单行文字行高等于div高度实现垂直居中 */
				
			}
		</style>
```



### 行和块分类



- 行内标签（行内元素）

  - 文本内容：

    - 共享一行

    - 不支持宽高，由里面的内容决定

    - ```html
      <Span> <label> <i> <a> 
      ```

      

- 块级标签（块内元素）

  - 页面布局

    - 独享一行

    - 支持宽高设置

      ```html
      <Div><p> <h> <table> <tr> <ol> <ul> <li> 
      ```

  

- 行内块级标签（行内块级元素）

  - 例如<img>标签

  - 元素同行显示

  - 支持宽高

    ```html
    <Td> <img> <input> <button> <select>
    ```

  

- 相互转换

  - 通过display属性进行转化

    - display-inline：转为行内元素
  - display-inline-block：转为行内块级元素
    - display-block：转为块级元素
  - display：none：隐藏元素，元素从页面中消失，页面会重新绘制
  
  

### 字体样式



```html
<head>
		<meta charset="utf-8">
		<style>
			div{
				font-family: "宋体",Arial, Helvetica, sans-serif;
				/* 每个浏览器或系统默认字体不同，如需要统一则需要在样式中设置。
        设置多种字体需要用逗号隔开，如果字体名中文或多单词需要使用单号或双引号，
				系统会在系统内找第一个字体，如果没有第一种就找第二种字体，以此类推，如果都
				没有会使用到sans-serif字体，因为此中字体通用*/
				font-size: 20px;
				font-weight: 100;/* 100-900 bold bolder lighter normal，有些字体不支持bolder */
				font-style: italic;italic 斜体 oblique 倾斜
			}
      
      @fontface{
				font-family: myfont;/* 给字体取名个名字 */
				src:url(font/xxx.ttf),url(font/xxx.worf)/* 字体文件可以有多个格式，用英文逗号隔开。 */
			}
			/* 可以引入字体下载，一个fontface只能引入一个字体，如想引入多个，则需要写多个fontface
			@font-face */
		</style>
		<title></title>
	</head>
	<body>
		<div>
			 文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本
			 文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本
			 文本
		</div>
		<b>bold</b> <!-- 标签默认加粗，如果需要更改样式可以使用normal等属性 -->
	</body>
```



### 字体图标



- 字体是以图标的方式展示，例如fontawesome，可以与字体一样通过css设置属性，如图标的大小，颜色，阴影等。

- 产品地址：https://fontawesome.dashgame.com

- 页面引入css地址：

  ```html
  <link rel="stylesheet" href="path/to/font-awesome/css/font-awesome.min.css">
  <style>同样可以添加自己定义的样式
  			.iconfont{
  				color: red;
  			}
  		</style>
  ```

  - 而后代码编辑具体样式

    ```html
    <i class="fa fa-camera-retro"></i> fa-camera-retro
    <i class="fa fa-camera-retro fa-lg"></i> fa-lg #33%增大
    <i class="fa fa-camera-retro fa-2x"></i> fa-2x #二倍大小
    <br>
    <ul class="fa-ul">#二倍大小列表样式
      <li><i class="fa-li fa fa-check-square"></i>List icons</li>
      <li><i class="fa-li fa fa-check-square"></i>can be used</li>
      <li><i class="fa-li fa fa-spinner fa-spin"></i>as bullets</li>
      <li><i class="fa-li fa fa-square"></i>in lists</li>
    </ul>
    <br>
    <span class="fa-stack fa-lg">#使用 fa-stack 类作为父容器， fa-stack-1x 作为正常比例的图标， fa-stack-2x 作为大一些的图标。
      <i class="fa fa-square-o fa-stack-2x"></i>
      <i class="fa fa-twitter fa-stack-1x"></i>
    </span>
    
    <i class="fa fa-shield fa-rotate-90 iconfont"></i> fa-rotate-90<br>
    #iconfont为自己定义的样式，叠加在fontawesome样式上
    ```



### 超链接



```html
<a href="http://www.baidu.com">baidu</a>
```



```css
<style>
			/* 未访问链接添加样式 */
			a:link{
				color: red;
			}
			/* 访问过链接添加样式 */
			a:visited{
				color: green;
			}
			/* 鼠标划过样式 */
			a:hover{
				color: blue;
			}
			/* 访问过与鼠标滑过样式权重一致，在后面的会覆盖前面的样式。
			所以hover属性必须放在link及visited后面才会有效果，active放在hover后面才有效 */
			/* 鼠标按住不放样式 */
			a:active{color: yellow;}
		</style>
```



### 列表样式



```html
<body>
		<ul><!-- 默认上下16px的margin，padding-left:40px -->
			<li>aaa</li>
			<li>bbb</li>
			<li>ccc</li>
		</ul>
</body>
```



```css
<style>
			li{
				list-style-type:none; 
				/* 无项目标记符号，还可更改参数更改列表前面项目符号的样式，入cicle，lowerroman等*/ ;
				border: 1px solid red;
				/* 可以设置列表项标志的位置 */
				list-style-position:outside;
				/* 标志在标签外面，inside在标签里面 */
			    list-style-image: url();
				/* 自定义项目符号图片，但是要控制图片尺寸大小，css无法控制图片大小 */
        list-style:none /* 符合属性*/
			}
		</style>
```

- 如果需要鼠标移动到一级菜单才显示二级菜单，可以通过ur加li实现一级菜单，再在li中嵌套ur加li实现二级菜单。
- 而后用display：none实现二级菜单不显示，再用鼠标滑过时：标签:hover.class实现鼠标滑过显示即可，display：block



### 表格样式



```css
<style>
			table{
				border: 1px solid red;
				width: 900px;
				height: 300px;
				border-spacing: 0;/* 单元格之间间距 */
				border-collapse: collapse;/* 表格边合并，合并后边框为1px，不是border-spacing合并后为2px */
			}
		</style>
```



### link和@import



- 两种方式都可以引入css。
  - link是一种标签，@import是一种语法
  - link不仅可以引入css，还可以引入其他文件格式。@import只能引入css。
  - 加载时间：link是随着页面加载而加载，@import等页面加载完成再加载
  - link兼容性比@import好
  - link可以被js控制，@import不能。



```html
<link ref="stylesheet" href="css/">

@import url(css/)
```



## 盒模型



### 标准盒子结构



- content：内容区，存放内容空间，文本，图片等。
- padding：内边距，内容到边框的距离。padding/padding-top/bottom/left/right。
- border：边框，也可以上下左右分别设置。
- margin：外边距，盒子与盒子之间的间距（父子关系，兄弟关系），同样可以上下左右分别设置。
- **width与height是content的宽和高**。



### 边框



- 给盒子添加边框

```html
<style>
			.box{
				width: 200px;
				height: 200px;
				background-color: pink;
				border-left-width:10px;
				border-left-style:solid;/* 实线 */
				border-left-color: red;
				/* 颜色同样可以是16进制和rgb */
				border-top: 10px dotted green;/* 点线 */
				border-right: 10px double red;/* 双实线 */
				border-bottom: 10px dashed blue;/* 虚线 */
				/* 符合属性 */
				border: 10px solid yellowgreen;
			}
</style>
```

- 边框至少设置两个值：宽度和类型，默认显示黑色。

- 边框可以撑大盒子整体占位。

- 渲染原理：只设置一条边，是矩形形状，设置相邻边框，想接部分沿着对角线均分。

  ```html
  .box1{
  				width: 200px;
  				height: 200px;
  				background-color:red;
  				border-left:10px red;
  				border-top:10px green;
  				/*  只设置一条边，是矩形形状，设置相邻边框，想接部分沿着对角线均分 */
  			}
  ```

- 可以通过边框设置三角形，三边透明，一边不透明或三边不透明，一边透明。

```html
<style>
			.box{
				width: 0px;
				height: 0px;
				border-left: 100px dotted red;
				border-top: 100px dashed yellow;
				border-right: 100px double blue;
				border-bottom: 100px solid green;
			}
			.box1{
				width: 0px;
				height: 0px;
				border-left: 100px solid transparent;
				border-top: 100px solid transparent;
				border-right: 100px solid transparent;
				border-bottom: 100px solid yellow;
			}
		</style>
```



### 内边距padding



- 设置内容到边框的距离
- 语法：

```html
<style>
			.box{
				width: 100px;
				height: 100px;
				border: 1px solid red;
				padding-left: 10px;
				padding-top: 10px;
				padding-bottom: 10px;
				padding-right: 10px;
				/* 符合属性 设置一个值代表四周都为此值；设置两个值第一个代表上下，第二个左右；
				三个值第一个值代表上，第二个代表左右，第三个代表下；四个值则按照从上开始，顺时针付值。*/
				padding: 30px;
				padding: 30px 60px;
				padding: 30px 60px 90px；
				padding: 30px 60px 90px 120px;
			}
		</style>
```



- 导航中因为不同文字长短可通过设置左右padding并且<li>不设宽度即可实现。
- padding会撑大整个盒子区域，背景会覆盖padding区域。
- 如果超出外部容器，可以在外部容器使用overflow：hidden来解决。

```css
.header .navi ul li{
	/* width: 95px; */
	height: 50px;
	display: inline-block;
	vertical-align: middle;
	text-decoration: none;
	text-align: center;}

.header .navi ul li a{
	display: inline-block;
	font-size: 11px;
	color: #9d9d9d;
	/* width: 100px; */
	height: 50px;
	font-size: small;
	margin-top: 15px;
	text-align: center;
	text-decoration: none;
	padding:0px 10px;
```



### 外边距margin



- 盒子和盒子之间的距离。
- 语法参考padding语法，是一致的。



- 盒子之间关系：

#### 兄弟关系

- 在垂直方向相邻margin会重叠，按照较大的值。
- 水平方向不重叠，直接相加即可。



#### 父子关系

- margin-top，子元素会传递给父元素，因为如果找不到父元素的边界，就传递给父元素。 
- 解决margin-top传递问题：
  - 需要给父元素设置边界，如border或padding，但是会改变父元素盒子大小。
  - 给父元素添加overflow:hidden，超出部分溢出。
    - 借助BFC容器的特点：里面的元素如何排列不会影响容器外的元素。

- margin-bottom/left/right不存在传递性的问题



### 标准盒子大小的计算



- css中的width和height是针对content
- padding设置会增加盒子大小
- border设置会增加盒子大小计算
- margin不会计入盒子大小计算

- 标准盒子真正大小的计算：
  - 宽度=content（width）+padding*2（左右padding）+border*2（左右border）
  - 高度=content（height）+padding*2（上下padding）+border*2（上下border）

- 标准盒子所占空间的大小计算：

  - 宽度=content（width）+padding*2（左右padding）+border*2（左右border）+margin*2（左右margin）
  - 高度=content（height）+padding*2（上下padding）+border*2（上下border）+margin*2（上下margin）

  

### 怪异盒子（IE盒模型）



- IE盒模型的宽高设置包含了内容区，padding区和border区

- 可以通过box-sizing来转换,主流浏览器都是标准盒模型

  - content-box：标准盒模型
  - border-box：怪异盒模型

  ```html
  box-sizing:border-box
  ```

- 怪异盒子真正大小：
  - 宽度=width（content+padding+bording）
  - 高度=height（content+padding+bording）

- 怪异盒子所占空间真正大小
  - 空间宽度=盒子宽度+margin*2
  - 空间高度=盒子高度+margin*2

### 拓展

- 宽度设置百分比和默认不设置的区别
  - 百分比：参考父元素宽度设置，设置content内容区域的宽度，添加padding+padding会更改盒子大小，添加margin会改变盒子所占空间大小。
  - 不设置：auto，代表动态获取到父元素内容宽度，总宽度是包含border，padding和margin
    - margin：0 auto：上下边距为0，左右为auto，代表自适应将剩余空间均分左右代表均分。

## 选择器

- css由两部分组成

  - 选择器：找到页面中的制定标签，丰富选择器写法，可以精确找到页面中某些标签。
  - css样式代码：样式之间需要用分号隔开

  

### 选择器



#### 标签选择器



- 通过标签找到满足条件的标签，没有自动范围，找到页面中所有标签

- 语法：

  ```css
  标签名{
    css代码
  }
  ```

  

#### 类选择器



- 通过class名称找到对应选择器，标签上class名可以相通，可以提取公共样式。

- 同一标签可以作用多个class标签选择器的样式。

  ```css
  .class名{
    css code
  }
  ```

  

#### id选择器



- 通过标签上id名找到对应的标签，id是唯一，只能找到页面中唯一的标签

- id命名规则

  - 数字，字母，下划线和横线构成
  - 不能以数字开头，不能包含特殊符号。

- 语法：

  ```css
  #id名{
    css code
  }
  ```

  

#### 后代选择器



```css
<style>
			/* 后代选择器（派生选择器）：找到标签里满足条件的所有后代标签，找到class名为box标签里面所有的p标签。
			可以找到儿子，孙子。。。 */
			.box p{
				background-color: pink;
			}
			/* 子元素选择器，找到标签里满足条件的直接子元素，中间使用>隔开
			 只找到box下面一级符合条件的元素--儿子元素，孙子重孙子等不符合
       >前后是否有空格不影响*/
			.box > p{
				
			}
		</style>
```



```html
<body>
		<div class="box">
			<ul>
				<li>
					<p>p1</p>
				</li>
				<li>
					<p>p2</p>
				</li>
				<li>
					<p>p3</p>
				</li>
			</ul>
			<p>p4</p>
		</div>
		<p>p5</p>
	</body>
```



#### 兄弟选择器



```css
<style>
			/* 相邻兄弟选择器，用+隔开，找到满足条件相邻后面的第一个标签 
			找到ul标签里面的class名为li2的标签后面相邻的第一个li标签*/
			ul .li2 + li{
				border: 1px solid red;
			}
			/* 找到ul标签里面所有class名为li2的标签后面相邻第一个兄弟li标签的后面相邻的第一个兄弟li标签 */
			ul .li2 + li +li{
				border: 1px solid green;
			}
			/* 后续兄弟选择器,使用～隔开，找到满足条件标签后面所有的兄弟标签
			找到页面中ul标签的后代中class名为li2后面所有标签为li的兄弟标签*/
			ul .li2 ～ li{
				border: 1px solid red;
			}
		</style>
```



```html
<body>
		<ul>
			<li>大吉大利</li>
			<li class="li2">今晚吃鸡</li>
			<li>召唤师峡谷</li>
			<li>小乔</li>
			<li>大乔</li>
		</ul>
	</body>
```



**注意**：相邻与标签匹配同等重要，不相邻但同级不符合要求，不能作用。



```css
.box+p{
				/* box标签后面相邻的第一个标签是box1的div2，而不是p标签，所以这样的设置无效 */
				background-color: pink;
			}
```



```html
    <div class="box">div1</div>
		<div class="box1">div2</div>
		<p>p1</p>
```



#### 组合选择器



```css
<style>
			/* 多种选择器组合起来，使用，隔开，每种选择器都作用相同的样式 */
			h1{
				color: red;
			}
			p{
				color: pink;
			}
			span{
				color: gray;
			}
			h1,p,span{
				color: red;
			}
		</style>
```



```html
<body>
		<h1>今天下雨</h1>
		<p>适合睡觉</p>
		<span>上课不准</span>
	</body>
```



#### 属性选择器



- 通过标签的属性找到对应标签

|         选择器         |                           描述                           |
| :--------------------: | :------------------------------------------------------: |
|     **【属性名】**     |              **用于选取带有特定属性的元素**              |
| **【属性名=属性值】**  |      **用于选取带有指定属性和值的元素（精确匹配）**      |
| **【属性名*=属性值】** |      **匹配属性中包含指定值的某个元素（模糊匹配）**      |
|  【属性名～=属性值】   |            用于选取属性值中包含指定词汇的元素            |
|  【属性名｜=属性值】   | 用于选取带有指定值开头的属性值的元素，该值必须是整个单词 |
|   【属性名^=属性值】   |             匹配属性值以指定值开头的每个元素             |
|   【属性名$=属性值】   |             匹配属性值以指定值结尾的每个元素             |



```css
<style>
			/* 选择指定属性名的标签 */
			[type]{
				border: 1px solid red;
			}
			/* 选择指定属性名和属性值的标签-精准匹配 */
			[type=password]{
				border: 1px solid red;
			}
			/* 没有空格代表并且的意思，表明寻找既有type也有name的标签 */
			[type][name]{
				border: 1px solid red;
			}
			/*  属性值带有op的标签，op只要包含即匹配，如aop op1。。。 */
			[class *= op]{
				border: 1px solid red;
			}
			/* 属性值包含特定词汇的标签，精确匹配，aop op1不行，但是bopc op可以 */
			[class ~= op]{
				border: 1px solid red;
			}
			/* 属性名属性值是以指定值开头 必须是一个单词 op op1/op1 op都不行，op-op1是可以的*/
			【class｜=op】{
				border: 1px solid red;
			}
			/* 属性值以指定值开头即可，op oppo op1 op-oo都可以  */
			【class ^= op】{
				border: 1px solid red;
			}
			/* 属性值以指定值结尾,不需要是单独单词，只要以结尾即可 */
			[class $= pc]{
				border: 1px solid red;
			}
		</style>
```



```html
<body>
		<input type="text" placeholder="please input your name" class="op">
		<input type="password" name="" id="" class="aop">
		<p class="bopc op">p1</p>
		<button type="button" class="coap">button1</button>
		<button class="op1">button2</button>
	</body>
```



#### 伪类选择器



- 给浏览器上标签添加一些功能性内容或效果

|  选择器  |                           描述                           |
| :------: | :------------------------------------------------------: |
|  :link   |               向未被访问过的超链接添加样式               |
| :visited |                向被访问过的超链接添加样式                |
|  :hover  |                  鼠标移入元素上添加样式                  |
| :active  | 向被激活的元素加添加样式，如鼠标正在点击某个链接时的样式 |
|  :focus  |   向拥有键盘输入焦点的元素添加样式，如input输入内容时    |

- 注意：
  - :link和:visited是超链接专属
  - :hover必须放在:visited和:link之后，:active必须放在:hover之后，顺序：L-V-H-A

```html
<body>
		<input type="text">
	</body>
```



```css
<style>
			input{
				border: 1px solid red;
			}
			input:focus{
				border: 5px solid dodgerblue;
				/* 边框外面一圈轮廓，需要用outline取消掉默认属性才能实现 */
				outline: none;
			}
		</style>
```



#### 伪元素选择器



- 可以在标签开头或结束添加一块渲染区域，该区域可以添加样式
- 选择器：
  - ::first-letter：找到标签里第一个字符区域添加样式
  - ::first-line：找到标签里第一行区域添加样式
  - ::before：
    - 在标签**内容**之前添加一块渲染区域，可以添加内容或样式。
    - 需要添加content使用，否则无效果。
    - 行内元素，非block，不可设置高宽，如需要转化支持宽高，需要display设置转换。
  - ::after：
    - 在标签**内容**之后添加一块渲染区域，可以添加内容或样式。
    - 需要添加content使用，否则无效果
    - 行内元素，非block，不可设置高宽，如需要转化支持宽高，需要display设置转换。

```css
<style>
			.box{
				width: 500px;
				border: 1px solid red;
			}
			/* 找到标签里第一个字符区域添加样式 */
			.box::first-letter{
				color: rebeccapurple;
				background-color: pink;
			}
			/* 找到标签里第一行区域添加样式 */
			.box::first-line{
				background-color: red;
			}
			/* 在标签内容之前添加一块渲染区域，可以添加内容或样式，需要添加content使用，否则无效果 */
			/* 行内元素，非block，不可设置高宽 */
			.box::before{
				content：“css”;
				background-color: blue;
			}
			/* 在标签内容之后添加一块渲染区域，可以添加内容或样式，需要添加content使用，否则无效果 */
			/* 行内元素，非block，不可设置高宽 如需要转化支持宽高，需要display设置转换*/
			.box::after{
				content：“css”;
				background-color: blue;
			}
		</style>
```



```html
<body>
		<div class="box">
			<!-- ：：before -->
			空间站缓缓飞过祖国大地，仰望星河，看闪耀的“中国宫”过境祖国上空。
			舱壁上鲜艳的五星红旗与蔚蓝色的星球交相辉映。虽遥遥千里，但是如此清晰而美好。
		</div>
	</body>
```



- 案例：鼠标滑过文字出现二维码浮层，浮层上边框居中接近文字处为三角形图形。

  

```html
<div class="box">二维码文本</div>
```



```css
.box::before{
				/* 向区域添加内容 */
				content: "";
				display: block;
				width: 0;
				border: 10px solid transparent;
				border-bottom: 10px solid tomato;
			}
```



***其中三角形位置通过后面介绍的css定位来实现，此处暂不显示***



#### **通配符选择器**



- 找到页面中所有元素

- 语法：

  ```css
  *{
    css代码
  			}
  ```

  

### 选择器的分类



- 基础选择器：id选择器，类选择器，标签选择器，属性选择器，伪类选择器，伪元素元素器，通配符选择器

  

- 复合选择器：后代选择器，子元素选择器，兄弟选择器（相邻，后续）



### 选择器的权重



1. 相同选择器：内联权重最大，内部和外部采用就近原则

2. 基础选择器权重大小：id选择器>类选择器(属性选择器)>标签选择器>通配符选择器>继承样式

3. 组合选择器权重需要计算，将所有用到的选择器叠加进行对比

   #### 组合选择器权重计算方式

1. 加法运算：将所有选择器权重相加，对比大小，权大的更高。
   - 内连样式：1000
   - id选择器：100
   - 类（属性）选择器：10
   - 标签选择器：1
   - 继承的样式：0

```css
<style>
.box ul li .p2
/* 10+1+1+10 /（0，0，2，2）*/
{
  background-color:pink;
}
#mybox ul li p{
  /* 100+1+1+1*/（0，1，0，3）/
  background-color:red;
}
.box ul1 li .p2{
  /* 10+10+1+10*/（0，0，3，1）/
  background-color:yellow;
}
</style>
```



***注意：单纯的十个标签选择器权重还是小于类选择器，不满足满十进一原则***



2. 4个0（0，0，0，0）

- 第一个0:是否内连样式，有则为1，无则为0。
- 第二个0:代表id选择器的个数。
- 第三个0:代表类（属性）选择器的个数。
- 第四个0:代表标签选择器的个数。



***规则：从第一个0开始对比，值大的权重更高，如果值相同，对比第二个0的值，以此类推。如果最后一个0都相等，后面覆盖前面。***



## css的继承



- 继承更多出现在编程语言中，js学习继承，父级元素的样式子元素可以作用。

- css很多属性，有些可以被继承，有些不可以，需要手动设置。

  

- 继承分为两类：

  

  1. 自动继承：子元素自动继承父元素的样式。

     - font系列：font-size，font-family，font-weight，font-style

     - 文本样式：color ，text-align，line-height，text-decoration，text-indent，letter-spacing，word-spacing，text-transform

     - list-style：li可以从ul和ol继承。

     - 鼠标样式：cursor：pointer（抓手）

       

  2. 手动继承：子元素不能自动继承父元素的样式，需要手动设置继承。

     - 宽度width
     - height
     - border
     - padding
     - margin
     - background
     - 。。。

***注意：但以上这些属性值设置为“inherit”时则可以表示为从父元素继承。***



## 浮动



### 块级元素同行显示



1. display：inline-block，中间存在5px间距，浏览器兼容问题。

2. 浮动

   

### 浮动



- 让元素同行显示，排列不下自动换行

- 语法：

  ```css
  float:left|right|none;
  ```

  - left：左浮动
  - right：右浮动
  - none：不浮动，默认值。

- 特点：
  1. 浮动元素可以同行显示，排列不下自动换行，不存在浏览器兼容问题
  2. 浮动元素会脱离标准文档流，在标准文档流之上
  3. 浮动元素原来的所占的空间不存在，若原父元素未设置宽高等属性，有可能导致父级元素塌陷。
  4. 行内元素设置浮动后支持宽和高属性

- 注意：
  - 只有设置了浮动的元素才可以同行显示
  - 多个元素同时浮动，第一个浮动元素找父盒子的边界，后面的浮动元素找前面元素的边界。
  - 块级元素设置浮动后，如果不设置宽度，默认是auto，宽度由内容决定。



### 标准文档流



- 概念：在页面布局过程中，元素按照从上倒下，从左到右，块级独占一行，行级元素同行排列的规则。



### 脱离文档流



- 概念：在页面布局过程中，元素不再遵循标准文档流规则，有自己的排列规范。



### 浮动练习



```html
<body>
		<div class="container">
			<div class="leftbox">
				<div class="box1"></div>
				<div class="box1"></div>
			</div>
			<div class="centerbox">
				<div class="box2"></div>
				<div class="box2"></div>
				<div class="box2"></div>
			</div>
			<div class="rightbox">
				<div class="box1"></div>
				<div class="box1"></div>
			</div>
			
		</div>
	</body>
```



```css
<style>
			.container{
				width: 900px;
				height: 600px;
				border: 1px solid red;
				margin: 0 auto;
			}
			.leftbox{
				width:300px;
				height: 600px;
				background-color: green;
				float: left;
			}
			.centerbox{
				width: 300px;
				height: 600px;
				background-color: pink;
				float: left;
			}
			.rightbox{
				width: 300px;
				height: 600px;
				background-color: tomato;
				float: left;
			}
			.box1{
				height: 300px;
				border: 1px solid white;
				box-sizing: border-box;
			}
			.box2{
				height: 200px;
				border: 1px solid white;
				box-sizing: border-box;
			}
		</style>
```



### 浮动的影响



- 非浮动元素会占用可浮动元素原来位置
- 非浮动元素里面的文本会被浮动元素挤出
  - 实现图文混排

```html
<body>
		<img src="" alt="">
		<p>
			让元素同行显示，排列不下自动换行语法：``cssfloat:left|right|none;```-
			left：左浮动right：右浮动none：不浮动，默认值。让元素同行显示，排列不下
			自动换行语法：``cssfloat:left|right|none;```- left：左浮动right：右浮动
			none：不浮动，默认值。
		</p>
	</body>
```



```css
<style>
			img {
				float: left;
				width: 60px;
			}
		</style>
```



- 子元素浮动，父元素高度塌陷



### 清除浮动



- 通过clear属性来清除浮动，清除浮动元素对非浮动的影响

- 语法：

  ```css
  clear：left｜right｜both；
  ```

  - left：清除做浮动影响

  - right：清除右浮动影响

  - both：清除左右浮动影响

    

### 清除浮动的方法



1. 在受影响元素添加clear属性清除浮动

2. 在浮动和非浮动元素之间添加br标签，通过br的clear=all属性将浮动与非浮动元素隔开，起到清除浮动影响

3.  通过空白的div添加clear：both将浮动与非浮动元素隔开，起到清除浮动影响

   

   ```html
   <div class="box1">box1</div>
   <br clear="all">
   <div style="clear:both;"></div>
   </div>
   <div class="box2">box2</div>
   ```

   ```css
   <style>
   .box1{
     width:200px;
     height:200px;
     float:left;
   }
   .box2{
     width:300px;
     height:300px;
   }
   
   ```

   

4. 给父元素添加伪元素选择器（推荐）

```html
<div class="container clearafter">
			<div class="box"></div>
			<div class="box"></div>
			<div class="box"></div>
			<div class="box"></div>
			<br clear="all"><!-- 清除box float对container塌陷的影响 -->
			<div style="clear:both;"></div><!-- 清除box float对container塌陷的影响 -->
		</div>
```



```css
.clearafter::after{
				content: "";
				clear: both;
				display: block;
			}
```



- 注意：overflow：hidden可以解决子元素浮动，父元素高度塌陷的问题，是取消浮动的影响，借助bfc容器的特点，这个容器里面的浮动元素会参与副元素高度的计算。

  

### 清除浮动练习



```html
<div class="container clearafter">
			<div class="box"></div>
			<div class="box"></div>
			<div class="box"></div>
			<div class="box"></div>
			<br clear="all"><!-- 清除box float对container塌陷的影响 -->
			<div style="clear:both;"></div><!-- 清除box float对container塌陷的影响 -->
		</div>
```



```css
<style>
			.container{
				width: 1000px;
			}
			.box{
				width: 200px;
				height: 200px;
				background-color: pink;
				float: left;/* 子元素设置浮动后，父元素未设置则会高度塌陷 */
			}
			.clearafter::after{
				content: "";
				clear: both;
				display: block;
			}
```



## 定位

### 如何让盒子移动到指定位置



1. margin负值，破坏文档流进行移动

   - 标准文档流：在页面布局过程中，元素从上到下，从左到右，块状元素独占一行，行级元素共享一行

   - 破坏文档流：在页面布局过程中，元素在移动过程中不遵循标准文档流规范，移动完成后仍然遵循标准文档流 

   - 脱离文档流：在页面布局中，元素不在遵循标准文档流，有自己的排列规范，如float

     

- 应用场景：头部内容和banner重叠，重叠部分可以使用此方式，如qq安全中心。



2. 定位：让元素移动到指定位置



### 静态定位



- 默认每个标签都是静态定位

  ```html
  position: static;/* 静态定位 */
  ```

  

### 相对定位



- 概念：元素参考原来的位置，按照指定方向进行移动

  

- 语法：

  ```html
  position：relative
  ```

​               left：距离参考位置的左边缘进行移动
​				 top：距离参考位置的上边缘进行移动
​				 right：距离参考位置的右边缘进行移动
​				 bottom：距离参考位置的下边缘进行移动



- 特点：

  1. 设置相对定位的元素会破坏文档流进行移动

  2. 只设置相对定位，元素不会有变化，一旦设置了偏移量，破坏文档流参考元素按照原来位置进行移动，

  3. 原来的空间还占用

  4. 子元素设置相对定位，父元素进行移动，子元素跟着移动，原因在于子元素原来位置会随父元素先进行移动，参考位置变化，所以会跟着父元素一起变化。

  5. 一般配合绝对定位一起使用

     注意：

     - 行内元素设置相对定位后仍旧不支持宽高



### 绝对定位



- 元素会脱离文档，按照制定位置进行移动

  ```html
  position: absolute;
  ```

  

  ​               left：距离参考位置的左边缘进行移动
  ​				 top：距离参考位置的上边缘进行移动
  ​				 right：距离参考位置的右边缘进行移动
  ​				 bottom：距离参考位置的下边缘进行移动

  

- 特点：
  - 设置绝对定位元素脱离文档流
  - 只设置绝对定位，元素是在当前位置脱离文档流，下面的元素会占据绝对定位元素原来的位置，但绝对定位元素会在原来位置显示在最高层。
  - 一旦设置偏移量，元素默认参考整个文档进行移动
  - 原来空间不再占用

- 注意：

  - 行内元素设置绝对定位后支持宽高

  

#### 定位父级

- 结构父级：子元素在html代码结构上的父标签

- 定位父级：设置的绝对定位的元素进行移动时的参考位置，默认按照整个文档进行移动，一旦父级元素设置**相对定位，绝对定位和固定定位**后，参考**最近**定位父级别元素进行移动

- 定位父级可以使用相对定位，绝对定位，固定定位，一般使用相对定位，因为还是按照文档流进行排列（子绝父相）。

  

### 固定定位



- 元素脱离文档流，按照指定位置进行移动，会固定在页面上，不会随着滚动条滚动

  

- 语法：

  ```html
  position：fixed
  ```

  

​               left：距离参考位置的左边缘进行移动
​				 top：距离参考位置的上边缘进行移动
​				 right：距离参考位置的右边缘进行移动
​				 bottom：距离参考位置的下边缘进行移动     

- 特点：

  - 固定定位的元素会脱离文档流，在标准文档流之上

  - 会固定在页面之上，不会随着滚动条滚动

  - 只设置固定定位，当前位置脱离固定在页面上，如果设置偏移量，参考整个文档进行移动，固定在页面上

  - 原来的空间不再占用

    

- 应用场景：头部导航，小广告，登录框



### 定位层级



- 多个元素定位只针对**固定定位，相对定位，绝对定位**有效，其他无效。
- 语法：

```
z-index：auto/0/1/2。。。
```



- 定位层级：

  - auto默认值，相当于0，标准文档流元素相当于0

  - 数字越大，层级越高，显示在上方，数字相同按照代码结构规则进行排列，后面的元素盖住前面的元素（参考代码结构）。

  - 有元素层级设置为负值时显示标准文档流元素后面，即被覆盖。

    

### 盒子居中技巧



- *margin：auto auto*：可以让元素水平居中，不能垂直居中。

  - auto是一个值，自适应，浏览器自动计算得出值，一般垂直方向内容撑开，高度是在变化，垂直方向上auto禁用

    

- 方案一：
  - 父元素相对定位
  - 小盒子绝对定位，top，bottom，left，right都为0，然后*margin：auto auto*

```css
<style>
			.container{
				width: 400px;
				height: 400px;
				border: 1px solid red;
				position: relative;
				/* 设置定位父级 */
			}
			.box{
				width: 200px;
				height: 200px;
				background-color: green;
				/* 设置绝对定位 */
				position: absolute;
				top: 0;
				bottom: 0;
				left: 0;
				right: 0;
				margin: auto auto;
			}
		</style>
```



```html
<div class="container">
			<div class="box"></div>
		</div>
```



- 方案二：绝对定位设置calc函数进行计算

  - 大盒子相对定位

  - 小盒子绝对定位

    top：calc（50%-小盒子高度一半）

    left：calc（50%-小盒子宽度一半）

```css
<style>
			.container{
				width: 400px;
				height: 400px;
				border: 1px solid red;
				position: relative;}
.box{
				width: 200px;
				height: 200px;
				background-color: green;
        position: absolute;
				top: calc(50%-100px);
				left: calc(50%-100px);
			}
</style>
```



```html
<div class="container">
			<div class="box"></div>
		</div>
```



- 方案三：margin-top与margin-left组合使用，与方案二逻辑一致--都是通过calc函数计算。
  - 但是只适用于大盒子为正方形（宽高一致）的情况。
  - margin与padding设置百分比，无论哪个方向，都是参考父元素的**宽度**。

## FC



FC（Formating Context）格式化上下文，CSS2提出的一个视觉渲染概念。他是页面中的一块渲染区域，他决定了其子元素如何排列，以及和其他元素之间的关系。



### BFC

Block Formating Context：块级格式化上下文

- 指的是页面中一个标签，不一定是块级标签，有指定的满足条件，有自己的排列规范，决定了BFC区域的子元素如何排列，与其他元素之间的相互关系（BFC是页面中的一个块级渲染区域）

  

### BFC区域特点



- 内部的box会在垂直方向一个接一个显示（标准文档流）
- box垂直方向的距离由margin决定，属于同一个BFC的两个相邻盒子的margin发生重叠
  - 属于不同区域的BFC区域的盒子在垂直方向不发生重叠

- 每个元素左外边缘（margin-left），与包含块的左边相接触（对于从左往右排列的格式化，否则相反）；即使存在浮动也是如此，除非这个元素自己形成了一个新的BFC区域

- BFC区域不会与float box重叠

- BFC区域就是页面上一个独立的容器，容器里的子元素不会影响外面的元素，反之亦然

- 计算BFC区域的高度时，浮动元素也参与计算

  - 可以解决子元素浮动，父元素高度塌陷

    

### 如何让一个盒子变成BFC（如何升级为BFC）



- 根标签（html标签就是一个BFC容器）
- ```float```浮动不为```none```
- ```position```为```absolute```和```fixed```
- ```display```为```inline-block```，```table-cell```，```table-caption```，```flex```（弹性盒子）
- ```overflow```，不为```visible```



### BFC应用场景



- 场景一：
  - 每个元素左外边缘（margin-left），与包含块的左边相接触（对于从左往右排列的格式化，否则相反）；即使存在浮动也是如此，除非这个元素自己形成了一个新的BFC区域

```css
<style>
			body{
				border: 1px solid red;
			}
			.aside{
				width: 200px;
				height: 300px;
				background-color: pink;
				float: left;
				/* 即使存在浮动也是如此 */
			}
	/* 每个元素左外边缘（margin-left），与包含块的左边相接触 */
			.article{
				height: 400px;
				background-color: tomato;
				float: left;/* 或者 */overflow: hidden;
				/* 除非这个元素自己形成了一个新的BFC区域。*/
        	/*但是每个BFC区域特点不尽相同，在此页面中：float: left 与overflow: hidden渲染的效果在页面排列不同,float: left不设置宽度，宽度由内容宽度撑开；overflow: hidden不设置宽度，
        宽度自适应页面宽度*/
			}
			/* 每个元素左外边缘（margin-left），与包含块的左边相接触 */
		</style>
```



```html
<body>
		<div class="aside">aside</div>
		<div class="article">article</div>
	</body>
```



- 场景二：实现三列布局
  - 三列布局左右固定，中间自适应
  - 每个元素左外边缘（margin-left），与包含块的左边相接触（对于从左往右排列的格式化，否则相反）；即使存在浮动也是如此，除非这个元素自己形成了一个新的BFC区域
  - BFC区域不会与float box重叠

```css
<style>
			body{
				border: 1px solid red;
			}
			.left{
				width: 200px;
				height: 200px;
				background-color: pink;
				float: left;
			}
			.center{
        /* 不设置宽度，宽度由内容撑开宽度，高度如果不设置也一样 */
				height: 400px;
				background-color: tomato;
				/* float: left;此场景这样设置无法实现三列布局 */
				overflow: hidden;
			}
			.right{
				width: 200px;
				height: 200px;
				background-color: red;
				float: right;
			}
		</style>
```



```html
<div class="container">
			<div class="left">left</div>
			<div class="right">right</div>
			<div class="center">center</div>
      /* center放在left和right最后是关键，如果放在left和right之间则也不能实现三列布局 */
		</div>
```



- 场景三：解决子元素浮动脱离文档流后，父元素塌陷
  - 计算BFC区域的高度时，浮动元素也参与计算

```css
<style>
			.container{
				border: 1px solid red;
				overflow: hidden;/* 计算BFC区域的高度时，浮动元素也参与计算,所以将父盒子也设置成bfc区域。
				此场景设置float：left｜position：fixed/absolute｜display：inlineblock/flex也可以 */
			}
			.box{
				width: 200px;
				height: 200px;
				background-color: pink;
				float: left;
				/* 子元素浮动，父元素高度塌陷 */
			}
		</style>
```



```html
<div class="container">
			<div class="box">box1</div>
			<div class="box">box2</div>
		</div>
```



- 场景四：

  - box垂直方向的距离由margin决定，属于同一个BFC的两个相邻盒子的margin发生重叠

  - 解决方案：将其中一个盒子放在新的BFC容器中

    ```css
    <style>
    			/* box垂直方向的距离由margin决定，属于同一个BFC的两个相邻盒子的margin发生重叠
    			 当box1与box2同级别显示时，垂直margin重叠，垂直的margin由较大的一个决定
    			 但当box2由container包裹为新的bfc容器时，margin不重叠，相加计算*/
    			.box1 {
    				width: 100px;
    				height: 100px;
    				background-color: pink;
    				margin-bottom: 50px;
    			}
    
    			.box2 {
    				width: 100px;
    				height: 100px;
    				background-color: tomato;
    				margin-top: 80px;
    			}
    			.container{
    				overflow: hidden;
    				float: left;
    				position: absolute;
    				
    			}
    ```

    ```html
    <body>
    		<div class="box1"></div>
    		<div class="container">
    			<div class="box2"></div>
    		</div>
    ```

    

### IFC



行内格式化上下文（inline Formating Context），与BFC一样，都是CSS2提出视觉渲染的概念，指的是一行区域的渲染规则，确定了一行中行级元素如何进行排列对齐。



#### IFC特点



- 在IFC中，盒子水平放置，一个接一个，从包含块的顶部开始
- 在盒之间的```margin```和```padding```在水平方向有效
- 这些盒子可以通过不同的方式进行对齐，有些是底部和顶部对其，有些是顶部和基线对齐。。。
  - 顶线
  - 中线
  - 基线
    - 每种字体都有自己的基线，这主要是为西文字体的，所谓基线，就是你小时候练习英文的时候，英文簿每行下面的那条线，你写字的时候每个字母底部都贴着基线，例如 abc ，大写字母都在基线上面，少数小写字母会有一部分在基线下面，例如 g y 
  - 底线

![fb1e2d408855c69073cb6f8eecf47878.png](/Users/mujiabin/Documents/HBuilderProjects/practise/doc/img/fb1e2d408855c69073cb6f8eecf47878.png)

#### 行盒



- 整个一行的渲染区域

  - 行盒宽度：一行中内容总宽度决定，由浮动和包含块决定

  - 行盒高度：一行中内容高度计算得出，由行盒最高点到最低点决定

    

#### 影响行盒的css属性



- ```font-size```：字体大小影响行盒

- ```font-family```：字体样式更改

- ```height```｜```line-height```：行高和高度

- ```vertical-align``：设置对齐方式，不同的对齐方式可能会影响行盒

  

#### 影响IFC区域高度的css属性

- ```font-size```：设置字体大小
  - 字体越大，行盒越高，以行盒中高度最大的高度决定

- ```font-family```：
  - 不同字体类型占据高度不一样，会影响IFC行盒的高度

- ```height```｜```line-height```：
  - 分别设置盒子的高度和行高，值越大，行盒的高度越大，会影响行盒的高度
  - 行高的区域：文字上下的高度，不是文字底部到上一行文字底部的距离

- ```vertical-align```：行级元素在垂直方向对齐方式

  - 取值：

    - baseline：基线对齐

    - top：顶部对齐

    - middle：中线对齐

    - bottom：底部对齐

      

#### 文本之间排列方式



- 文本与文本默认参考基线对齐
  - 如果设置了`vertical-align`其他方式对齐，则需要按照设置的对齐（参考）线对齐

- 文本与图片
  - 文本基线与图片底部对齐
  - 如果设置了`vertical-align`其他方式对齐，则需要按照设置的对齐（参考）线对齐

- 表格
  - 设置表格中单元格中内容在垂直上的对齐方式
  - 取值：
    - `middle`：单元格中内容垂直居中
    - `top`：单元格中内容顶部对齐
    - `bottom`：单元格中内容底部对齐

## H5标签



### 新增表单



- 之前学习的表单标签：
  - `input`（``text``，``password`，`radio`，`checkbox`，`button`），`select`，`textarea`，`button`，`form`

- H5新增了功能性表单标签：

```html
<form action="success.html" method="GET">
			<h3>邮箱输入框</h3>
			<input type="email" required autofocus>
      <!-- required：必填项 --><!-- autofocus:自动获取焦点 -->
	<!-- 提供了邮箱格式的验证，需要输入格式才能提交数据，格式不一定完全正确以后通过js进行验证 -->
			<input type="number" readonly value="18" name="age">
      <!-- readonly：只读，不可更改，可以复制，可以提交 -->
			<!-- 文本输入只能输入数字来完成验证 -->
			<input type="url" disabled>
      <!-- disable:禁用，不可更改，可以复制，不可以提交到数据库 -->
			<!-- 验证输入的内容是否是网址：http://xxx.xxx or  https://xxx.xxx-->
			<input type="search">
			<!-- 搜索输入框提供了输入文本输入内容清空内容功能 -->
			<input type="range">
			<input type="color">
			<input type="file" multiple>
			<!-- 默认只能上传一个文件，多个文件 上传属性加mutiple -->
			<input type="date">
			<!-- 年/月/日 -->
			<input type="month">
			<!-- 年/月 -->
			<input type="week">
			<!-- 年/周 -->
			<input type="time">
			<input type="text" list="mylist">
			<!-- 通过input的list属性绑定datalist的id=“”选项完成输入提示功能 -->
			<datalist id="mylist">
				<option value="">xiaomi</option>
				<option value="">iphone</option>
				<option value="">huawei</option>
				<option value="">sumsong</option>
			</datalist>
			<button type="submit">提交</button>
		</form>
```



- 注意：
  - H5标签存在浏览器兼容和渲染效果不同的问题，如Chrome不支持``input`` 中`list`属性绑定```datalist```里的`id`="list绑定名"绑定



### H5音视频



#### 音频

```html
<audio src="" controls autoplay loop muted></audio>
		<!-- src：链接音频文件的路径 -->
		<!-- controls为控制音频显示的操作界面，不加的话音频无法显示出来，无法控制播放操作 -->
		<!-- autoplay自动播放，但存在兼容，后期可以通过js控制 -->
		<!-- loop 循环播放 -->
		<!--muted  静音播放，默认值而已，点击播放按钮可以正常播放  -->

		 <audio controls>
			 <source src="链接mp3格式的音频" type="audio/mp3">
			 <source src="链接ogg格式的音频" type="audio/ogg"> 
		 </audio>
	<!-- 不同浏览器兼容问题，同一音频需要引入不同格式的文件 -->
```



#### 视频

```html
<video src="" controls loop autoplay muted></video>
		 <!-- src：链接视频的文件路径-->
		 <!-- controls为控制视频显示的操作界面，不加的话视频无法显示出来，无法控制播放操作 -->
		 <!-- autoplay自动播放，但存在兼容，后期可以通过js控制 -->
		 <!--muted  静音播放，默认值而已，点击播放按钮可以正常播放  -->
		 <video controls>
			 <source src="文件为mp4的文件路径" type="video/mp4">
			 <source src="文件为rm的文件路径" type="video/rm">
			 <!-- 不同浏览器兼容问题，同一视频需要引入不同格式的文件 -->
		 </video>
```



## 语意化标签



- 语意化标签能够通过标签名很好的合理正确的表达标签内容的意思。



#### 语意化标签好处



- 方便用户阅读，样式丢失，看代码结构可以让页面比较清晰

- 有利于SEO的优化，搜索引擎根据标签来确定上下文的各个标签关键字的关系及权重

- 方便其他设备进行解析，比如盲人阅读器

- 有利于开发和维护，语意化标签具有可读性，代码更好维护

  

#### 语意化标签的使用



| 标签名字        | 标签描述                                     |
| --------------- | -------------------------------------------- |
| ```<footer>```  | 定义整个文档尾部                             |
| ```<main>```    | 网页中主体部分，内容区域，页面上有且仅有一个 |
| ```<nav>```     | 定义导航                                     |
| ```<aside>```   | 网页侧边栏                                   |
| ```<article>``` | 定义网页中的一块独立区域，一般放内容         |
| ```<section>``` | 定义网页中一个模块，理解为平时div            |
| ```<thead>```   | 表格头部                                     |
| ```<tbody>```   | 表格内容                                     |
| ```<tfoot>```   | 表格尾部                                     |
| ```<time>```    | 定义一个时间和日期                           |
| ```<audio>```   | 音频                                         |
| ```<video>```   | 视频                                         |
| ```<source>```  | 资源，定义多媒体资源                         |
| ```<canvas>```  | 定义图形，绘制图形或形状                     |
| ```<header>```  | 定义整个文档头部                             |

- 典型案例：苹果官网



#### 标签的选择



1. 最外层标签尽量使用HTML5的语意化标签：`header`，`main`，`footer`。。。
2. 标签尽量使用标题标签，主要为了SEO优化
3. 网页的内容框架，重复出现使用`section`，大体内容区使用`article`
4. 具体内容该使用什么标签就使用标签



## CSS3



### 渐变



- 相比较规则的渐变背景可以切1px的图片平铺，不规则的渐变只能引入整张图片。通过图片实现渐变背景，可拓展性比较低，会影响网页的加载速率。

- CSS3提出渐变背景的属性：线性渐变和径向渐变

- 渐变背景可以看作一个“图像”，使用属性background-image



#### 线性渐变



- 概念：渐变的颜色过渡可以按照一条直线进行渐变

  

  ```css
  background-image:linear-gradient(渐变方向,颜色1 位置,颜色2 位置,颜色3 位置,...)
  ```

  

  ```css
  <style>
  			.box{
  				width: 400px;
  				height: 400px;
  				border: 1px solid red;
  				background-image: linear-gradient(red 0%,green 80%,yellow 100%);
  				/* 1.线性渐变：linear-gradient()
  				 2.至少需要两种颜色,多种颜色用英文逗号隔开，默认是均匀渐变
  				 3.设置渐变范围可以用色标百分比控制，如红到绿为0-80%，80-100为绿变黄
  				 4.色标：有一个颜色和一个位置构成，决定渐变的范围，首位色标不设置时，默认为0和100%
  				 5.如果首色标50%开始，那前50%都为纯色填充，从50%到80%开始由红到绿渐变，尾部如果设置不是100%，也是同样逻辑
  				 6.如果两个色标位置相同，中间出现断层
  				 7.渐变线的方向：默认为垂直方向，由上至下
  				 8.改变方向使用“to结束方向 left top bottom right”,可以两两搭配,默认to bottom
  				 9.角度改变方向：以deg为单位，垂直向上为0deg，顺时针开始计算度数，可以设置负值，则为逆时针渐变*/
  				 background-image: linear-gradient(to bottom right,red ,green 80%,yellow 100%);
  				 background-image: linear-gradient(30deg,red ,green 80%,yellow 100%);
  			}
  		</style>
  ```

  ```html
  <body>
  		<div class="box"></div>
  	</body>
  ```

  - 色标：颜色可以rgb（），单词，十六进制

![7ba58add34d6f57ced5497b42b77528c](/Users/mujiabin/Documents/HBuilderProjects/practise/doc/img/7ba58add34d6f57ced5497b42b77528c.png)



##### 重复线性渐变



- 可以实现线性渐变的重复效果，使色标在渐变的方向上无限重复

- 注意：只有收尾颜色位置不再0%或100%时，重复渐变才生效

  ```css
  background-image: repeating-linear-gradient(pink 0px,pink 20px,yellow 20px,yellow 40px);
  ```

  - 多种渐变同时设置在background-image属性上，中间使用逗号隔开，**前面的图片或渐变背景会盖住后面的**

    ```css
    background-image: linear-gradient(transparent 50%,red),url(../img/);
    /* 属性里前面盖住后面的，图片不透明，想要实现图片上蒙一层滤镜效果，需要把滤镜的渐变效果设置在图片前面 */
    background-image: repeating-linear-gradient(-45deg,
    				rgba(255,0,0,0.3) 0px,
    				rgba(255,0,0,0.3) 20px，
    				rgba(255,255,0,0.3) 20px，
    				rgba(255,255,0,0.3) 40px)，repeating-linear-gradient(45deg,
    				rgba(255,0,0,0.3) 0px,
    				rgba(255,0,0,0.3) 20px，
    				rgba(255,255,0,0.3) 20px，
    				rgba(255,255,0,0.3) 40px)
    /* rgba(0-255,0-255,0-255,0-1),可以设置有透明度的颜色，a代表透明度，0代表完全透明，1代表不透明 */
    ```

    

#### 径向渐变



- 概念：就是椭圆渐变，渐变是沿着椭圆半径进行渐变，圆是椭圆的一种特殊情况
- 分为两部分：
  - 椭圆：用来控制渐变的位置，大小，形状等
  - 色标：有一个颜色和位置，用来控制渐变的过渡效果

- 语法：

  ```css
  background-image:radial-gradient(大小 形状at x轴 y轴，颜色1 位置，颜色2 位置，颜色3 位置)；
  ```

  

- 大小：
  - farthest-corner:渐变的半径是从圆心到最远的角
  - closest-corner:渐变的半径是从圆心到最近的角
  -  farthest-side：渐变半径从圆心到最远的边
  - closest-side：渐变半径从圆心到最近的边

- 形状：
  - 椭圆：ellipse，默认值
  - circle：正圆

- 圆心：at x轴 y轴，可以控制椭圆的位置，默认圆心在盒子的中心点默认为center center

  - 单词：left right top bottom center 两两搭配使用

  - 像素：左上角为 0px 0px

  - 百分比：参考盒子的宽度和高度，50% 50%相当于center center

    

##### 重复径向渐变



- 径向渐变可以重复显示，无限重复
- 注意：重复径向渐变首尾颜色位置不在0%或100%，重复渐变才有效
- 语法：

```css
background-image: repeating-radial-gradient(circle,#999 0px,#999 20px,#666 20px,#666 40px);
```



### 圆角



- 盒子默认四个角都是圆角，通过``border-radius`设置。

  ```css
  <style>
  			.box{
  				width: 200px;
  				height: 200px;
  				background-color: aqua;
  				border-top-left-radius: 10px;
  				border-top-right-radius: 20px;
  				border-bottom-left-radius: 30px;
  				border-bottom-right-radius: 40px;
  				/* 复合属性 */
  				border-radius: 10px 20px 30px 40px;/* 左上角开始，顺时针 */
  				border-radius: 10px 20px 30px;/* 左上角，右上角和左下角，右下角 */
  				border-radius: 10px 20px;/* 左上角右下角两个，右上角左下角两个 */
  				border-radius: 10px;/* 四个角 */
  				border-radius: 10px 10px 10px 10px/20px 20px 20px 20px;/* (水平半径)/(垂直半径) */
  			}
  		</style>
  ```

  ```html
  <div class="box"></div>
  ```

  

- 圆角的原理：由水平半径和垂直半径决定的椭圆和正圆的一段圆弧

  - 水平与垂直半径相等，为正圆的圆弧，不相等，为椭圆的圆弧

    

#### 内半径



- 如果盒子设置了那边框，边框宽度大于圆角半径，边框里边没有圆角效果
- 如果边框宽度小于圆角半径，边框外层的圆角是外半径决定，边框内层圆角是由内半径决定
- 内半径=外半径-边框宽度
- 注意：
  - 边框宽度大于圆角半径，边框里边没有圆角效果，因为内半径为0或负数，没有圆角大小

```css
.box1{
				width: 300px;
				height: 300px;
				border: 20px solid red;
				border-radius: 30px;
			}
```



```html
<div class="box1"></div>
```



#### 圆角的应用



- 正圆

  ```css
  .box{
  				/* 正圆，盒子宽高一致，border-radius:50% */
  				width: 100px;
  				height: 100px;
  				background-color: red;
  				border-radius: 50%;
  			}
  ```

- 胶囊

  ```
  .box1{
  				width: 400px;
  				height: 100px;
  				background-color: red;
  				border-radius: 50px;
  				/* 胶囊形状，border-radius设置为像素，像素值为盒子高度（短边）的一半 */
  			}
  ```

  

### 阴影



#### 盒子阴影



- 给盒子添加阴影：`box-shadow`

- 语法：

  ```css
  box-shadow:x轴偏移量 y轴偏移量 虚化程度 阴影大小 颜色 inset;/* inset:内阴影 */
  /* 虚化程度和阴影大小可以不写 */
  
  /* 可以设置多层阴影，中间逗号隔开 */
  box-shadow:x轴偏移量 y轴偏移量 虚化程度 阴影大小 颜色，x轴偏移量 y轴偏移量 虚化程度 阴影大小 颜色 inset，x轴偏移量 y轴偏移量 虚化程度 阴影大小 颜色；
  ```

- 样例

  ```css
  <style>
  			.box{
  				width: 300px;
  				height: 300px;
  				border: 1px solid red;
  				background-color: pink;
  				/* 盒子阴影 x轴偏移量 y轴偏移量 虚化程度 阴影大小 颜色 */
  				/* inset 内阴影 */
  				box-shadow:2px 5px 10px 2px green inset;
  				box-shadow: 2px 2px red;/* 虚化程度和阴影大小可以不写 */
  				box-shadow:2px 5px 10px 2px green, -3px -5px 10px 3px yellow;
  				/*box-shadow可以设置多层阴影，中间用逗号隔开  */
  			}
  		</style>
  ```

  

#### 文字阴影



- 给文本添加阴影，使用的`text-shadow`

  ```css
  text-shadow:x轴偏移量 y轴偏移量 虚化程度 颜色
  /* 文字阴影不可以设置大小 */
  ```

- 样例

  ```css
  .box1{
  				width: 200px;
  				height: 200px;
  				border: 1px solid red;
  				color: red;
  				text-shadow: 2px 5px 5px red;
  				/* 给本文添加阴影 */
  				/* 可以设置文字发光效果 */
  			}
  ```

  

### 结构选择器



- 根据Html结构代码找到对应的标签，也是伪类选择器

```css
<style>
			/* .box{
				color: red;
			} */
			
			/* 先找到满足条件的标签，这些标签是某个标签的第一个子标签 */
			/* 找到class名为box的标签的后代p标签，并且p标签是某个标签的第一个子标签 */
			/* 符合条件的为p1和p7 */
			/* 注意：如果某标签的第一个子元素不是p标签，属性设置不起作用 */
			.box p:first-child{
				color: red;
			}
			/* 先找到满足条件的标签，这些标签是某个标签的最后一个子元素 */
			/* 找到class名为box的标签的后代p标签，并且p标签是某个标签的最后一个子元素 */
			/* 符合条件的为p8 */
			/* 注意：如果某标签的第一个子元素不是p标签，属性设置不起作用 */
			.box p:last-child{
				color: aqua;
			}
			/* nth-child(n) 找到满足条件的标签，并且这个标签是某个标签的第n个子标签*/
			/* 找到class名为box的标签的后代p标签，并且p标签是某个标签的第n个子元素 */
			/* 满足条件的是p2和p8 */
			/* 注意：如果某标签的第二个子元素不是p标签，属性设置不起作用 */
			.box p:nth-child(2){
				color: blue;
			}
			/* nth-child(2n) 找到满足条件的标签，并且这个标签是某个标签的偶数子标签*/
			/* nth-child(2n+-1) 找到满足条件的标签，并且这个标签是某个标签的奇数子标签*/
			/* 注意：如果某标签的第2n或2n+-1个子元素不是p标签，属性设置不起作用 */
			.box p:nth-child(2n){
				color: bisque;
			}
			/* nth-last-child(n) 找到满足条件的标签，并且这个标签是某个标签的倒数第n个子标签*/
			/* 注意：如果某标签的最后一个子元素不是p标签，属性设置不起作用 */
			.box p:nth-last-child(2){	
			}
			/* nth-of-type(n) 找到满足条件的标签，将这些标签筛选进行重新排序，找到其中的第n个标签*/
			/* 注意：如果某标签的第一个子元素不是p标签，会排除掉不符合条件的标签，将符合条件的标签按条件附上属性 */
			.box p:nth-of-type(2){
				color: blanchedalmond;
			}
			.box p:nth-last-of-type(2){
				color: blanchedalmond;
			}
		</style>
```



```html
<div class="box">
			<!-- <span>p6</span> -->
			<p>p1</p>
			<p>p2<p>
			<!-- <span>p9</span> -->
			<p>p3</p>
			<p>p4</p>
			<p>p5</p>
			<!-- <span>p10</span> -->
			 <ul>
				 <li>p7</li>
				 <!-- <span>p10</span> -->
				 <li>p8</li>
			 </ul>
		</div>
```



## CSS兼容



### 兼容性问题



#### 来源



- 内核是浏览器最底层最核心的代码，决定了浏览器如何解析网页以及被浏览器加载，还有脚本如何执行

- 但不同的浏览器由不同的内核，每种浏览器内核对相同的网页有不同的解析方式，导致最终解析结果不一致，将这种现象称为兼容性问题

  

### 浏览器内核



- 内核是浏览器最底层最核心的代码，不同浏览器有不同的内核

- 主流浏览器：

  - Chrome（WebKit）  
  - Firefox（Gecko） 
  - IE（Trident ） 
  - EDGE(Chromium-webkit) 
  - Safari（WebKit） 
  - Opera（Presto）

- 国产浏览器：360 搜狗 猎豹 QQ UC，国产浏览器都是使用国外产品内核；360存在双核浏览器，由IE Trident和Safari 的Webkit内核集成的

  

#### 内核的作用



- 解析网页
  - Html
  - CSS
  - Javascript

- 内核里有个很重要的概念：渲染引擎

  - Html解析器：会将Html代码解析为DOM树，上面的每个标签就是DOM树上的一个节点

    ![c83b2030c0d0bb5d9dcb4e3348b62b28](/Users/mujiabin/Documents/HBuilderProjects/practise/doc/img/c83b2030c0d0bb5d9dcb4e3348b62b28.png)

  - CSS解析器：将CSS计算出来，

  - 布局（layout）：网页中模块定位，浮动，排列在一起等等

  - Javascript引擎：允许Javascript运行的环境



#### 网页是如何解析出来的？

 ![截屏2022-07-27 14.15.07](/Users/mujiabin/Documents/HBuilderProjects/practise/doc/img/截屏2022-07-27 14.15.07.png)



1. 加载网页代码
   - 判断是否时网络资源，是就利用网络模块从对应网络地址中加载网页代码
   - 如果是本地文件，则直接从本地文件加载网页代码到浏览器内核中

2. 经过Html解析器对代码进行解析
   - 浏览器从代码第一行开始解析，把不同类型的代码交给对应的解析器
     - Html-Html解析器
     - CSS-CSS解析器
     - Javascript-Javascript解析器

3. 内部表示：将各个解析器的结构综合并梳理
   - 把标签和对应的CSS结合起来，每个标签都有自己的渲染对象，标签样式先在内部整合，Javascript脚本也在作用在指定的标签上

4. 布局和绘图

   - 把每个标签的样式，位置都绘制在页面上，如果需要使用图片，视频，音频等内容会交给对应模块进行处理，处理完成直接显示在页面上

     

### 兼容器问题处理



#### hack处理



- 专门针对特定浏览器设置CSS代码
- 针对不同的浏览器不同版本写不同的CSS代码，这个写CSS代码的过程称为 CSS hack
  - https://Caniuse.com  兼容性问题自查网址

- 主要学习IE hack代码

  

#### CSS hack分类



- 属性前缀法
  - 给特定的浏览器CSS样式属性添加一些前缀，方便特定浏览器识别，以达到预期页面效果
  
  - 只能单个属性进行设置，多个属性需要每个设置
  
    ```css
    .box{
    				width: 200px;
    				height: 200px;
    				border: 1px solid red;
    				*color: red;
    				/* 属性前面加星号代表只有ie7及以下的版本使用 */
    				*background-color: pink;
    			} 
    ```
  
    
  
- 选择器前缀法
  - 在选择器前面添加一些前缀，只有特定的浏览器才能识别

    ```css
    @media screen\0{
    				.box{
    					color: red;
    					background-color: pink;
    				}
    ```
  
    
  
- 条件注释法

  - 通过注释完成样式的引用，注释语法可以检测浏览器的类型或版本

    - lte代表小于等于，gte大于等于

    - ！代表“非”的意思

      ```css
      <!--[if gte ie 8]>
      			<link rel="stylesheet" href="css/...">
      			<![endif]-->
      			/* 只在大于等于ie8时引用 */
      ```

      

#### CSS兼容思想指导



##### 优雅降级（推荐）

- 先不管兼容问题，直接以目前主流浏览器为主，实现页面最佳效果，然后再考虑低版本浏览器，针对低版本浏览器去写对应css代码，保证低版本浏览器也有很好的页面效果



##### 渐进增强

- 先把网页内容搭建好（不考虑效果），在内容不受影响情况下，逐步添加对应页面效果，浏览器版本越高，效果越佳。先考虑大多数浏览器都能正常运行，给高版本的浏览器添加对应的页面效果



![截屏2022-07-27 22.54.15](/Users/mujiabin/Documents/HBuilderProjects/practise/doc/img/截屏2022-07-27 22.54.15.png)

- 兼容问题大全：http://t.zoukankan.com/gaojunfeng-p-3945024.html



## 弹性盒模型

### 传统布局



- 基于盒模型：依赖：float+display+position
- 这种方式兼容性好，但布局过程繁琐
- 传统布局的不便：
  - 各种居中对齐
  - 块级元素同行显示，设置浮动
  - 清除浮动
  - 各种细节调整

CSS3提出了一种自适应的布局模式——弹性盒模型，用来辅助或替代传统布局



### 弹性盒模型



- 概念：它是一种当前页面需要适应不同屏幕大小及设备类型时，确保里面元素拥有恰当行为的一种布局模式
- 目的：提供一种更加有效的方式来对一个容器中的子元素进行排列，对齐和剩余空间分配



#### 弹性和模型结构

![20210707143115585](/Users/mujiabin/Documents/HBuilderProjects/practise/doc/img/20210707143115585.png)



弹性盒子是由弹性容器和弹性项目构成

- 弹性容器：包含弹性项目的父元素
- 弹性项目：弹性容器里的每个子元素
- 主轴：弹性项目排列在一行显示的方向就是主轴
- 侧轴：与主轴垂直的方向就是侧轴



### 给父元素（弹性容器）设置的属性



#### `display:flex`|`inline-flex`



- `Display:flex`：设置块级弹性容器，对里面的子元素来说，就是弹性容器，对其兄弟元素来说就是普通的块级元素
- `Display:inline-flex`：设置行级弹性容器，对里面子元素来说就是弹性容器，对其兄弟元素来说就是普通的行级元素



#### 弹性容器特点



- 里面的元素同行显示，排列不下，按对应比例压缩显示
- 弹性盒子不设高度，高度自适应
- 对兄弟元素无影响
- 只对子元素有影响，对孙元素无影响



##### `flex-wrap`



- 设置弹性容器中弹性项目排列不下时换行

- `wrap`：换行

- `nowrap`：不换行

  

##### `flex-direction`



- 控制主轴（弹性项目的排列）方向
- 注意：如果主轴方向发生改变，侧轴也会发生改变，侧轴的方向与主轴垂直
  - `row`：为默认值，水平方向为主轴，弹性项目从左到右
  - `row-reverse`：水平方向为主轴，弹性项目从右到左
  - `column`：主轴方向为垂直方向，弹性项目从上到下依次排列
  - `column-reverse`：主轴方向为垂直方向，弹性项目从下到上依次排列



##### `justify-content`



- 概念：主轴上的富裕空间的分配

  - `flex-start`：默认值，主轴的富裕空间放在弹性项目之后，如果主轴变为`flex-direction：colomn`，则变为垂直由上到下，富裕空间仍旧放在弹性项目之后

  - `flex-end`：主轴的富裕空间放在弹性项目之前，如果主轴变为`flex-direction`：`colomn`，则变为垂直由下到上，富裕空间仍旧放在弹性项目之前

  - `space-between`：首尾紧靠弹性容器，中间均分富裕空间

  - `space-around`：每个弹性项目两侧均分

  - `space-evenly`：每个弹性项目之间间距相同，包括首尾部分

  - `center`：所有弹性项目居中

    

##### `align-items`



- 概念：侧轴上富裕空间的分配

  - `flex-start`:默认值，侧轴上富裕空间均分放在每行弹性项目之后

  - `flex-end`：侧轴上富裕空间均分放在每行弹性项目之前

  - `center`：弹性项目在当前行居中

  - `stretch`：当弹性项目没有设置高度时的默认值，将弹性项目拉伸撑满整个弹性空间

    

#####  盒子水平垂直居中

```css
justify-content:center;
align-items:center;
```



#### 给子元素（弹性项目）设置属性



##### `align-self`



- 给当前弹性项目侧轴上的富裕空间分配

  - `flex-start`:默认值，侧轴上富裕空间均分放在每行弹性项目之后

  - `flex-end`：侧轴上富裕空间均分放在每行弹性项目之前

  - `center`：弹性项目在当前行居中

  - `stretch`：当弹性项目没有设置高度时的默认值，将弹性项目拉伸撑满整个弹性空间

    

##### `flex-shrink`



- 设置当弹性容器宽度不够时，弹性项目的压缩因子

- 原理：弹性容器一行宽度排列不下当前所有弹性项目时，就会按照设置的`flex-shrink`将项目进行压缩以达到不换行的目的，`flex-shrink`会按照设置的值将需要压缩的宽度等量划分，减少对应弹性项目尺寸

- 前提：弹性容器宽度小于弹性项目总宽度，弹性项目不换行

- 语法：

  ```
  flex-shrink：数字，默认值为1
  ```

  

- 计算公式：

  ```
  弹性项目压缩的空间=（弹性项目总宽度-弹性容器的宽度）/压缩因子的总数*压缩因子
  弹性项目的大小=弹性项目的宽度-弹性项目压缩的空间
  ```

  

- 应用场景：
  - 当指定view为`flex`布局后，给子元素定义`width`是不起效果的。 
  
  - 原因：定义为flex布局元素的子元素，自动获得了flex-shrink的属性，这个属性是什么意思呢？就是告诉子元素当父元素宽度不够用时， 自己调整自己所占的宽度比，这个`flex-shrink`设置为1时，表示所有子元素大家同时缩小来适应总宽度。**当flex-shrink设置为0时，表示大家都不缩小适应**。 
  
  - 所以，倘若给父元素设置了flex布局后，**若要其子元素的width有效果**，必须给子元素设置`flex-shrink`为0。
  
    

##### `flex-grow`



- 设置弹性项目的因子，消化掉富裕空间

- 需要设置一个数字，默认值为0

- 语法：

  ```css
  flex-grow:数字
  ```

  

- 计算公式

  ```
  弹性项目的弹性空间=富裕空间/弹性因子总数*弹性因子
  弹性项目大小=弹性项目宽度+弹性项目的弹性空间
  ```

  

`flex-basis`

- 给弹性项目设置默认宽度，其优先级大于设置的width

  ```css
  flex-basis:宽度；
  ```

- 默认值：`auto`



`flex`

- 复合属性

- 语法：

  ```css
  flex: 弹性因子 压缩因子 flex-basis；
  ```

  ```css
  flex:flex-grow flex-shrink flex-basis；
  ```

  

`order`

- 弹性项目显示位置

- 默认值为0，数字越大排序越靠后

- 数字相同按照代码结构排序显示

- 可以为负值，排序逻辑不变

  ```css
  order:数字；
  ```

  

- 应用场景：
  - 不改变代码结构的情况下鼠标拖拽盒子改变盒子显示顺序
  - 将某个模块拖拽到最后



### 富裕空间



- 概念：弹性容器中，除去弹性项目以外剩余的空间

- 分为两部分：

  - 主轴上的富裕空间：`justify-content`

  - 侧轴上的富裕空间:`align-items`和`align-self`

    

### 弹性空间



- 概念：弹性项目消化掉的富裕空间，将富裕空间变成弹性项目中的一部分，即弹性项目会发生改变



## 过渡



### 基本概念



- `transition`提供了一种在更改css属性时控制动画速度的方法，可以让这个属性在指定时间内完成效果，而不是立即生效。

  

### 属性



- `transition-property` 与`transition-duration`

  - 设置过渡属性名与执行时间

  - 语法：

    ```css
    <style>
    			.container{
    				width: 100%;
    				height: 500px;
    				border: 1px solid red;
    			}
    			.box{
    				width: 200px;
    				height: 200px;
    				background-color: aqua;
    				/* 设置过渡属性名 */
    				transition-property:width,height;
    				/* 设置过渡时长  ms代表毫秒 代表秒 1s=1000ms*/
    				transition-duration: 2s,3s;
    				/* ˙注意：过渡属性属性名必须与过渡时长一起使用 */
    				/* 多个属性名同时过渡，中间使用逗号隔开;过渡属性名与时长一一对应 */
            /* 如果过渡属性名多余执行时长的个数，时间重复一遍，一一对应 */
    			}
    			.container:hover .box{
    				/* margin-left: 500px; */
    				width: 500px;
    				height: 600px;
    			}
    		</style>
    ```

    ```html
    <div class="container">
    			<div class="box"></div>
    		</div>
    ```

    

- `transition-timing-function`

  - 设置过渡速率

  - 属性：

    - `ease`：为默认值，低速度开始，然后变快，结束前变慢；

    - `linear`：匀速；

    - `ease-in`：低速开始；

    - `ease-out`：低速结束；ease-in-out低速开始和结束；

    - `cubic-bezier()`：贝塞尔曲线

      

#### 贝塞尔曲线（自定义速度曲线）

- 是一种用于构建二维图片的速度曲线，本质上是一个数学曲线

- 作用：在css中，通过贝塞尔曲线可以控制动画的速率

- 语法：

  ```css
  cubic-bezier(x1,y1,x2,y2)
  ```

  -  这两个坐标决定了曲线的形状，不同形状所对应的速率不一样，可以为负值

- 贝塞尔曲线官网：https://cubic-bezier.com



- `transition-delay`

  - 设置过渡延迟时长，过渡延迟多久才开始执行

  - 语法：

    ```css
    transition-delay：1s;
    ```

    - 默认为0s

-  `transition`

  - 复合属性

  - 语法：

    ```css
    transition: margin-left 3s 2s linear,margin-top 2s 1s ease;
    ```

    - 并不是所有属性都支持`transition`，比如`display`属性
    
    - 可以采取其他方式起到同样效果，比如设置 `opacity`为0，鼠标移过时为1，或者高度为0，鼠标移过时给一个高度
    
      

## 2D转换



- css3提供了`transform`属性来处理盒子（html）标签的转换，包括位移，旋转，缩放，倾斜等操作

- 一般需要配合`transition`过渡使用

  

### 位移`translate`



- 可以让盒子沿着x轴或y轴进行移动，不会影响其他盒子和元素

- 语法：

  ```css
  <style>
  			.container{
  				width: 100%;
  				height: 500px;
  				border: 1px solid red;
  			}
  			.box{
  				width: 100px;
  				height: 100px;
  				background-color: aqua;
  				transition: all 2s;
  			}
  			.container:hover .box{
  				/* margin-left: 300px;
  				margin-top: 300px; */
  				/* 使用位移，让盒子进行移动 */
  				/* x轴移动量，y轴移动量,可以设置负值 */
  				transform: translate(300px,300px);
  				transform: translate(300px);/* 只设置一个值，沿着x轴移动 */
  				transform: translateX(300px);
  				transform: translateY(300px);
  			}
  		</style>
  ```

  ```html
  <div class="container">
  			<div class="box"></div>
  			<span>span</span>
  		</div>
  ```

  

- 注意
  - 盒子参考原来位置进行移动



### 旋转`rotate`



- 让盒子进行旋转

- 语法：

  ```css
  <style>
  			.container{
  				width: 100%;
  				height: 500px;
  				border: 1px solid red;
  			}
  			img{
  				transition: all 3s;
  				border: 1px solid green;
  			}
  			.container:hover img{
  				/* 旋转 */
  				/* 围绕中心点旋转，正值时顺时针旋转，负值时逆时针旋转 */
  				transform: rotate(120deg);
  				/* 围绕x轴进行旋转 */
  				transform: rotateX(120deg);
  				/* 围绕y轴进行旋转 */
  				transform: rotateY(120deg);
  			}
  		</style>
  ```

  ```html
  <div class="container">
  			<img src="../img/rotate.png" alt="">
  		</div>
  ```

  

- 注意：盒子是没有厚度的，如果围绕x轴或y轴旋转90度，盒子与视线平行，看不见盒子，从页面中消失

  

### 缩放 `sclae`



- 让盒子进行放大和缩小

- 语法：

  ```css
  <style>
  			.container{
  				width: 100%;
  				height: 500px;
  				border: 1px solid red;
  			}
  			img{
  				transition: all 3s;
  				margin: 10px auto;
  				display: block;
  			}
  			.container:hover img{
  				/* 缩放：x轴（宽度倍数）缩放，y轴（高度倍数）缩放 */
  				/* 1为默认原始值 */
  				transform: scale(2，2);
  				/* 只设置一个值，代表x轴与y轴等比例缩放 */
  				transform: scale(0.5);
  			}
  		</style>
  ```

  ```html
  <div class="container">
  			<img src="../img/rotate.png" alt="">
  			<br>
  			<span>span</span>
  		</div>
  ```

  

- 注意：
  - 倍数为0，盒子消失
  - 倍数为1，参考盒子原来大小
  - 倍数0-1，盒子缩小
  - 倍数大于1，盒子放大
  - 盒子缩小放大都是参考盒子中心点进行缩放



### 倾斜 `skew`



- 让盒子沿着x轴或y轴进行倾斜

- 语法：

  ```css
  <style>
  			.container{
  				width: 100%;
  				height: 500px;
  				border: 1px solid red;
  			}
  			img{
  				transition: all 3s;
  				margin: 10px auto;
  				display: block;
  			}
  			.container:hover img{
  				/* 倾斜，沿着x轴进行倾斜 */
  				transform: skew(45deg);
  				transform: skewX(45deg);
  				/* 沿着y轴进行倾斜 */
  				transform: skewY(45deg);
  			}
  		</style>
  ```

  ```html
  <div class="container">
  			<img src="../img/rotate.png" alt="">
  			<br>
  			<span>span</span>
  		</div>
  ```

  

- 注意：

  - skewX：沿着x轴倾斜时，角度越大，越接近x轴，当角度为90deg时，会和x轴平行，消失不见

  - skewY：沿着y轴倾斜时，角度越大，越接近y轴，当角度为90deg时，会和y轴平行，消失不见

    

### 转换基点



- 基点：是css 2D转换时的参考点

- 可以通过`transform-origin`设置转换的参考点位置

- 语法：

  ```css
  <style>
  			.container{
  				width: 100%;
  				height: 500px;
  				border: 1px solid red;
  				display: flex;
  				justify-content: center;
  				align-items: center;
  			}
  			img{
  				width: 200px;
  				border: 1px solid green;
  				transition: all 1s;
  				/* 设置转换基点：top left center right bottom 两两搭配使用
  				 默认为center center，中心点进行旋转*/
  				 /* 还可以设置像素，如：0px，0px是左上角*/
  				 /* 还可以设置百分比 如：50% 50%是中心点center center*/
  				 /* 转换基点需要设置在未更改css样式上，因为默认转换基点在center center，
  				 在更改样式时设置转换基点会从center center变为更改指定的点，样式会错乱，所以不能设置在hover上*/
  				transform-origin: top left;
  				
  			}
  			.container:hover img{
  				transform: rotate(60deg);
  				transform: scale(2);
  				/* 位移默认参考盒子原来的位置影响，不受转换基点影响 */
  				transform: translate(200px,200px);
  			}
  		</style>
  ```

  

- 注意：
  - 针对**缩放和旋转**，因为都是默认参考盒子中心点进行变换，所以改变转换基点位置，缩放和旋转会受影响
  - 位移是参考盒子原来的位置进行移动，所以改变转换基点位置不会影响位移的变换
  - 如果需要设置转换基点，需要在未改变样式时设置基点位置，因为默认基点在`center center`，如果改变样式时设置基点的位置，基点会从`center center`变为指定位置，样式效果会错乱



### 组合变换



- 将多种2D转换组合在一起使用

- 语法：

  ```css
  <style>
  			.container{
  				width: 100%;
  				height: 500px;
  				border: 1px solid red;
  			}
  			.box{
  				width: 200px;
  				height: 200px;
  				background-color: aqua;
  				transition: all 0.5s;
  			}
  			.container:hover{
  				/* 向右移动500px，旋转90度 */
  				/* 多个2d转换组合在一起，使用空格隔开 */
  				transform: translateX(500px) rotate(90deg);
  				/* 旋转90度，向右移动500px */
  				/* 先旋转90度，x轴变为顺时针向下方向，y轴也随之变化 */
  				transform: rotate(90deg) translateX(500px);
  			}
  		</style>
  ```

  ```html
  <div class="container">
  			<div class="box">box</div>
  		</div>
  ```

  

- 注意：
  - 旋转会改变坐标轴的方向



## SASS



### 原生css不便



- 书写重复的选择器

- 修改css属性不便，一处改没处都需要改

- css代码重复，比如水平垂直居中，`ul`三件套

  

### 基本概念



- SASS是css预处理器，可以为网站启用可以定义，可管理和可重用的样式表。SASS是一种动态样式表语言，扩展了css的功能
- css预处理器是一种脚本语言，可以拓展css并将其编译为常规css语法，以便于浏览器进行解析
- SASS对css进行拓展，通过它提供的嵌套，变量，混合等等操作来减少编写css的效率
- 目的：极大程度的提升编写css代码的效率
- 官网：https://www.sass.hk/



### 基本使用



- VS Code中使用EasySass插件
  - 利用VS Code来编写css代码
    - 安装EasySass插件
    - 新建以.sass或.scss为后缀名的文件，在里面书写sass代码
      - .sass为旧版本的sass文件格式
      - .scss为新版本的sass文件格式

- EasySass会在保存文件时自动将sass代码编译为css代码，在页面通过link标签引入对应css文件



#### 手动编译好的css文件存储路径

- 在VS Code-设置-设置中搜索EasySass，在EasySass-configuration中修改Target Dir下目录即可



### 嵌套



- 概念：SASS支持选择器里面嵌套子选择器

- 作用：让SASS代码对应的css代码层级结构清晰明了，不会出现父子标签之间的权重

  ```css
  父选择器{
     父选择器css代码；
     子选择器{
            子选择器css代码；
       子子选择器{
         子子选择器代码；
       }
      }
  }
  ```

  

- 实例：

  ```css
  .header{
      width: 100%;
      height: 70px;
      background-color: pink;
      .container{
      width: 1200px;
      height: 70px;
      border: 1px solid red;
      margin: 0 auto;
      .logo{
          width: 200px;
          height: 70px;
          background-color: tomato;
      }
      nav{
          width: 400px;
          height: 70px;
          background-color: green;
          >ul{
              list-style: none;
              li{
                  background-color: red;
                  // &代表父选择器
                  &:hover{
                      background-color: blue;
                  }
                  &::before{
                      content: "";
  
                  }
              }
          }
          + .box{
              border: 1px solid red;
          }
          /* +表示兄弟选择器 */  
          ~div{
              width: 300px;
              height: 200px;
          }
          /* ～表示“所有”*/
          
      }
      }
  }
  ```

  

### 变量



- 概念：变量可以看成是一个存储数据的容器，可以在代码中重复使用

- 语法：

  ```css
  $变量名：数据;
  ```

  - 数据可以是任意的css属性，比如：red 70px 或者复合属性的属性值：1px solid red
  - 注意：变量需要先在页面开始定义后才可以使用
  - 变量名命名规范：
    - 变量名可以包含数字，字母，__和-
    - 不能以数字开头
    - 多个单词之间建议用“-”隔开
    - 注意：变量可以进行数学运算

- 实例

  ```css
  $mycolor:pink;
  $myborder:1px dashed gray;
  $add:50px;
  .box1{
      width: 200px+$add;
      height: 200px+$add;
      background-color: $mycolor;
      border: $myborder
  }
  .box2{
      width: 300px+$add * 2;
      height: 300px-$add * 1;
      background-color: $mycolor;
      border: $myborder;
  }
  .box3{
      width: 400px-$add * 4 ;
      height: 400px+$add * 3;
      background-color: $mycolor;
      border: $myborder
  }
  ```

  

## 3D转换



- 3D转换是基于css完成3D设计

- 在css中3D其实是2D的一个补充，在2D平面上的基础上新增了z轴，形成了三维坐标系



### 三维坐标系



- 概念：在x，y轴基础上新增z轴，构成三维坐标系

- 在css中三维坐标系，x轴正方向是水平向右，y轴正方向是垂直向下，z轴的正方向是垂直屏幕向外

- 左手系统：食指水平向右代表x轴正方向，中指垂直向下代表y轴正方向，大拇指垂直x轴和y轴指向屏幕外面，代表z轴

  ![08abb0eb40ac47fc876b5d73322809c7](/Users/mujiabin/Documents/HBuilderProjects/practise/doc/img/08abb0eb40ac47fc876b5d73322809c7.png)

- 有了三维坐标系，我们可以用（x，y，z）代表三位空间的任意一点



### 景深



- 概念：在摄像中，景深是指相机对焦点前后的清晰的成像范围，即镜头和物体之间的距离
- 在开发中，我们将景深转化为当前物体在z轴上的距离，或**观察者与z=0平面的距离**
- 作用：通过景深来设置盒子和屏幕之间的距离，景深越大，盒子和屏幕之间的距离越远，景深越小，盒子和屏幕之间距离越近。
  - 一旦设置了景深，物体可以在运动过程中就可以实现近大远小的效果，景深越小，离镜头越近，效果越大，反之越小

- 语法：

  ```css
  perspective: 像素值;
  ```

  

- 特点：
  - 景深是给父元素设置的，子元素以3D形式呈现
  - 景深越大，3D效果越不明显，景深越小3D效果越明显
  - 景深是搭配3D转换一起使用



### 3D转换



#### 位移



- 让盒子进行移动

- 语法：

  ```css
  transform: translateX(200px);/*x轴移动*/
  transform: translateY(200px);/*y轴移动*/
  transform: translateZ(200px);/*z轴移动，近大远小*/
  transform: translate3d(200px,200px,200px);/*同时控制三个轴移动*/
  ```

  

-  z轴上`transition`失效？

- https://www.cnblogs.com/yanggeng/p/11285856.html:`translateZ`与`perspective`关系

  - 原理图：

    

![1609428-20190801234131287-970705813](/Users/mujiabin/Documents/HBuilderProjects/practise/doc/img/1609428-20190801234131287-970705813.png)

![1609428-20190801234818111-1640872733](/Users/mujiabin/Documents/HBuilderProjects/practise/doc/img/1609428-20190801234818111-1640872733.png)

![1609428-20190801232932435-607269886](/Users/mujiabin/Documents/HBuilderProjects/practise/doc/img/1609428-20190801232932435-607269886.png)



#### ![1609428-20190801233508948-1693095665](/Users/mujiabin/Documents/HBuilderProjects/practise/doc/img/1609428-20190801233508948-1693095665.png)



#### 缩放



- 可以让盒子放大或缩小

- 语法：

  ```css
  transform: scale(2);/* x轴缩放，宽度的缩放，或者scaleX(2)*/
  transform: scaleY(2);/* y轴缩放，高度的缩放 */
  transform: scaleZ(2);/* z轴缩放，相当于厚度的变化，直观上无法发现效果 */
  transform: scale3d(2,0.5,1.5);/* 三个轴同时缩放 */
  ```

  

-  z轴上`transition`失效？



#### 旋转



- 让盒子进行旋转操作，选确定旋转轴的方向，在设置旋转角度

- 语法：

  ```css
  transform: rotateX(60deg);/* 沿着X轴旋转 */
  transform: rotateY(60deg);/* 沿着Y轴旋转 */
  transform: rotateZ(60deg);/* 沿着Z轴旋转 */
  transform: rotate3d(1,1,1,60deg);
  /* 沿着原点（0，0，0）到设置坐标点（1，1，1）的一条直线为轴进行转转 */
  ```

  

-  只有`rotate在`z轴上`transition`有效

  

### 灭点



- 灭点：在动画里是指视线消失的点

  ![558e58c00be18b0aea02af3f7a9d0f49](/Users/mujiabin/Documents/HBuilderProjects/practise/doc/img/558e58c00be18b0aea02af3f7a9d0f49.png)

- 通过`perspective-origin`设置视线灭点，改变观察者的位置

- 语法：

  ```css
  perspective-origin: top left;
  /* 灭点设置为上左，表明观众位置为下右 */
  /* 设置灭点位置 */
  /* 单词：left right center top bottom */
  /* 像素：0px 0px 相当于舞台左上角*/
  /* 百分比：50% 50% 相当于舞台中心点：center center*/
  
  ```

  - 默认舞台中心点

- 注意：

  - 这个属性设置在舞台的大盒子上，就是设置景深的盒子上

  - 如果元素在舞台正中心并且灭点在中心点，看元素是对称的

    

### `transform-style`



- 概念：嵌套的元素如何在3D空间中显示，定义3D图形如何进行显示，是在2D平面上显示，还是在3D空间中显示
- 取值：
  - `flat`：默认值，代表子元素在2D平面显示
  - `preserve-3d`：代表其子元素以3D平面显示

- 语法：

  ```css
  transform-style: flat/perserve-3d;
  /* 默认，代表子元素在2d空间中展示 */
  /* perserve-3d，代表子元素在3d空间中展示 */
  ```

  

- 注意：
  - 设置在父元素上，控制里面子元素以什么方式显示在页面上。注意这个父元素不一定设置景深的盒子

- 应用：
  - 实现页面中的3D效果



## 动画



### 完成自动播放的动画



- 编写Javascript脚本完成自动播放的动画
- 可以用Flash计算完成动画设计
- 可以使用某些动画标签，拨入`marquee`
- H5提供了`canvas`技术（绘图技术），来完成动画设计
- CSS3提供了一种`animation`动画可以完成自动播放持续播放的动画



### 动画的概念



- 动画：快速切换连续图片而达到流畅的画面效果
- 帧数：一秒钟切换的图片数量，数量越多，画面越流畅。60hz（每秒钟切换60张图片）
- 关键帧：每一页的关键画面



### 关键帧



- 概念：指盒子状态要发生改变的帧，就是设置需要播放的动画步骤。一个完整的动画会被拆分为多个步骤，每一个步骤就是一个关键帧

- 例子：盒子向右移动500px，有2个关键帧：开始状态和结束状态

- 例子：盒子变圆后向右移动500px，有3个关键帧：开始状态-变圆-右移500px

- CSS动画中，定义关键帧

  

### 动画的基本使用



- 先定义关键帧，再通过`animation`调用关键帧
- 步骤：
  - 运用`keyframes`属性来定义所有关键帧，给动画设置一个名称
  - 给要使用的盒子添加`animation`的相关属性，指定动画的名称和执行时长



#### 定义关键帧



- 利用`keyframes`属性来定义关键帧，这个属性是属于CSS代码，不需要写在任何选择器中

- 语法：

  ```css
  @keyframes move/* 动画名称 */ {
  				from{
  					/* 开始状态 */
  					transform: translateX(0px);
  				}
  				to{
  					/* 结束状态 */
  					transform: translateX(500px);
  				}
    还可以使用百分比定义关键帧，百分比代表整个动画再某个百分比时是什么状态
    0%{
      
    }
    50%{
      
    }
    100%{
      
    }
    div{
      animation-name:动画名称；
      animation-duration: 执行时长;
    }
  ```

  - 关键帧在设置过程中可以使用百分比，`from`相当于0%，`to`相当于100%

  - 每一帧时间跟两帧之间的百分比有关系，跨度越大，分配时间越多；跨度越小，分配到的时间越少

  - #### 公式：关键帧执行时间=两帧之间的差*总动画时间



### 动画属性



- `animation`动画属性可以控制动画的速率，次数等等操作

- 属性：

  - `animation-name`：设置动画的名称，需要配合执行时长一起使用

  - `animation-duration`：设置动画的执行时长，默认为0s

  - `animation-timing-function`：设置动画执行速率，原理是通过贝塞尔曲线实现

    - `ease`：低速开始，变快，低速结束
    -  `linear`：匀速
    - `ease-in`：低速开始
    - `ease-out`：低速结束
    - `cubic-bezier`：（x1,y1,x2,y2）贝塞尔曲线

  - `animation-delay`：设置动画的延迟，默认为0s

  - `animation-iteration-count`：设置动画的执行次数，默认执行1次

    - `n`：数字，代表次数
    - `infinite`：无限次

  - `animation-direction`：设置动画的执行方向

    - `normal` ：正常播放
    - `alternate`： 奇数次正向播放，偶数次反向播放
    - `alternate-reverse`： 奇数次反向播放，偶数次正向播放
    - `reverse` ：反向播放

  - `animation-fill-mode`：设置动画第一帧或最后一帧是否作用在元素上

    - `forwards` 将最后一帧作用在元素上，保持结束状态
    - `backwards`  将第一帧作用在元素上，保持开始状态
    - `both` 将第一帧与最后一帧都作用在元素上

  - `animation-play-state`：控制动画是否播放

    - `running`：播放，默认值
    - `paused`：暂停

  - `animation`：复合属性

    ```css
    animation: name duration timing-function delay iteration-count direction fill-mode;
    animation:  动画名称 执行时长 执行速率 延迟时长 执行次数 执行方向 是否保持开始和结束状态;
    ```

    

## 响应式布局



### 常见布局



- 固定布局

  - 原理：主要内容区域基本都是固定像素（如960px-1200px），再水平居中，两边自适应

  - 一般应用于PC端，中间内容固定，两边自适应（`margin：0 auto`），从psd原稿分析网页结构，中间内容居中，两边在设计过程中直接自适应（留白）

  - 如：https://douban.com

  - 好处：布局简单，大div设置一个固定宽度，设置`margin：0 auto`水平居中

  - 缺点：

    - 无适应性，对移动端不友好

    - 产生水平滚动条

      

- 流式布局

  - 原理：为了适应不同的屏幕，主要内容区域以百分比代理固定像素，不同的屏幕有不同的页面效果，有良好的适应性

  - 一般用于移动端

  - 如：https://taobao.com，顶部导航搜索栏处

  - 缺点：

    - 当宽度不够足够小时，导致内容无法查看

  - 好处：

    - 支持不同的屏幕，有很好的适应性

    - 良好的用户体验

      

- 响应式布局

  - 原理：利用媒体查询技术，实现当不同的屏幕采用不同的css代码，即一套代码多种css样式，多端使用

  - 如：https://J2qq.com

  - 缺点：

    - 大量css代码，开发难度大，维护性下降

  - 优点：

    - 很好的适应性，不同的屏幕有不同的页面效果
    - 特别好的用户体验

    

- 移动端布局

  - 原理：针对移动端设计一套html和css代码，移动端一套代码，PC端单独一套代码

  - 如：https://pvp.qq.com和https://pvp.qq.com/m

  - 缺点：

    - PC端与移动端相互独立，代码量大

  - 优点：

    - 移动端有极好的用户体验

      

- 注意

  - 如果网页设计比较简单，可以采用相应式布局

  - 如果网页布局比较复杂，并且移动端与PC端页面效果差距较大，采用移动端布局

    

### 响应式布局



- 概念：利用媒体查询技术，实现当不同的屏幕采用不同的css代码，不同的设备有不同的用户体验的一种布局模式

- 核心：媒体查询

  

### 媒体查询



- 媒体：在网页中媒体指各种设备，比如电视，手机，iPad，电脑等
- 查询：检测当前屏幕属于哪种设备，以及属于哪种类型，根据这些信息采用不同的css代码



### 基本语法



- 在引入css文件时规定css样式的作用范围

  ```html
  <link rel="stylesheet" href="../css/xiangying.css" media="设备类型">
  ```

  

- 在css语法中规定样式作用范围

  ```css
  @media 媒体类型 {
  				.box{
  					background-color: tomato;
  				}
  			}
  ```

  

### 媒体类型



| 值         | 设备类型                 |
| ---------- | ------------------------ |
| **All**    | 所有设备                 |
| Print      | 打印设备                 |
| **Screen** | 电脑显示器，彩色屏幕     |
| Braile     | 盲人用点字法触觉回馈设备 |
| Embossed   | 盲文打印机               |
| Handhelp   | 便携设备                 |
| Projection | 投影设备                 |
| Speech     | 语音或音频合成器         |
| Tv         | 电视类设备               |
| Try        | 电传打印机或终端         |



#### 媒体特性



- 媒体特性是指媒体设备的特性，用来描述设备的一些特点，如：宽度，高度，最大最小的宽度等等

- 常用到的媒体特性：

  | 值            | 描述                                            |
  | ------------- | ----------------------------------------------- |
  | `width`       | 网页显示区域完全等于设备的宽度                  |
  | `height`      | 网页显示区域完全等于设备的高度                  |
  | `max-width`   | 网页显示区域小于设备的宽度                      |
  | `max-height`  | 网页显示区域大于设备的高度                      |
  | `min-width`   | 网页显示区域大于等于设备的宽度                  |
  | `min-height`  | 网页显示区域大于等于设备的高度                  |
  | `orientation` | `portrait`（竖屏模式）｜`landscape`（横屏模式） |

  

#### 媒体关键字



- 用于媒体特性的连接词，可以将多个媒体特性关联到一起

  - `and`：并且，前后条件必须同时满足

    ```css
    @media screen and (max-width:750px) {
    				.box{
    					background-color: yellow;
    				}	
    			}
    ```

    

  - `not`：非，不是的意思，否定媒体特性

    ```css
    @media not screen and (orientation:landscape){
    				.box{
    					background-color: transparent;
    				}	
    			}
    ```

    

  - `，`：代表或者的意思，逗号前后满足一个条件即可

    ```css
    @media screen and (max-width:750px),screen and (min-width:320px){
    				.box{
    					background-color: yellow;
    				}	
    			}
    ```

    

    - 注意：逗号前后的设备相互独立

      

  - `only`：仅仅的意思，就是一种修饰，强调

    ```css
    @media only screen and (width:320px) {
    				.box{
    					background-color: aquamarine;
    				}
    			}
    ```

    

    - 早期用于某些浏览器才能识别，可以检测那些浏览器可以使用，哪些不能作用的css样式，目前的浏览器没有什么限制

    

## Bootstrap



### 简介



- Bootstrap是一个响应式布局的框架，可以对应的html的结构代码和css代码进行有序的排列，可以快速的构建响应式页面

- 框架指的是其他开发人员或者公司为了简化某一领域的开发流程而设计出来的有序的代码，简称第三方开发工具

- 官网：https://bootcss.com

- Bootstrap内置了很多组件和js插件，直接使用进行页面布局，有些代码无需自己编写，只需要添加不同的class名即可

  

#### Bootstrap3与Bootstrap4区别



| Bootstrap3               | Bootstrap4                                       |
| ------------------------ | ------------------------------------------------ |
| less语言编写             | sass语言编写                                     |
| 4种栅格类                | 5中栅格类                                        |
| 使用px为单位             | 使用rem和em为单位（除部分margin喝padding使用px） |
| 使用push和pull向左右移动 | 偏移列通过offset-类设置                          |
| 使用float的布局方式      | 选择弹性盒模型（flexbox）                        |



- Bootstrap3的四种栅格

  - 特小（col-xs-）适配手机（小于768px）

  - 小（col-sm-）适配平板（大于等于768px）

  - 中（col-md-）适配电脑（大于等于992px）

  - 大（col-lg-）适配宽屏电脑（大于等于1200px）

    

- Bootstrap4的5种栅格
  - 特小（col-）小于576px
  - 小（col-sm-）大于等于576px
  - 中（col-md-）大于等于768px
  - 大（col-lg-）大于等于992px
  - 特大（col-xl-）大于等于1200px



#### 基本使用



- 引入文件

  ```html
  <!-- 引入bootstrap的css文件 -->
  <link rel="stylesheet" href="../bootstrap/css/bootstrap.min.css">
  <!-- 引入jquery文件 -->
  <script src="../javascritpt/jquery-3.6.1.js"></script>
  <!-- 引入bootstrap的js文件 -->
  <script src="../bootstrap/js/bootstrap.bundle.min.js"></script>
  ```

  - **注意：先引入jquery文件，再引入bootstrap的js文件**



## 图表



### highcharts



- 实例丰富
- 文档是英文
- 稳定性比Echarts好
- https://www.highcharts.com/demo



### Echarts



- 百度地图开发团队
- 能结合百度地图一起使用
- 内部使用vue语法来写数据部分代码



# Javascript



## Javascript使用（浏览器环境）



- 通过`script`标签来书写Javascript代码

  

  - 在html中添加`<script> </script>`，在标签中书写Javascript代码

    ```html
    <body>
      
      <script>
        Javascrip代码
      </script>
    </body>
    ```

    - 一个页面可以有多个``<script> </script>``

    - 出于性能和执行的考虑，Javascript代码放置在`</body>`前面

      

  - 通过`script`标签引入Javascript文件

    ```html
    <script src="js文件路径"></script>
    ```

    - 支持绝对路径和相对路径

    - js文件：以`.js`结尾的文件

    - 可以通过`<script>`标签引入

    - 引入后可以立即执行文件中的js代码

      

  - javascript代码执行顺序与html一致：由上至下，由左至右。



## 注释



- 单行注释

```javascript
// 注释内容
//var name="aa";
var name="bb";//定义了一个变量
```



- 多行注释

```javascript
/*
注释内容
*/
```



- 文档注释
  - 文档注释是一个特殊的多行注释，是对整个js代码，或者一个js函数进行说明

```javascript
/**
注释内容
*/

/**
 * 传入两个数字，进行加法运算
 * @param {number} num1
 * @param {number} num2
 */
function add(num1,num2){
	return num1+num2
}

```



## 输入与输出



### 输出（3种方式）



- 页面输出：`document.write();`

  ```javascript
  document.write("");
  ```

  - 一般情况下，想要在每句代码后面加一个`;`，表示代码结束

  - 输出的内容需要包含在一对`""`里面，引号可以是单引号，也可以是双引号，无区别

  - 如果输出的是html 代码，会直接解析，变成一个真正的html标签显示在页面上

    ```javascript
    document.write('<a href="http://www.baidu.com">baidu</a>');//页面上会显示超链接
    ```

    

    

- 控制台输出：`console.log();`

  ```javascript
  console.log("console 输出")
  ```

  - 内容会在开发着工具中的控制台（console）中进行输出

    

- 弹窗输出：`alert();`

  ```javascript
  alert("alert输出");
  ```

  - 内容会以弹窗的方式输出

  - 如果页面上也有`document,write`，Google浏览器会在弹窗消失后显示`document,write`内容，火狐则会都一起显示出来

    

- 注意：

  - 双引号嵌套双引号容易引起问题，可以双引号内单引号，或者单引号内双引号

    ```javascript
    document.write("prompt(‘请输入您的姓名’)“);
    ```

    

  - **输出时不加引号javascript会将里面的内容作为代码执行**

    ```javascript
    document.write(prompt("请输入您的姓名"));
    ```

    

### 输入



- 输入是指程序获取用户通过输入设备输入的信息

  - javascript提供了`prompt`可以获取用户通过键盘获取的内容

    ```javascript
    prompt(" 请输入您的卡号和密码")；
    ```

    - 页面上会出现一个输入框，方便用户进行输入



## 变量



### 概念



- 变量是指可以存放数据的容器，一个变量可以保存一个数据，变量可以多次重复使用



### 使用（两个步骤）



- 定义变量

  ```javascript
  var  变量名 = 要保存的数据;
  例子：
  var username = "zhangsan";
  var age = 18;
  ```

  - 变量名规范
    - 只能包含数字，字母， $和 _ ，不能以符号开头
    - 见词达意，如：number，total，尽量不要出现aa，c1等

- 使用变量

  ```javascript
  直接以变量名来代替保存的数据
  例子：
  document.write(username);//输出zhangsan
  document.write(age+12);//输出18+12=30
  ```

  - 变量定义一次，可以多次重复使用

  - 修改变量保存的值

    ```javascript
    已定义的变量名=新的数据
    例子：
    username="lisi";//username变为lisi
    age=12;//age变为12
    ```



## 数据类型



### 概念



- javascript将可能用到的数据进行归纳分类

  
### 分类

  

- 将数据划分为7类

  - Number：数字。例如1 2 1.2 -123

  - String：字符串，被引号包围的内容，在程序中作为普通文本处理，例如：“张三”，“123”

  - Boolean：表示逻辑的正确和错误，只有两个值：True False

    ```javascript
    var result = true;
    var result = false;
    ```

  -  Object：对象，表示一个复合数据
    - javascript中数组和函数都是对象

  - Undefined：一个特殊数据，未定义，一般为定义了变量但无数据的时候，可以理解为变量的默认值

    ```javascript
    var result;//此时result被定义但未赋值，数据类型为undefined
    ```

  - null：一个特殊值，表示对象为空
  
  - symbol：符号，es6新增的数据类型，表示唯一的值
  
    

```javascript
var data1 = 12;
var data2 = "zhangsan"
var data3 = false;
var data4 = {};//定义一个对象
var data5;//默认为undefined
var data6 = null;//空
var data7 = new symbol();//定义一个唯一值
```



### 数据转换



- 字符串转数字

  - `Number()`：将某个字符串转为数字

    ```javascript
    Number(字符串);
    var number = Number("123");//将转换之后的数字“123”保存在变量number
    document.write(number);//输出变量number的数字
    
    ```

    - Number(字符串)需要传入可以转换的数字，如果给出的字符串是非数字，则会报错：输出NaN(not a number)

  - `ParseInt()`：将字符串转为数字，并去掉小数部分，即取整

    ```javascript
    ParseInt(字符串)；
    var num = ParseInt("23.6");
    document.write(num);//输出23，而不是23.6
    ```

  - `ParseFloat()`：将某个字符串转为数字，保留小数部分

    

- 数字转字符串（`数字.toString`）

  ```javascript
  var num = 12;
  var str = num.toString();
  document.write(str);//输出字符串“12”
  ```

  

- 数字转小数位（`toFixed`）:保留指定的小数位

  ```javascript
  var num =123.4567;
  var str = num.toFixed(2);//保留两位小数
  document.write(str);输出123.45，注意，此时数据类型已经是String,自动四舍五入
  ```

  

### 字符串拼接



- 对于加法来说，如果+两边有一个是字符串类型，那么javascript会把另一个也转化为字符串类型，直接拼接成一个字符串

  ```javascript
  "123"+"345"="123345";
  ```

  

-  对于减法而言，如果-号两边有一个是字符串或两个都为字符串，那么javascript会尝试把两个字符串都转化为数字类型并进行数学减法运算，如果其中一个转换失败，那么结果是NaN

  ```javascript
  "123"-"23"=100;
  "123"-"adn"=NaN;
  "123"-"12j"=NaN;
  ```

  

### 模板字符串（ES6）



- 背景：

  - 拼接字符串加号太多，整个代码不容易阅读和理解，拼接繁琐

  - 显示多行字符串，必须用+分段拼接

    ```javascript
    <script>
    			var width1=prompt("请输入div的宽度");
    			var height1=prompt("请输入div的高度");
    			var border1=prompt("请输入div的边框");
    			var style1="style='width:"+width1+";height:"+height1+";border:"+border1+"';";
    			document.write(style1);
    			document.write("<div "+style1+"></div>");
    		</script>
    
    <script>
    			var str="字符串字符串字符串字符串字符串字符串字符串"+
    			"长字符串长字符串长字符串长字符串长字符串长字符串长字符串长字符串长字符串长字符串"+
    			"长长长长长长长长长长长长";
    			document.write(str);
    		</script>
    ```

    

- 概念：是es6提供的一种新的字符串表达形式，通过一定的语法可以在字符串中直接使用变量和代码表达式

  

- 语法：

  ```javascript
  var str = `es6字符串形式`;//反单引号
  用${}在字符串中嵌入变量或代码表达式
  
  //变量
  var username="zhangsan";
  document.write(`my name is ${username}`);
  
  <script>
  			var width1=prompt("请输入div的宽度");
  			var height1=prompt("请输入div的高度");
  			var border1=prompt("请输入div的边框");
  			var style1=`style="width:${width1};height:${height1};border:${border1};"`;
  			document.write(style1);
  			document.write(`<div ${style1}></div>`);
  		</script>
  
  //表达式
  <script>
  			var num =`1+1=${1+1}`;
  			document.write(num);
  		</script>
  ```

  

- 应用

  - 代替传统的字符串+拼接

    - 多行字符串

      ```javascript
      <script>
      			var str =`这是一个很长长长
      			        长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长长
      					长长长的字符串`;
      			document.write(str);
      ```

      

    - 拼接变量



### 扩展



#### 如何判断一个数据是否为数字



- `isNaN`

  - 概念：判断一个数据是否为数字，最终代码结果为一个布尔型数据

    ```javascript
    isNaN(带检测的数据);
    
    var result=isNaN("a"-1);//"a1"-1导致NaN
    document.write(result);
    ```

    - 如果为`true`，说明不是数字
    - 如果为`false`，可以间接说明一个数据是不是数据
    - 因为一般数字出错会报出`NaN`,所以可能反过来证明如果数据不是`NaN`，那么就是一个数字（不是百分之百准确）

- `typeof`

  - 概念：javascript的一个关键字，用于检测数据是什么数据类型，代码的结果会返回一个字符串，会表示数据类型

    ```javascript
    typeof 要检测的数据;
    
    document.write(typeof "123");//string
    document.write(typeof 123);//number
    document.write(typeof NaN);//number,javascript的bug
    document.write(typeof true);//boolean
    document.write(typeof {});/object
    ```

    - 如果`typeof`结果是`number`，说明数据是数字或`NaN`

      ```javascript
      var num=12;
      if(typeof num =="number" && isNaN(num)==false)
      if(typeof num =="number" && !isNaN(num))
      ```

      



## 运算符



- 概念：一些特殊的符号，用于程序中某个运算和判断等操作，我们称这些符号为运算符

- 根据运算符的不同功能分为五类：

  

### 算术运算符



- 用于常规的数学运算

- 运算符：

  - `+`：加号
  - `-`：减号
  - `*`：乘号
  - `/`：除号
  - `%`：取余，即被除数不能被除数整除的部分

  ```javascript
  var num =2;
  var num1 =num+1;//3
  var num2 =num-1;//1
  var num3 = num *2;//4
  var num4 = num /2;//1
  var num5 = num %2;//0
  var num6 = num %5;//2
  
  ```

  

### 赋值运算符



- 能够快捷的对一个变量进行赋值操作，赋值就是给变量一个数据

- 运算符：

  - `=`：给变量赋予数据，一般用于定义变量和修改变量数据时使用

    ```javascript
    var num = 2;
    num =3;//变量由2变成3
    num = num+3;//修改变量num的数据，新的变量是旧的变量基础上+3
    num = num-3;//在上面基础上6-3=3
    num = num*3;//在上面基础上3*3=9
    num = num/3;//在上面基础上9/3=3
    num = num%3;//在上面基础上3%3=0
    document.write(num);//输出0
    ```

    

  - `+=`：给变量赋予数据，在原来基础上进行加法运算

    ```javascript
    var num=3;
    num+=3;//num=num+3
    ```

    

  - `-=`：给变量赋予数据，在原来基础上进行减法运算

    ```javascript
    var num=3;
    num-=3;//num=num-3
    ```

    

  - `*=`：给变量赋予数据，在原来基础上进行乘法运算

    ```javascript
    var num=3;
    num*=3;//num=num*3
    ```

    

  - `/=`：给变量赋予数据，在原来基础上进行除法运算

    ```javascript
    var num=3;
    num/=3;//num=num/3
    ```

    

  - `%=`：给变量赋予数据，在原来基础上进行取余运算

    ```javascript
    var num=3;
    num%=3;//num=num%3
    ```

    

  - `++`：给变量赋予数据，在原来基础上+1运算

    ```javascript
    var num=3;
    num++;//num=num+1 自增1
    ```

    - 如果++单独使用，效果相当于自增1

    - 如果在表达式中使用，++特点是根据++所在位置有关

      - 如果++在变量后边，效果是先读取后执行

      - 如果++在变量前面，效果是先执行，后读取

        ```javascript
        var num =1;
        var a=num++ + num--;//3 num=1
        var b=++num - --num;//1 num=1
        var num2 =2;
        var c = ++num2 - --num2;//1 num2=2
        var d = --num2 + num2++;//2 num2=2
        ```

        

  - `--`：给变量赋予数据，在原来基础上-1运算

    ```javascript
    var num=3;
    num--;//num=num-1 自减1
    ```

    



### 关系运算符



- 比较两个数据之间的关系，任何一个关系判断都会返回一个布尔型数据

- 运算符：

  - `>`：大于
  - `<`：小于
  - `==`：等于
  - `!=`：不等于
  - `>=`：大于**或**等于
  - `<=`：小于**或**等于
  - `===`：完全等于
    - 当字符串用数字比较时，数值相等时，用`==`比较，会返回true，但用`===`比较时会返回false
    - `==`只比较数值，不比较数据类型，`===`既比较数值，也比较数据类型

  ```javascript
  document.write(1>2);//返回false
  var num1=1;
  var num2=2;
  document.write(num1<=num2);// 返回true
  document.write("1"==1);//返回true
  document.write("1"===1);//返回false
  ```

  



### 逻辑运算符



- 可以实现多个关系的判断，搭配关系运算符使用，返回的还是布尔类型的数据

- 运算符：

  - `&&`：与，多个条件同时满足

  - `||`：或，多个条件满足一个即可

  - `!`：取反，即true变为false或false变为true

    ```javascript
    //条件1 && 条件2 && 。。。 && 条件n
    //条件1｜｜ 条件2 && 。。。 && 条件n
    //！条件1 条件1本身结果取反
    var num=10;
    document.write(num>=0 && num<100);//大于等于0，小于100，返回true
    document.write(num<0 || num>100);//大于100，小于0，返回false
    document.write(!(num>0));//大于0取反，返回false
    document.write(!num);//false
    document.write(!undefined);//true
    document.write(!null);//true
    document.write(!true);//false
    document.write(!"abc");//false
    //对正常变量取反，都会返回false，只有当变量为undefined和null时为true
    var total;
    			document.write(!total);//true
    ```

    

- 取反应用场景
  - 判断变量是否有数据，如果取反为true，则说明变量值未赋值，如果为false，则说明变量有数据



### 位运算符



## 控制结构



- 概念：某个语法结构，代码的执行顺序并不是从上往下，可能是判断，重复执行等，我们统称这些句法结构为控制结构



### 分支结构



#### if

- `if`结构表示当根据某个条件进行判断时，进行不同处理

```javascript
if(需要判断的条件){
  条件为true时候执行的代码
} else{
  条件为false时候执行的代码
}
流程：
1 判断条件是否为true
2 为true时，执行if {条件为true时候执行的代码}
3 为false时，执行else{}里面的代码
4 if结构结束
```



- `if-else`结构只能处理两个分支，当有三个及以上的分支时，需要额外使用`else if`结构来扩展分支处理

  ```javascript
  if(条件1){
    条件1为true时执行的代码;
  }else if(条件2){
    条件2位true时执行的代码;
  }else if（条件n）{
    条件n位true时执行的代码;
  }else{
    所有条件都为false时执行的代码;
  };
    
  ```

  

- `else`可以不写，不影响程序执行



#### switch



- 也是一种分支结构，功能与if类似
- 特点：
  - 一般适用于固定的分支情况，比如星期几
  - 相对于`if`结构，`switch`更加整齐简洁，代码量少一些
  - 一般每个`case`后面会加一个`break`用于退出`switch`结构，如果不退出，可能会继续执行系一个`case`的代码

- 语法

  ```javascript
  switch(条件){
    case 值1:当条件为case值1的时候要执行的代码;break;
      case 值2:当条件为case值2的时候要执行的代码;break;
      ...
      case 值n:当条件为case值n的时候要执行的代码;break;
    default:
      当所有条件都不满足时候要执行的代码;break;}
  
  var day=new Date().getDay();
  			switch(day){
  				case 0:
  				document.write("今天是星期日");break;
  				case 1:
  				document.write("今天是星期1");break;
  				case 2:
  				document.write("今天是星期2");break;
  				case 3:
  				document.write("今天是星期3");break;
  				case 4:
  				document.write("今天是星期4");break;
  				case 5:
  				document.write("今天是星期5");break;
  				case 6:
  				document.write("今天是星期6");break;
  				default:
  				document.write("输出错误");break;
  				
  			}
  ```

  

- `switch`与`if`的区别：
  - `switch`一般用于固定分支情况，if可用于任何情况
  - `switch`分支需要`break`来结束，`if`自动结束
  - `switch`语法更加简洁



### 循环结构



- 能够重复执行指定代码的语法结构

  

#### for



- 语法：

  ```javascript
  for(当前的循环次数;循环满足的条件;循环次数自增){
     每次循环要执行的代码
  }
  例子：
  for(var i=1;i<=130;1++){
    document.write("重复输出130遍")
  }
  ```

  

- 执行流程：
  - 初始实行当前循环变量，执行一次`var i=1`
  - 判断循环条件是否满足，即`i<=130`是否为true
    - 如果为true，执行第三步
    - 如果不满足，推出整个for循环
  - 执行一次`{}`中的所有代码
  - 循环次数自增，即执行一次`i++`,即`for`循环中第二个分号后的代码
  - 退回到第二步



#### while



- 概念：循环结构的另一种语法，能与`for`循环完全替换使用，只是语法和使用场景不同

- 语法：

  ```javascript
  while(while循环要继续的条件){
    每次循环要执行的代码
  };
  ```

  

- 流程：
  - 判断循环条件是否为`true`，为`true`，执行第二步；为`false`，退出循环
  - 执行`{}`之内的代码，退回第一步

- 与`for`循环的区别
  - `while`更简单，但是不提供循环次数的变量的书写位置
  
  - 两者可以完全相互替用，`while`适用于不关心循环次数的情况，`for`适用于关心循环次数的情况
  
    

#### do...while



- 概念：从`while`演变而来的语法。更适用于先执行一次在判断的场景

- 语法：

  ```javascript
  do{
    要循环的代码；
  } while(循环继续条件);
  
  do{
  				var userinput=prompt("请输入");
  				console.log(userinput);
  			}while(userinput!="y");
  ```

  

- 流程：先执行一次`{}`内的代码，再进行判断是否继续循环执行



#### 各个循环结构的对比



- 三个都是用于循环操作，语法结构和应用场景上有所区别
- `for`和`while`都是先判断再执行，`do..while`是先执行一次，再判断是否循环
- `for`和`while`更加常用，并可以相互替换使用
- `for`适用于有明确循环次数的情况，`while`循环次数未知，`do..while`适用于先执行后判断



#### break&continue



- `continue`：

  - javascript的关键字。能够实现跳过当前循环过程，继续下一次循环

  - 语法：在循环体`{}`中使用即可

  - 执行`continue`时，循环过程中还未执行的代码不执行，即：循环中`continue`后面的代码不执行，循环外面的代码不受影响

    ```javascript
    for(){
      continue;
    }
    
    <script>
    			
    			var i=0;
    			while(i<10){
    				i++;
    				if(i==5){
    					continue;//跳过当前循环继续下一次循环
    				}
    				document.write(i);
    			}
    		</script>
    ```

    

- `break`：

  - Javascript中的关键字，主要是为了结束循环及`switch`结构

  - 作用：结束整个循环

  - 特点：

    - 当`break`被执行时，循环中的循环变量不会依次递增，循环自然结束，编程中我们可以利用这个特点实现判断，比如质数

    - 当`break`处于嵌套循环中，`break`会结束最近的`for`循环

      ```javascript
       for(var i=1;i<=9;i++){
      				 for(var j=1;j<=9;j++){
      					 document.write(j);
      					 break;//结束内循环
      				 }
      				 break;//结束外循环
      			 }
      ```

      

  - 语法：

    ```javascript
    for(){
      break;
    }
    
    
    var i=0;
    			while(i<=10){
    				i++;
    				if(i==5){
    					break;
    				}
    				document.write(i);
    			}
    ```

    

## 数组



- 概念：程序数据的仓库，可以用来保存多个数据。
- 官方定义：数组是一个有序数据的集合，数组的每个数据都有一个对应的编号（下标），用来快速检索。比如多个快递。
- 下标（数组中数据的编号）
  - 下标是一个数字，用于表示该数据在数组中的位置，通过下标可以快速找到该数据
  - 原理：数组中的第一个数据的下标为0，第二个为1，依次递增，最后一个数据的下标为数据个数减1,即：`数组变量.length-1`



### 基本使用



#### 定义数组

```javascript
空数组：

1 数组字面量：【】
var 变量名=【】;//定义一个空数组，并把数组保存到变量中

2 新的数组对象：
var 变量名= new 　Array();//定义一个新的数组对象并保存到变量中

带有默认数据的数组：

1 数组字面量：数据之间以逗号分隔
var 变量名=【数据1,数据2,数据3,...数据n】;//定义一个空数组，并把数组保存到变量中

2 新的数组对象：
var 变量名= new Array(数据1,数据2,数据3,...数据n);//定义一个新的数组对象并保存到变量中

```



#### 数组的基本应用



```javascript
var num=[59,88,77,99,92,73];
```



- 获取数组中指定的一个数据

  ```javascript
  数组变量名[下标]；
  
  num[0];//获取第一个数据59
  ```

  

- 修改数组中指定的一个数据

  ```javascript
  数组变量名[下标]=新数据；
  
  num[2]=66;//将77改为66
  ```

  

- 添加数组中的数据

  ```javascript
  数组变量名[新下标]=新数据；
  
  num[6]=80;//添加第七个数据80
  num[num.length]=80;//添加第七个数据80
  ```

  

- 删除数组中的数据（最后一个）

  ```javascript
  数组变量名.length--;
  数组变量名.length-=1;
  
  num.length--;
  ```

  

- 数组中的数据个数（数组的长度）

  ```javascript
  数组变量名.length;
  
  document.write(num.length);//7
  ```

  

- 数组中全部数据(数组的遍历)

  ```javascript
  for(var i=0;i<=数组变量名.length-1;i++){
  				document.write(num[i]+"<br>");
  			}
  
  for(var i=0;i<=num.length-1;i++){
  				document.write(num[i]+"<br>");
  			}
  ```

  

## 常用API



### API



- 定义：用户编程接口（Application Programming Interface）：用户能直接使用的代码，一个API带有一个功能。
  - 比如`parseInt()`就是一个API，功能是取整，`Math.random()`，`Number()`，`toSrting()`，`toFixed()`，`prompt()`，` alert()`
  - 每个API就是一个函数
  - API是程序内置，可以直接使用，无需知道内部如何实现
  - 以下都是数组相关API

#### `push`



- 数组末尾添加数据

  ```javascript
  数组变量名.push(数据1，数据2.。。数据n)
  
  var arr=[1,2,3,4,5];
  arr.push(6);
  document.write(arr);//[1,2,3,4,5,6]
  arr.push(7,8,9);
  document.write(arr);//[1,2,3,4,5,6,7,8,9]
  ```

  

#### `pop`



- 数组末尾删除数据

  ```javascript
  数组变量名.push(数据)；
  
  var arr=[1,2,3,4,5];
  arr.pop();//每次只删除一个数据，想删除多个需要多次调用此函数
  var data=arr.pop();//用一个变量保存被删除的数据
  document.write(arr);//[1,2,3,4]
  ```

  



#### `unshift`



- 数组开头添加一个或多个数据

  ```javascript
  数组变量名.unshift(数据1，数据2.。。数据n)
  
  var arr=[1,2,3,4,5];
  arr.unshift(0,0,0);
  document.write(arr);//[0,0,0,1,2,3,4]
  ```

  

#### `splice`



- 数组指定位置插入或删除数据

  ```javascript
  数组变量名.splice(插入或删除的开始下标，要删除的数量，添加的数据1，添加的数据2.。。添加的数据n)
  
  var arr=[1,2,3,4,5];
  arr.splice(2,1,-1,-2,-3);
  document.write(arr);//[1,2,-1,-2,-3,4,5]
  ```

  - 数组变量名.splice(插入或删除的开始下标);//后面无参数，表示下标及后面数据全部删除



#### `join`



- 将数组中的数据拼接转为字符串

  ```javascript
  数组变量名.join(数据分隔符)；//分隔符默认为逗号，即join（）
  var arr=[1,2,3,4,5];
  var data=arr.join("-");
  document.write(data);//1-2-3-4-5
  ```

  - `join`生成的字符串需要定义变量来接受



#### `reverse`



- 数组倒叙存放

  ```javascript
  数组变量名.reverse();
  
  var arr=[1,2,3,4,5];
  			arr.reverse();
  			document.write(arr);
  ```

  - 直接对原数组进行操作



#### `concat`



- 和一个或多个数组合并，得到一个新数组，对原数组无影响

  ```javascript
  数组变量名.concat(数组1，数组2。。。数组n)
  
  var arr1=[1,2,3,4,5];
  			var arr2=[6,7,8,9];
  			var arr3=[0];
  			var arr=arr1.concat(arr2,arr3);
  			document.write(arr);
  ```

  

#### `slice`



- 根据下标获取数组中的部分数据

  ```javascript
  数组变量名.slice(开始下标，结束下标);
  
  var arr=[1,2,3,4,5];
  			var arr1=arr.slice(1,4);
  			document.write(arr1);
  ```

  - 包含开始的下标，不包含结束的下标
  
  - 获得新数组，需要定义变量接收
  
  - 如果截取数组结尾是原数组最后一个数据，那么结尾下标可以不写
  
  - 支持开始下标为负数，即开始从倒数第n个开始
  
    ```javascript
    var newarr=arr.slice(arr.length-4,arr.length);
    
    var newarr=arr.slice(-4);
    ```
  
    

### `sort`



- 对数组进行排序

  ```javascript
  数组变量名.sort();//自然排序：0-9 a-z
  var arr=[1,2,"a","s","b",5,4,6];
  			document.write(arr.sort());//1,2,4,5,6,a,b,s
  var arr=[777,654,21,9998,8,76];
  document.write(arr.sort());//21，654，76，777，8，9998 只会按照首位自然排序，不准确
  
  自定义排序：
  数组变量名.sort(function);//定义函数决定数据相邻数据如何排序
  
  var arr=[777,654,21,9998,8,76];
  			function paixu(num1,num2){
  				return num1-num2;//升续，num2-num1，降序
  			}//根据函数返回值排序，如果大于0，num1排在num2前面
  //根据函数返回值排序，如果小于0，num1排在num2后面
  //根据函数返回值排序，如果等于0，num1与num2排在一起
  			arr.sort(paixu);
  			document.write(arr);
  
  arr.sort(function(num1,num2){
  				return num1-num2;
  			})
  
  //随机打乱顺序
  			arr.sort(function(num1,num2){
  				return Math.random()-0.5
  			})
  			document.write(arr);
  ```

  



#### `indexOf`



- 获取某数据在数组中第一次出现的下标，没有的话返回-1

  ```javascript
  数组变量名.indexOf(数据);
  
  var arr=[1,2,3,3,5];
  			document.write(arr.indexOf(3));//返回2
  var arr=[1,2,3,3,5];
  			document.write(arr.indexOf(6));//返回-1
  ```

  



#### `lastindexOf`



- 获取某数据在数组中最后一次出现的下标，没有的话返回-1

  ```javascript
  var arr=[1,2,3,3,5];
  			document.write(arr.indexOf(3));//返回3
  var arr=[1,2,3,3,5];
  			document.write(arr.indexOf(6));//返回-1
  ```

  

### 数组习题

力扣（http://leetcode.cn）



## 二维数组



### 概念



- 数组中的每个数据都是一维数组
- 一维数组指数组中的数据都是具体的数据，如【1，2，3，4，5】



### 作用



- 用来表示多个符合数据的集合，比如多个学生，每个学生又有姓名，年龄，性别，成绩。



### 基本操作



- 定义：二维数组本身就是一个普通的数组，只是里面的数据变为一维数组后，数组成为二维数组

  ```javascript
  var arr=[];
  arr.push([1,2,3,4,5]);
  
  var students=[];
  students.push(["tom",24,"male",80]);
  students.push(["jerry",25,"female",100]);
  students.push(["lee",28,"male",77]);
  students.push(["rose",26,"female",90]);
  ```

  

- 获取数据

  ```javascript
  数据变量名.[下标]
  
  arr[0];//[1,2,3,4,5]
  arr[0][0];//1
  
  students[0];//["tom",24,"male",80]
  students[0][2];//"male"
  ```

  

- 添加数组

  ```javascript
  students.push(["bale",18,"male",88]);//添加一条数据
  students[2].push("leee");//第三条数据后面添加一个数据
  ```

  

- 删除数据

  ```javascript
  students.length--;//删除最后一条数据
  students[2].length--;//删除第三条数据的最后一个数据
  ```

  

- 修改数据

  ```javascript
  students.splice(0,2,["muyancheng","9","male",100]);//将第一条和第二条数据替换成【"muyancheng","9","male",100】
  students[2].splice(0,1,"leee");//修改第三条数据里面第一个数据，替换成“leee”
  students[2][0]="zhangqinning";//修改第三条数据里的第一个数据为“张秦宁”
  ```

  

- 长度

  ```javascript
  document.write(students.length) ;//共4条数据
  document.write(students[0].length) ;//第一条数据的长度，4
  ```

  

- 遍历

  ```javascript
  for(var i=0;i<students.length;i++){
                  for(var j=0;j<students[i].length;j++){
                      document.write(students[i][j]+"<br>");
                  }
                  document.write(students[i]+"<br>");
              }
  ```

  

## 函数



### 概念



- 背景：对不同数据进行相同操作，会导致代码重复，操作繁琐，所以会使用到函数
- 函数：指一个容器，该容器包含一段代码，通过函数能够重复使用这段代码



### 基本使用



- 定义函数

  ```javascript
  function 函数名(){
    包含的代码；
  }
  ```

  

- 调用函数

  ```javascript
  函数名();
  ```

  - 函数可以多次调用，没调用一次，函数内的代码会执行一次

    

- 问题
  - 如果只是基本使用，可以解决代码重复问题，但是函数本身不能对不同数据进行处理，想要使用参数来解决



### 参数



- 概念：函数对不同数据处理的一种机制，分为形式参数和实际参数，两种参数是协同工作的

  - 可以使用参数将要处理的数据传入函数中进行处理，对多个数据处理，只需要调用多次函数

    ```javascript
    函数名(参数1);
    函数名(参数2);
    函数名(参数3);
    ```

    

- 形式参数：指函数定义时`()`里的变量，该变量可以在函数体`{}`内使用，形式参数里的数据来自于实际参数

  ```javascript
  function 函数名(形式参数){
    包含的代码；
  }
  ```

  

- 实际参数：指在函数调用时，写在`()`中的具体数据，有时具体数据也可以是一个变量。函数调用时，实际参数会把数据传递给形式参数，在函数体`{}`执行时，让形式参数是有具体数据的

  ```javascript
  函数名(实际参数);
  
  函数名（123）；
  或
  var num=123;
  函数名(num);
  ```

  

- 参数的使用

  ```javascript
  function demo(num){
  				document.write(num+7);
  			}
  			demo(3);//10
  ```

  

- 多个参数

  ```javascript
  function 函数名(参数1，参数2。。。参数n){
    ...
    return ...
  }
  
  //例子
  var x=Number(prompt("input x"));
  			var y=Number(prompt("input y"));
  			function num(x,y){
  				var total=1;
  				for(var i=1;i<=y;i++){
  					total*=x;
  				}
  				return total;
  			}
  			var sum= num(x,y);
  			document.write(sum);
  ```

  - 函数可以有多个参数，彼此之间用逗号分隔，形式参数与实际参数之间的顺序必须一致
  - 参数可以任意数量，无限制，实际参数数量根据实际情况确定



### 返回值



- 当函数调用执行后，函数里的变量和数据不能直接在函数外使用。

  ```javascript
  var arr1=[1,3,4,55,6];
  			var arr2=[22,4,66,5,9];
  			var arr3=[3,3,7,58,8];
  			
  			function total(arr){
  				var max=arr[0];
  				for(var i=0;i<arr.length;i++){
  					if(max<arr[i]){
  						max=arr[i];
  					}
  				}
  			}
  			total(arr1);
  			document.write(max);//报错，max是函数total的变量，在函数外不能使用
  ```

  

#### 概念



- 返回值是一种数据输出机制，可以通过返回值将函数里的变量和数据传递到函数外，即函数调用后可以继续使用函数里的变量和数据

  

#### 语法



```javascript
1.书写return语句，表示函数调用后需要返回的数据，即函数外可以继续使用的数据

functon 函数名(){
  
  return 要返回的数据;
}

2.函数调用后，通过定义变量接受函数的返回值

var 变量名=函数名();//变量名保存的就是return返回的数据。

//例子：
var arr1=[1,3,4,55,6];
			var arr2=[22,4,66,5,9];
			var arr3=[3,3,7,58,8];
			
			function total(arr){
				var max=arr[0];
				for(var i=0;i<arr.length;i++){
					if(max<arr[i]){
						max=arr[i];
					}
				}
				return max;
			}
			var sum= total(arr1)+total(arr2)+total(arr3);
			document.write(sum);
```

- 一般来说，`return`写在函数的最后一行，一般会返回函数处理后的数据。

- 变量接收后，可以通过变量继续使用函数返回的数据

- `return`妙用

  - 当函数中`return`语句被执行时，会终止当前函数调用，即该次函数调用剩余代码不会被执行
  - 函数的默认返回值是`undefined`
  - 作用：对函数传入的参数进行检测，提高函数的健壮性。

  ```javascript
  function sum(num){
  				if(typeof num!="number"){
  					return;//return出现会终止函数其他代码运行，类似break；
  				}
  				var a=num+10;
  				return a;
  			}
  			var s=sum(5);
  			var s1=sum("aaa");
  			document.write(s,s1);//15 undefined
  ```

  

### Arguments



- 定义：`arguments`是javascript针对函数内的一个类数组对象

- 作用：可以在函数调用时保存所有的实际参数

- 使用：`arguments`只能在函数体内使用

  ```javascript
  function demo(){
    document.write(arguments);
  }
  
  function demo(){
  				document.write(arguments[0]);
  			}
  			demo("111","222","333");//111
  
  function demo(){
  				for(var i=0;i<arguments.length;i++){
  					document.write(arguments[i]);
  				}
  				
  			}
  			demo("111","222","333");//111222333
  ```

  

- 特点：

  - 类数组，可以遍历，也可以通过下标来使用`arguments`内的数据，但不能进行添加和修改等操作
  - 实际参数在`arguments`里的顺序，跟在函数内调用时书写的顺序一致

- 应用

  - 当函数实际参数不固定，可以使用`arguments`以及遍历来获取及处理每一个参数

    - 如模拟实现push

      ```javascript
      var str="";
      			function stradd(){
      				for(var i=0;i<arguments.length;i++){
      					str+=arguments[i]+"\n";
      				}
      				return str;
      			}
      			stradd("hello","fucking","world");
      			document.write(str);
      
      var arr=[1,2,3,4];
      			function pushtest(array){
      				for(var i=1;i<arguments.length;i++){
      					array[array.length]=arguments[i];
      				}
      				return arr;
      			}
      			pushtest(arr,5,6,7,8,9);
      			document.write(arr);
      ```

      



### 箭头函数（ES6）



- 定义：ES6提供的新的定义函数的语法

- 作用：代码更加简洁

  ```javascript
  var 函数名 = (形式参数) =>{
    函数体;
  }
  
  demo()//调用在定义前后，都可用
  			
  			function demo(){
  				document.write("funtion demo");
  			}
  			
  			jiantoudemo();//调用在定义前，不可用
  			var jiantoudemo=()=>{
  				document.write("jiantoudemo");
  			}
  			jiantoudemo();//调用在定义后，可用
  ```

  - 箭头函数调用与`Function`一致

  - 箭头函数只能定义后使用，`Function`函数无此限制

  - 如果箭头函数只有一句`return`代码，可以省略`return`关键字及`{}`

  - 如果箭头函数只包含一个形式参数，那么形式参数外的`()`可以省略

    ```javascript
    function add(a,b){
    				return a+b;
    			}
    
    var arrow=(a,b) => a+b;
    
    var arrow=a=>a+5;
    ```

    

- 应用

  - `sort`

  ```javascript
  var arr=[1,2,4,3,8,3];
  			/* arr.sort(function(num1,num2){
  				return num1-num2;
  			}); */
  			arr.sort((num1,num2)=>num1-num2);
  			document.write(arr);
  ```

  

## DOM



###  概念



- 文档对象模型（Document Object Model），Javascript将网页（Html）看作一系列标签的集合，并提供了一系列API来操作这些标签，实现对标签的增删改查，以及Css的修改，以实现对Html的动态效果

  

### 发展



- DOM 0级：96年，IE与Nescape各自实现Javascript对Html操作的API，无统一标准
- DOM 1级：98年，W3C推出标准，IE8支持，只能支持简单的Html标签操作，
- DOM 2级：所有浏览器都支持版本，增强了对页面的控制及添加了对CSS的支持，以及事件支持
- DOM 3级：对API进行模块化，方便管理和更新



### 兼容



- DOM 1级：IE8及以下
- DOM 2级：IE9+以及现代主流浏览器



### 基本操作



#### `document`



- `document`操作是DOM的核心，大多数API都是通过该对象提供

  - 基础API

    - 获取`body`标签

      ```javascript
      var body=document.body;
      ```

      

    - 获取`html`标签

      ```javascript
      var html=document.documentElement;
      ```

      

    - 获取`title`标签标签

      ```javascript
      var title=document.title;
      ```

      

    - 获取页面上地址

      ```javascript
      var url=document.URL;
      ```

      

    - 获取页面上所有图片

      ```javascript
      var image=document.images;
      ```

      

    - 获取页面上所有表单

      ```javascript
      var form=document.forms;
      ```

      

  - Html页面API

  - Javascript中`dom`的一般流程

    - 获取Html标签

      - 通过`id`

        ```javascript
        var input=document.getElementById("demo");
        			console.log(input);
        ```

        

      - 通过`class`

        ```javascript
        var p=document.getElementsByClassName("p2demo");
        			console.log(p);
        ```

        - 获得的是一个数组，无数据或只有一个也是一个数组
        - 想要查看第一个标签：p[0]，第二个标签p[1]。。。，最后一个标签p[p.length-1]

      - 通过标签名

        ```javascript
        var tag=document.getElementsByTagName("div");
        			console.log(tag[1]);
        ```

        - 获得的是一个数组，无数据或只有一个也是一个数组
        - 想要查看第一个标签：tag[0]，第二个标签tag[1]。。。，最后一个标签tag[tag.length-1]

      - 通过`querySelector`或`querySelectorAll`

        - `querySelector`或`querySelectorAll`支持css的各种标签选择器格式查找标签

        - `querySelector`：匹配第一个符合条件的标签

          ```javascript
          var p1=document.querySelector("div p");
          			console.log(p1);
          ```

          

        - `querySelectorAll`：匹配所有符合条件的标签

          ```javascript
          var p1=document.querySelectorAll("div");
          			console.log(p1[0]);
          ```

          

          - 获得的是一个数组，无数据或只有一个也是一个数组
          - 想要查看第一个标签：数组[0]，第二个标签：数组[1]。。。，最后一个标签数组[数组.length-1]

    - 修改或获取Html标签的内容

    - 修改Html标签的CSS
    
      

- 属性

  - 先获取标签

  - 在通过标签变量.`getAttribute`获取标签属性

    ```javascript
    
    标签变量名.getAttribute("属性名")
    
    <img src="img/id1.jpg" id="img">
    
    var img=document.queryselector("img");
    var src=img.getAttribute("src");
    ```

  - 设置标签属性 `setAttribute`

    ```javascript
    标签变量名.setAttribute("属性名","属性值)
                       
    <img src="img/id1.jpg" id="img">
    var img=document.queryselector("img");      
    img.setAttribute("src","img/id2.jpg");
    ```

    





#### 获取/修改Html标签的内容/属性



- 内容

  - `value`

    ```javascript
    <body>
    		<input type="text" id="demo" value="123">
    		<button id="buttondemo">button</button>
    		<div id="divdemo">
    			<p>context1</p>
    			<p>context2</p>
    		</div>
    </body>
    //先获取标签
    var 变量名=document.querySelector("标签名"//".类名"//"#id名");
    
    var ipt=document.querySelector("input");
    
    //再获取内容
    变量名.value；
    
    ipt.value;
    document.write(ipt.value);
    
    //修改内容
    ipt.value="新内容";
    ```

    

  - `innerHTML`

    - 获取标签内的Html代码，针对`<开始标签>。。。</结束标签>`

      ```javascript
      <input type="text" id="demo" value="123">
      		<div id="divdemo">
      			<button id="buttondemo">login</button>
      			<p>context1</p>
      			<p>context2</p>
      		</div>
      
      <script>
             var p1=document.querySelector("#divdemo");
      			var innerh=p1.innerHTML;
      //修改html代码内容
      //p1.innerHTML="新内容";
      			document.write(innerh);
      </script>
      ```

      

  - `innerText`

    - 获取标签文本内容，针对`<开始标签>。。。</结束标签>`

      ```javascript
      <input type="text" id="demo" value="123">
      		<div class="divdemo">
      			<button id="buttondemo">login</button>
      			<p>context1</p>
      			<p>context2</p>
      		</div>
      
      <script>
              var p=document.querySelector("#buttondemo p");//buttondemo下第一个<p>标签
      			var innerp=p.innerText;
      //修改文本内容
      //p.innerText="新内容";
      			document.write(innerp);
      </script>
      ```

    

#### 点击事件



- 当用户点击某个按钮时，执行某段js代码，此方法所有标签都可以添加

```javascript
//1标签上书写 onclick="jscode";

<body>
		<div onclick="alert(`点击事件`)">点击事件</div>
	</body>

<body>//函数实现
		<div onclick="demo()">点击事件</div>
		
		<script>
			
			function demo(){
				alert("函数实现onclick");
			}
		</script>
		
	</body>

//2在js中写

标签变量名.onclick=function(){
  jscode;
}

<div id="click">点击事件2</div>
<script>
			var click=document.querySelector("#click"); 
			click.onclick=function(){
				alert("完全js实现点击事件");
			}
		</script>
```



- `eval`

  - Javascript内置函数，将某个字符串作为Javascript代码执行并返回执行结果

    - `eval`只能执行字符串内（“”）的算式和程序，不能将字符串与其他类型数据一起计算，也不能将两个字符串变量进行运算
    
    ```javascript
    var s=eval("2+2");
    eval("var a=10;alert(a);")
    document.write(s);
    
    //错误情况：
    var input=document.querySelector("input");
    			var text=input.value;
    			
    			input.value=eval(text+text);
    			document.write(input.value); 
    
    var s="2+2";
    var s1=eval(s+3);
    ```
    

  

- `substring` `substr`

  - 都是Javascript内置API，用于获取字符串的一部分字符串

  - `substring` `substr`如果截取字符串都是到字符串末尾，第二个参数可以不写
  
    ```javascript
    字符串.substr(子字符串开始下标,截取长度)//截取长度：字符串数量
    字符串.substring(子字符串开始下标,字符串结束下标)//不包含结束下标
    
    var s="hello world";
    var news=s.substr(0,5);//hello
    var news1=s.substr(0,s.length-1);//hello worl
    
    var str="hello world";
    			//var newstr=str.substring(0,7);//hello w
    			//var newstr=str.substring(0,str.length-1);//hello worl
    			var newstr =str.substring(6,str.length);//world
    			document.write(newstr);
    ```
    
    

- 获取被点击标签本身

  ```javascript
  <div onclick="函数名(this)"></div>//this是固定用法，用它作为实际参数可以使被点击的标签在js中设置形式参数被调用
  
  //js1:
  function  函数名(x){
    //x 代表onclick的div
  }
  //js2:
  var div=document.queryselector("div");
  div.onclick=function(){
    this.innerText="div clicked";
  }
  ```

  



#### 添加Html标签



- 利用Javascript的相关API（document.createElement()）在Html中新生成一个Html标签，并利用`appendChild`或`insertBefore`将新生成的标签放入页面中

  

- 流程：

  - 利用`document.createElement()`在程序中生成一个新的标签，新标签是存在于代码中，页面中不显示
  - 利用`appendChild`或`insertBefore`将第一步新生成的标签追加到页面中

  

- `document.createElement()`

  - 新建标签

    ```javascript
    var 标签变量名=document.createElement("标签名");
    
    var newdiv=document.createElement("div");
    ```

    



- `appendChild`

  - 将某个新增的标签添加到页面中，作为其父标签的最后一个子标签，需要确保父标签已经存在于页面中

    ```javascript
    父标签变量名.appendChild(子标签变量名)；
    
    var newdiv=document.createElement("div");
    var body=document.body;
    body.appendChild(newdiv);
    var father=document.querySelector(`#fatherdiv`);//id为fatherdiv的父标签下添加一个div
    father.appendChild(newdiv);
    
    ```

    

- `insertBefore`

  - 将某个标签追加到页面上，并作为其父标签并放置在兄弟标签之前

    ```javascript
    父标签变量名.insertBefore(新标签变量名,兄弟标签变量名);
    
    var father=document.querySelector("div");
    			var brother=document.querySelector("p");
    			var p=document.createElement("p")
    			p.innerText="label2";
    			father.insertBefore(p,brother);
    ```

    



#### 删除Html标签



- 流程：
  - 获取父标签及要删除的子标签
  - 父标签调用`removeChild`删除子标签

- `removeChild`

  ```javascript
  父标签变量.removeChild("子标签");
  
  var farther=document.querySelector("div");
  			var p=document.querySelector("div p");
  			farther.removeChild(p);
  ```

  - `removeChild`只能删除一个标签

  - 批量删除

    - 获取待删除的标签

    - 对这些标签进行``for`循环遍历，父标签利用`removeChild`依次删除

      ```javascript
      var div=document.querySelectorAll("div");
      			var body=document.body;
      			for(var i=0;i<div.length;i++){
      				body.removeChild(div[i]);
      			}
      ```

      



####  获取兄弟标签



- `previousElementSibling`:上一个兄弟标签

  ```javascript
  标签变量名.previousElementSibling；//获取标签变量的上一个标签
  ```

  

- `nextElementSibling`：下一个兄弟标签

  ```javascript
  标签变量名.nextElementSibling；//获取标签变量的下一个标签
  ```

- 例子

  ```javascript
  <button onclick="minus(this)">-</button>
  		<input type="text" value="1">
  		<button onclick="add(this)">+</button>
  
  function add(btn){
  				var input=btn.previousElementSibling;
  				input.value++;
  			}
  			
  			function minus(btn){
  				var input=btn.nextElementSibling;
  				input.value--;
  			}
  ```

  



#### 获取子标签



- 通过父标签来获取子标签

- `firstElementChild`

  - 获取第一个子标签

    ```javascript
    父标签变量.firstElementChild;
    
    <div>
    			<button onclick="minus(this)">-</button>
    			<input type="text" value="1">
    			<button onclick="add(this)">+</button>
    		</div>
    
    var div=document.querySelector("div");
    			var btn=div.firstElementChild
    			console.log(btn);//<button onclick="minus(this)">-</button>
    ```

    

- `lastElementChild`

  - 获取最后一个子标签

    ```javascript
    父标签变量.lastElementChild;
    
    <div>
    			<button onclick="minus(this)">-</button>
    			<input type="text" value="1">
    			<button onclick="add(this)">+</button>
    		</div>
    
    var div=document.querySelector("div");
    			var btn=div.lastElementChild
    			console.log(btn);//<button onclick="add(this)">-</button>
    ```

    

- `children`

  - 获取全部子标签，不包括孙子标签，返回数组

    ```javascript
    父标签变量.children;
    
    <div>
    			<button onclick="minus(this)">-</button>
    			<input type="text" value="1">
    			<button onclick="add(this)">+</button>
    		</div>
    
    var div=document.querySelector("div");
    			var btn=div.children;
    			console.log(btn);//HTMLCollection(3){0:<button onclick="minus(this)">-</button>;1:	<input type="text" value="1">;2:	<button onclick="add(this)">+</button>}
    ```

    



#### 获取父标签



- `parentElement`

  ```javascript
  标签变量名.parentElement
  
  function add(btn){
  				var father=btn.parentElement;
  				console.log(father);
  			}
  ```

  



#### Css操作



- 获取
  - `getComputedStyle`

    - Javascript内置函数，获取某个标签所有最终样式
  
      ```javascript
      var 变量名=getComputedStyle(标签变量名,null);
      ```
  
      - 该函数会返回一个对象，通过定义变量接收。对象包含了标签所有样式属性及属性值，可以通过`对象变量名.css属性名`来获取该属性的值
  
        ```javascript
        var div=document.querySelector("div");
        var stylediv= getComputedStyle(div,null);
        console.log(stylediv.width,stylediv.height,stylediv.backgroundColor);
        ```
  
        
  
- 设置
  - `标签变量名.style.css属性名=css属性值`
  
    ```javascript
    var div=document.querySelector("div");
    			div.style.backgroundColor="blue";
    ```
  
    - 如果css属性名中间带“-”，需要把“-”去掉，后面的第一个字母大写
  
    - Javascript会将设置的css样式作为嵌入式样式放入标签属性中,保证优先级最高
  
      ```javascript
      <div style="background-color=`blue`>...</div>
      ```
  
      

### DOM树



#### 概念



- DOM将整个文档看作一个倒挂的树，HTML标签是一个个树枝（标签下包含了其他标签）或叶子（标签下无其他标签）。

- 我们称整个文档为一个`document`对象，是Javascript语言中整个HTML页面的对象，他有唯一一个节点，即`<html>`节点，也称为根节点。其他节点相对于根节点来说都是子节点，而子节点也有子节点。

- DOM技术就是用来操作这个DOM树，Javascript利用DOM技术来修改DOM树内容从而达到修改HTML文档的目的

- 总结：

  - Javascript为了操作方便，将整个HTML页面抽象成一个具有层级结构的文档，我们称之为“DOM树”
  - 每个HTML标签都是一个节点，其中标签内部的属性和文本内容在Javascript中也会作为一个节点存在
    - 例如下面的`<a>`标签，`<a>`为一个节点，`href`和``我的链接``也是节点

  ```javascript
  <!DOCTYPE html>
  <html>//根元素
  	<head>//元素
  		<meta charset="utf-8">
  		<title></title>//元素
  	</head>
  	<body>//元素
  		<a href="http://www.baidu,com">我的链接</a>//元素，href：属性，“我的链接”：文本
  		<h1>title</h1>//元素
  	</body>
  </html>
  ```

  

#### DOM节点



- 根据W3C规定，将节点分为12种类型，常用的3种：
  - 元素节点`Element Node`：HTML标签
  - 属性节点`Attribute Node`：元素节点中的一个属性
  - 文本节点`TextNode`：元素节点中的文本内容



-  常用API：

  - `nodeName`:节点的名称，如`<div>`的`nodeName`是DIV

  - `nodeType`:节点的类型

    - `1`:元素节点
    - `2`:属性节点
    - `3`:文本节点

    ```javascript
    var a=document.querySelector("a");
    			a.nodeName//A
    			a.nodeType//1
    ```

    

### 字符编码



#### 概念



- 为了在不同的计算机中能够正确的显示字符，设计出字符编码用于设置在计算机中用0和1的不同组合来表示不同字符

- 字符编码随着计算机发展和不同国家语言，字符编码也很多种，第一个通用的字符编码是`ASCII`，后续用于替代asc码的全球普及的编码格式是`UTF-8`，中国专业字符编码是`GB2312``GBK`,`unicode`兼容`ASCII`

- `ASCII`十进制常用范围

  - 数字0-9：48-57
  - 小写字母a-z：97-122
  - 大写字母A-Z：65-90
  - 127位`ASCII`除了以上范围内都是符号

  

#### 常用API



- `charCodeAt(下标)`：获取字符串中指定下标字符的`ASCII`码

  ```javascript
  var str="abc";
  var code=str.charCodeAt(0);
  console.log(code);//97
  ```

  

- `String.fromCharCode(数字)`：通过`ASCII`获取对应字符并返回

  ```javascript
  var code=String.fromCharCode(97);
  console.log(code);//a,a为字符串
  ```

  

## BOM



### 概念



- Browser Object Model,浏览器对象模型，Javascript会把浏览器的一个标签页（网页）作为一个对象存在于程序当中，提供了一系列的API来操作标签页本身。比如新建或关闭标签页，或跳转页面，前进后退。。。

- 本质上相当于把一个页面当成一个对象数据放在Javascript程序中，通过提供的API来操作页面本身

- 类似于DOM核心是`document`一样，BOM核心对象是`window`，具体BOM相关的API是由`window`提供，所以BOM核心就是`window`对象

  

### window对象概念



- `window`对象是每一个页面都会有的对象，Javascript自动生成，每个页面的`window`对象是不同的

- `window`对象提供了用于操作本页面所需的所有API，值得一提的事`document`对象事作为`window`对象的一部分

  ```javascript
  console.log(window);
  console.log(window.document)//等于console.log(document)
  ```

  - 作为`window`对象里的API，使用时可以省略`window.`前缀

    ```javascript
    window.alert("123");等同于 alert("123");
    ```

    

### window对象API



- `alert`

- `prompt`

- `confirm` ：页面上弹出一个确认框，返回`true`或`false`:点击确定，返回`true`，否则返回`false`

- `open`：新建一个页面，不推荐使用，受浏览器安全机制，可能无法执行

  ```javascript
  window.open("网页地址",打开方式,"窗口的基本配置")
  
  window.open("http://www.baidu.com","_blank","width=300,height=300,top=100,left=100")
  ```

- `close`：关闭当前页面

  ```javascript
  var result=confirm("yes or no?");
  			if(result==true){
  				window.close();
  			}
  ```

- `setInterval`

- `setTimeout`

- `clearInterval`

- `clearTimeout`

- `innerWidth`：用于获取页面窗口的宽度

- `innerHeight`：用于获取页面窗口的首屏高度

```javascript
console.log(innerHeight,innerWidth);
```

- `outerWidth`:用于获取窗口的宽度
- `outerHeight`:用于获取整个HTML（窗口）文档的高度，即`innerHeight`+浏览器工具栏高度



### BOM四大内置对象



#### `location`



- 基础概念：

  - 属于`window`对象，本身也是对象，内置了一些API能够实现刷新，页面跳转，获取页面地址等功能

  - 常用API：

    - `location.host`：页面地址中的主机地址

    - `location.port`：页面地址中的端口

    - `location.protocol`：页面地址中的网络协议

    - `location.hostname`：页面地址中的ip地址

    - `location.search`：页面地址中的数据，链接中“？”后面的参数，如：?name=az&age=12

    - `location.href`：页面完整地址

    - `location.assign()`：跳转指定页面，新建一条历史记录

    - `location.replace()`：跳转到指定页面，替换当前历史记录，无法后退到上一个页面

    - 除了`location.href`以外都不可以修改，只可以查看

      ```javascript
      console.log(location.href);
      
      ```

      

- 刷新页面

  

  - `location.reload()：`刷新当前页面

    ```javascript
    location.reload()
    ```

    

- 跳转页面

  

  ```javascript
  location.assign("http://www.baidu.com");
  location.href="http://www.baidu.com";
  ```

  

- 获取页面地址中的数据，实现多页面数据共享

  

  - 结合表单及`location.search`实现

    ```javascript
    <form action="../success.html">
    			name:<input type="text" name="user">
    			password:<input type="text" name="pass">
    			<button>submit</button>
    		</form>
    
    // success.html
    
    <script>
    			console.log(location.search)//?user=dd&pass=dd
    		</script>
    ```



#### `history`



- 提供了页面前进或后退的API，实现页面的前进或后退
- API：
  - `go()`：格局数字的正负来确定是前进还是后退的页数
    - `go(-1)`:后退一页
    - `go(1)`:前进一页
  - `forward()`：前进一页
  - `back()`：后退一页

```javascript
history.go(-1);
history.forward();
history.back();
```



- 应用场景：

  - 用户登录后返回上一个访问的页面，而不是返回首页

    

#### `navigator`



- 收集了跟浏览器本身相关的信息，如浏览器版本，当前操作系统版本等
- 应用场景：
  - 配合正则表达式判断当前用户使用的浏览器版本及是否是移动端，方便切换移动端和PC端

- API

  - `userAgent`：返回浏览器版本信息

    ```javascript
    navagator.userAgent();
    ```

    

#### `screen`



- 收集屏幕相关信息，是否横屏竖屏，色彩度等，HTML5针对`screen`新增了`orientation`来获取屏幕角度信息，竖屏返回0，横屏返回90

  ```javascript
  screen.orientation.angle
  ```

  

### 定时器



#### 延时定时器



- 概念

  - javascript提供了两个api实现一定时间之后执行某段javascript代码的功能

  - 根据指定代码是否重复执行分为两种定时器

    

- `setTimeout`

  - 利用javascript内置api`setTimeout`实现在一定时间之后执行一次指定的javascript代码，代码执行后定时器结束

    ```javascript
    setTimeout(function(){
      执行的js代码;
    },延时时间);
    
    setTimeout(function(){
      console.log("2秒后输出次语句");
    },2000);
    ```

    - 延时时间以毫秒为单位，1000毫秒=1秒

    - 利用内置`clearTimeout`终止执行

      ```javascript
      clearTimeout(延时器标识符);
      
      var timeout=setTimeout(function(){
        console.log("2秒后输出次语句");
      },2000);//timeout保存了改定时器的标识符
      
      clearTimeout(timeout);
      ```

      - 标识符：定时器id，表示要暂停哪个定时器，标识符可以通过`setTimeout`的返回值获得

      - `clearTimeout`在定时器执行之前使用，在定时器执行完后`clearTimeout`无效

        

#### 间隔定时器



- `setIterval`

  - 概念：每隔一段时间都会执行一次制定的代码。即如果不暂停，间隔定时器会一直执行下去

  - 语法

    ```javascript
    setInterval(function(){
      要执行的代码;
    },间隔的时间);
    
    setInterval(function(){
    				document.write("间隔定时器");
    			},2000);
    ```

    - 延时时间以毫秒为单位，1000毫秒=1秒

    - `clearInterval`停止间隔定时器

      ```javascript
      clearInterval(间隔定时器标识符)；
      
      var timeout=setInterval(function(){
      				console.log("间隔定时器");
      			},2000);
      			
      			function pause(){
      				clearInterval(timeout);
      			}
      ```

      

#### 延时定时器与间隔定时器区别



- 延时定时器是一段时间后只执行一次，执行后就结束；间隔定时器是每隔一段时间都要重复执行一次
- 结束定时器使用的内置函数不同，`cleartTimeout``clearInterval`



## 事件



### 基础



- 概念：用户与页面交互的各种动作的统称，点击，双击，按压键盘，滚轮。。。
- 我们可以实现通过事件的处理能够当用户触发某个动作时，能够去执行我们的Javascript代码



#### 分类



- `UI`：与用户间接相关

  

  - `load`：在资源加载完成之后进行触发

    - 只针对`window`对象和`img`标签有效

    - `window`对象是DOM加载完成后触发，`img`标签是图片加载完成后触发

    - `window.onload`可以保证要执行的js代码无论在页面什么位置都可以正常执行

      

  - `resize`：在页面尺寸发生变化时进行触发

    ```javascript
    标签变量名.onload=function(){
      //页面加载完成后执行的js代码;
    }
    标签变量名.onresize=function(){
      //页面加载完成后执行的js代码;
    }
    
    window.onload=function(){
      //页面加载完成后执行的js代码;
    }
    window.onresize=function(){
      //页面加载完成后执行的js代码;
    }
    
    var img=document.queryselector("img");
    img标签变量名.onload=function(){
       //图片加载完成后执行的js代码;
    }
    ```

    - 普通标签设置无效

- `鼠标`

  - `click`：点击事件

  - `dblclick`：双击事件

  - `mousemove`:鼠标移动时触发的事件，在指定标签内部移动时才会触发

  - `mouseenter`：鼠标在进入指定标签内部时触发一次

  - `mouseleave`：鼠标在离开指定标签边界时触发一次

    ```javascript
    标签变量名.ondblclick=function(){
      //双击要执行的js代码;
    }
    
    标签变量名.onmousemove=function(){
      //鼠标在标签内移动时要执行的js代码;
    }
    
    标签变量名.onmouseenter=function(){
      //鼠标在进入标签内时要执行的js代码;
    }
    
    标签变量名.onmouseleave=function(){
      //鼠标在离开指定标签时要执行的js代码;
    }
    ```

    

- `键盘`

  - `keydown`按下键盘任何键时触发

  - `keyup`：按下键盘任何一个键，完全释放时触发

    - 推荐使用，可以获得最新的输入内容

  - `keypress`：按下任何一个键到底部即将离开时触发

  - 用来检测用户输入是否合法

    ```javascript
    标签变量名.onkeydown=function(){
      //按下键盘时要执行的js代码，如果设置在标签上，只在标签内生效;
    }
    
    标签变量名.onkeyup=function(){
      //键盘释放时要执行的js代码，如果设置在标签上，只在标签内生效;
    }
    
    标签变量名.onkeypress=function(){
      //按下任何一个键到底部即将离开时要执行的js代码，如果设置在标签上，只在标签内生效;
    }
    ```

    

    

- `焦点`

  - `focus`：一般是表单元素获取焦点时触发，如鼠标点击输入框

  - `blur`：一般是表单元素失去焦点时触发，如鼠标移出输入框

  - 用于用户输入检测，或改变样式

    ```javascript
    标签变量名.onfocus=function(){
      //获取焦点时要执行的js代码;
    }
    
    标签变量名.onblur=function(){
      //失去焦点时要执行的js代码;
    }
    ```

    

- `文本`

  - `change`：针对下拉菜单，获取用户的选项，当用户切换选项时触发，不变更选项不触发

    - 常用于数据联动，如切换省，下面的城市更着变化

    ```javascript
    标签变量名.onchange=function(){
      //切换选项时要执行的js代码;
    }
    ```

    

- `滚轮`

  - `mousewheel`：当鼠标滚轮滚动时触发，不断滚动不断触发，火狐不兼容，DOM0级别的语法

  - `DOMMouseScroll`：当鼠标滚轮滚动时触发，不断滚动不断触发，火狐兼容，DOM2级别的语法

    ```javascript
    标签变量名.onmousewheel=function(){
      //鼠标滚轮滚动时要执行的js代码;
    }
    
    标签变量名.addEventListener("DOMMouseScroll",function(){
    						//鼠标滚轮滚动时要执行的js代码;;
    ```

    - 用于长列表数据加载

- `触摸屏`

  - `touchstart`：当触摸屏单个手指点击触发

  - `touchend`：当触摸屏单个手指离开屏幕时触发

  - `touchmove`：当触摸屏上单个手指在触摸屏上不断移动时触发

    ```javascript
    标签变量名.addEventListener("touchstart",function(){
    						//触摸屏单个手指点击时要执行的js代码；
     });
    标签变量名.addEventListener("touchend",function(){
    						//触摸屏单个手指离开时要执行的js代码；
     });
    标签变量名.addEventListener("touchmove",function(){
    						//触摸屏单个手指在屏幕移动时要执行的js代码；
     });
    ```

    

### 事件流



#### 概念

- 为了解决针对嵌套标签的事件触发位置问题，所以才有了事件流的概念

- 事件流是指事件触发的顺序流向，即谁先触发，谁后触发，针对嵌套标签

- 根据事件触发的顺序不同，分为冒泡和捕获

  - 冒泡：从具体触发事件的标签开始冒泡，依次触发父标签及主线标签的事件

    ```javascript
    <div class="div1">div1
    			<div class="div2">div2
    				<div class="div3"> div3
    					<div class="div4">
    						div4
    					</div>
    				</div>
    			</div>
    		</div>
    
    var div1=document.querySelector(".div1");
    			var div2=document.querySelector(".div2");
    			var div3=document.querySelector(".div3");
    			var div4=document.querySelector(".div4");
    			
    			div1.onclick=function(){
    				console.log("div1 click")
    			}
    			div2.onclick=function(){
    				console.log("div2 click")
    			}
    			div3.onclick=function(){
    				console.log("div3 click")
    			}
    			div4.onclick=function(){
    				console.log("div4 click")
    			}
    //div4 click div3 click div2 click div1 click,如果<body> <html><document>设置了js代码，也会按照子-父-父。。。顺序执行
    ```

  - 捕获：从`document`开始触发，一直到具体的子标签

    ```javascript
    div1.addEventListener("click" , function(){
    				console.log("div1 click");
    			},true)
    			div2.addEventListener("click" , function(){
    				console.log("div2 click");
    			},true)
    			div3.addEventListener("click" , function(){
    				console.log("div3 click");
    			},true)
    			div4.addEventListener("click" , function(){
    				console.log("div4 click");
    			},true)
    //div1 click div2 click div3 click div4 click,如果<body> <html><document>设置了js代码，也会按照父-子-子。。。顺序执行
    ```

    

### 事件执行阶段



#### 概念



- 当用户触发某个事件时，该事件的完整执行流程



#### 流程



- 第一阶段：先执行一次捕获，由父标签先触发（最顶层到`document`），一直到最底层的子标签触发
- 第二阶段：事件目标阶段，真正用户要触发的子标签进行触发
- 第三阶段：执行一次冒泡，由具体子标签到父标签依次执行
- 注意：第二阶段实际上是第一阶段的末尾和第三阶段的开始划分到第二阶段，第二阶段不会单独再触发一次事件
- 实际事件处理只会在捕获或冒泡中二选一
  - 普遍用的最多的是冒泡



### 事件处理程序



#### 概念



- 当触发某个事件时要执行的程序（即代码）分为DOM0和DOM2两种方式

  

#### DOM0



```javascript
//1
标签变量名.on事件名=function(){
  
}

//2
<div on事件名=“要执行的代码”></div> 
```

- DOM0只能在第三阶段处理，及冒泡阶段



#### DOM2



```javascript
标签变量名.addEventListener("事件名","function(){}",true);

//删除事件处理程序
标签变量名.removeEventListener("事件名","function(){}",true);

div1.addEventListener("click", handle, true);

			function handle() {
				console.log("div1 click");
			}
			div1.removeEventListener("click", handle, true);
```

- `true`:捕获阶段处理
- `false`：冒泡阶段处理，默认
- 如果要删除事件处理程序，必须保证三个参数与添加时一致，第二个参数必须是一个函数名，而不是具体的`function`

- 区别
  - DOM2可以选择在冒泡或捕获阶段处理，而DOM0只能在冒泡阶段
  - DOM2在IE9以上支持，DOM0无限制



## event对象



### 概念



- Javascript为了能够处理事件的相关代码时能够获取该事件的相关信息，Javascript会触发该事件时创建一个`event`对象并收集该事件的相关信息，该`event`对象会作为事件处理函数的实际参数。所以我们在写事件处理代码时需要定义形式参数来接收
- 接收`event`对象后可以使用`event`对象里包含的相关内容，如事件触发标签，事件类型名， 甚至冒泡行为，获取鼠标触发事件时鼠标所在位置等



### 获取event对象



```javascript
var div=document.querySelector("div");
			div.addEventListener("click",function(e){
				//e为此事件的对象
				console.log(e);
			})
```

- 每次触发会新建`event`对象



### 常用属性和API



- `target`: 真正触发事件的具体标签，如冒泡程序中只会返回真正触发的那个标签

  ```javascript
  var div=document.querySelector("div");
  			div.addEventListener("click",function(e){
          e.stopPropagation();//取消父标签的冒泡
  				//e为此事件的对象
  				console.log(e.target,e.currentTarget,e.type，e.clientX,e.clientY);//div,div,click，122，58
  			})
  ```

  

- `currentTarget`:当前正在处理的事件标签，因冒泡或捕获实际标签会不同

  ```javascript
  document.body.addEventListener("click",function(event){
  				console.log(event.target,event.currentTarget,event.type，e.clientX,e.clientY);//div,body.click，122，58
  			})
  ```

  

- `stopPropagation()`:取消**进一步**冒泡，设置后设置的标签之上的父标签不会触发冒泡

- `preventDefault()`:取消事件的默认行为

  - 如`a`标签点击后默认为跳转，设置该函数后点击就不会跳转

  - 或者表单里的按钮，设置该函数后就不具有表单提交功能

    ```javascript
    <form action="success">
    			username:<input type="text">
    			username:<input type="text"> 
    			<button>login</button>
    		</form>
    
    document.querySelector("button").addEventListener("click",function(e){
    				e.preventDefault();//点击button不会提交表单
    			})
    
    <a href="http://www.baidu.com">baidu</a>
    document.querySelector("a").addEventListener("click",function(e){
    				e.preventDefault();//点击链接不会跳转
    			})
    ```

    

- `type`:事件的类型名，`click`，`dblclick`。。。

- `clientX&clientY`:触发当前事件时，鼠标在当前窗口的下标，屏幕左上角为原点

- `pageX&pageY`:触发当前事件时，鼠标在html页面的下标，以屏幕左上角为原点，如果页面无滚动条，与`clientX&clientY`一样，如有滚动条，则`clientX&clientY`:的当前窗口可能为滚动后的当前窗口，所以二者坐标可能不同



### 事件委托



#### 背景



- 我们给多个标签设置事件处理程序时，相关代码会很多，特别是针对有规律的事件，代码会显得繁琐。针对代码繁琐问题，我们可以用事件委托来解决

  

#### 概念



- 事件委托，又叫事件代理，是指利用事件执行中的冒泡机制配合event对象来达到减少事件处理代码量的一种编程技巧



#### 作用



- 减少事件处理程序代码量



#### 语法（流程）



- 给需要设置点击事件的标签的父标签或祖先标签设置事件处理程序。
- 利用`event.Target`来判断事件的具体子标签，然后针对子标签来执行相应代码

```javascript
<body>
		<div class="box1">box1</div>
		<div class="box2">box2</div>
		<script>
			
			document.body.addEventListener("click",function(e){
				var classname=e.target.getAttribute("class");
				if(classname=="box1"){
					console.log("div1 click");
				}else if(classname=="box2"){
					console.log("div2 click");
				}
			})
		</script>
	</body> 
```





### 扩展



- `submit`:提交表单

- `reset`：重制表单

  ```javascript
  <form action="success">
  			username:<input type="text">
  			username:<input type="text"> 
  			<button>login</button>
  		</form>
  
  var form=document.querySelector("form");
  			form.submit();
  			form.reset();
  ```

  

## jQuery



### 背景



- javascript原生DOM不方便
  - 单词太多，API太多不好记
  - 设置事件不方便，代码量量大
  - 调用繁琐



### 基础概念



#### 概念



- jQuery是第三方的函数库，本质上是一个js文件，内部已经写好了大量的函数用于进行的快捷的DOM操作。write less do more



#### 版本



- 目前国内用的比较多的是3.5.1及能够支持IE8的1.11.1版本
- 从2.x版本就不再支持IE8



#### 引入jQuery



- 通过`<script src="文件路径"></script>`引入

- 先引入，后使用

  ```javascript
  <body>
  		
  		<script src="jquery-3.6.1.js"></script>
  		<script>
  			//jquery code
  		</script>
  ```

  

#### 使用流程



-  页面已经引入了jQuery
- 利用jQuery选择器找到需要操作的HTML标签
- 通过jQuery提供的函数完成DOM（页面上所有操作：标签的增删改查，设置css，事件等）操作
- 注意：
  - 如果页面使用了jQuery，用jQuery操作的标签不能再使用原生DOM API，如`innerHTML`，`appendChild`，`parentElement`等.如果要用，必须完成jQuery标签和原生DOM标签的转换



### 获取标签及和原生DOM标签的切换



#### 通过jQuery获取页面上标签



```javascript
$("css选择器");

<body>
		<div id="box">
			<div class="item">1</div>
			<div class="item">2</div>
			<div class="item">3</div>
			<div class="item">4</div>
			<div class="item">5</div>
		</div>
		<script src="jquery-3.6.1.js"></script>
		<script>
			var $box=$("#box");
			var $div=$("div");
		</script>
	</body>
```

- 通过css选择器去寻找匹配到的HTML标签，会根据返回的个数自动判断是返回一个元素或一个数组

  

#### jQuery标签和DOM标签切换



- jQuery转DOM

  ```javascript
  var 标签变量名=jQuery标签变量名.get(0);
  
  var $box=$("#box");
  var box=$box.get(0);
  ```

  

- 原生DOM转jQuery

  ```javascript
  var jQuery标签变量名=$(原生DOM标签变量名);
  
  var box=document.querySelector("#box");
  			var $box=$(box);
  			console.log($box);
  ```

  

#### 内容，属性操作



- 内容相关

  

  - `html()`：类似于原生DOM的`innerHtml`，用于获取某个标签内部的HTML代码

  - `text()`：类似于原生DOM的`innerText`，获取标签的内部文本

  - `val()`：类似于原生DOM的`value`，主要获取表单元素的内容

    ```javascript
    <div>
    			<p>
    				this is label p in div
    			</p>
    		</div>
    		<input type="text" value="123">
    		
    		<script src="jquery-3.6.1.js"></script>
    		<script>
    			
    		var $div=$("div");
    		var $html=$div.html();//获取
    	  var $text=$("p").text("this is a new text");//获取+设置
    		var $value=$("input").val("456");//获取+设置
    		console.log($html);
    		console.log($text);
    		console.log($value);
    ```
    
    
    
  
- 属性相关

  

  - `attr()`：获取或设置HTML的某个属性
  
  - `prop()`：获取或设置HTML的某个属性
  
    - 区别：`prop()`适用于标签的内置属性，`attr()`适用于用户自定义属性
  
  - `removeProp`:删除标签的某个属性
  
  - `removeAttr`：删除标签的某个属性
  
  - `addClass()`：给某个标签添加一个class
  
  - `removeClass()`：删除某个标签的指定class
  
    ```javascript
    <div class="box">
    			<p>
    				this is label p in div
    			</p>
    		</div>
    		<input type="text" value="123">
    		<input type="radio" name="gender" checked>male
    		<input type="radio" name="gender" >female
    <script>
    			
    		/* var $div=$("div");
    		var $html=$div.html();//获取
    		var $text=$("p").text("this is a new text");//设置
    		var $value=$("input").val("456");//设置
    		console.log($html);
    		console.log($text);
    		console.log($value); */
    		var value1=$("input").attr("value",456);//获取标签属性并设置
    		var value2=$("input").prop("value");//获取标签属性
    		var div=$("div");
    		div.addClass("item");
    		div.removeClass("box");
    		console.log(value1);
    		console.log(value2);
    		console.log(div); 
    		var gender=$("[name=gender]");
    		console.log(gender);
    		var value3= gender.attr("checked");
    		var value4=gender.prop("checked");
    		console.log(value3);
    		console.log(value4);
    ```
  
    

#### 修改css



- `css()`

  ```javascript
  //设置语法：
  jquery标签变量名.css("css属性名"，“css属性值”)；
  
  jquery标签变量名.css({
    "css属性名1":“css属性值1”,
    "css属性名2":“css属性值2”,
    ...
  })；//批量设置
  
  var $box=$(".box");
  		$box.css("background-color","aqua");
  
  $box.css({
  			"background-color":"aqua",
  			"border":"1px solid red",
  			});//批量设置
  
  var cssbox=$box.css("background-color");
  		console.log(cssbox);//获取css值
  ```



#### 添加，删除



- 添加相关

  

  - `append()`： 类似于原生`appendChild`,在某个标签之后插入一个新标签,新标签会作为最后一个子标签

  - `before()`：在某个标签之前插入一个新标签，新标签是前一个兄弟标签

  - `after()`：在某个标签之后插入一个新标签，新标签是后一个兄弟标签

    ```javascript
    jquery变量名.append("新标签html代码")；
    jquery变量名.before("新标签html代码")；
    jquery变量名.after("新标签html代码")；
    
    <div class="box">
    			<p id="p1">
    				this is label p in div
    			</p>
    		</div>
    
    var $div=$("div");
    		$div.append(`<p>
    				it is a new label p in div
    			</p>`);
    		var $p=$("#p1");
    		$p.before(`this is a new first brother label`);
    		$p.after(`this is a new  last brother label`);
    ```
    
    

- 删除相关

  

  - `remove()`：删除找到的所有标签，如果找到多个标签，每个标签都会被删除
  
    ```javascript
    jquery变量名.remove()；
    
    $p.remove();
    ```
  
    

- 展示隐藏

  - `show()`：展示所选标签

  - `hide()`：隐藏所选标签

    ```javascript
    jquery变量名.show()；
    jquery变量名.hide()；
    ```

    

#### 获取子标签，兄弟，父标签及遍历



- 获取子标签

  

  - `children()`:获取某个标签的所有直接子标签

  - `find(css选择器)`：根据css选择器获取某个标签的所有满足条件的后代标签

    ```javascript
    var divchild=$div.children();
    		var find=$div.find();
    ```
    
    

- 获取兄弟标签

  - `prev()`

  - `next()`

    ```javascript
    var prev=$div.prev();
    		var next=$div.next();
    ```

    

- 获取父标签

  - `parent()`:获取某个标签的直接父标签

  - `parents(css选择器)`：获取某个标签的某个祖先标签，具体通过css选择器来指代

    ```javascript
    var parent=$div.parent();
    		var parents=$div.parents(`html`);
    ```

    

- 遍历

  - `first()`：获取遍历标签中的第一个

    ```javascript
    var $inputs=$("input");
    $inputs.first();
    ```

    

  - `last()`：获取遍历标签中的最后一个

    ```javascript
    var $inputs=$("input");
    $inputs.last();
    ```

    

  - `each()`：用于对jquery标签的快捷遍历

    ```javascript
    var $inputs=$("input");
    $inputs.each(function(index){
    			console.log(index,this);
    		})
    ```

    

  - `eq(i)`:获取找到标签中指定下标的标签，即第i个jquery标签

    ```javascript
    var $inputs=$("input");
    
    console.log($inputs.eq(1));//遍历的第二个input标签
    
    ```

    

#### 全部API

- https://jquery.cuishifeng.cn



#### 事件（on-默认使用事件委托）



- `on`

  ```javascript
  $父标签变量名.on("事件名"，'要执行事件的标签css选择器'，function(e){
    //触发事件要执行的代码
  })
  
  <body>
  		<div class="box">
  
  $("body").on("click",".box",function(e){
  			console.log("onclick");
  		})
  
  $(".box").click(function(e){
  			console.log($(this));
  		})//快捷方式，不支持动态添加的标签
  ```

  - 支持同时给多个标签设置

  - 支持javascript动态添加的标签

    

- 快捷方式
  - `dbclick`
  - `mouseenter`
  - `hover`
  - ...

### 动画



#### 内置动画



- 淡入淡出

  - `fadeIn()`

  - `fadeOut()`

    

- 下拉上滑

  - `slideDown()`，如果以设置高度，则无法展现效果，需要等`sildeUp`收起后高度无后，才可以触发
  - `slideUp()`

```javascript
jquery变量名.slideDown(动画毫秒时间);
jquery变量名.slideUp(动画毫秒时间);
```

- 如果对一个标签书写多个动画，按照动画代码依次执行



#### 自定义动画



- `animate()`：用户自定义动画

  ```javascript
  jquery变量名.animate({
    "css属性名1"："css属性值1"，
     "css属性名2"："css属性值2"，
     "css属性名3"："css属性值3"，
      "css属性名n"："css属性值n"}，动画时间毫秒)
  
  function diy(){
  				$("div").animate({
  					"width":"300px",
  					"height":"300px",
  				},2000);
          $("div").animate({
  					"margin-left":"300px",
  				},2000);
  }//先变宽高，后移动位置
  ```

  - `animate`基本只支持跟位置和尺寸相关的动画，其他的基本都不支持
  - 如果要颜色的动画，可以使用CSS3，用Javascript来切换class达到控制动画目的

  

#### 动画结束后执行js代码



- jquery每个动画函数都可以支持额外的参数，该参数必须是一个函数，用于表示在动画结束后要执行的代码

  ```javascript
  jquery函数名.动画函数名(其他参数，function(){
                  //动画结束后要执行的代码
                  })
  
  $("div").fadeIn(2000,function(){
    $(this).text("123");
  })
  
  $("div").animate({
  					"width":"300px",
  					"height":"300px"
  				},2000,function(){
  					$(this).css("background-color","blue");
  				})
  ```

  

### 链式调用



#### 背景



- 如果需要对同一个标签执行多句jquery代码，会导致不断的获取jquery标签，代码量过大过多

  

#### 概念



- 概念：对同一个标签的多代码，可以整合成一句

- 代码整齐，减少一定代码量

- 语法：

  ```javascript
  jquery变量名.函数名1().函数名2().函数名3();
  
  $("div").css("width","300px").animate({"margin-left":"300px"},1000).text("123");
  ```

  - 以上每个函数都是接着前一个函数的执行结果继续执行

  - 如果某个函数本身就是返回某个文字，后续就不能再使用链式调用

    ```javascript
    $("div").css("width","300px").animate({"margin-left":"300px"},1000).text();
    //text()为获取内容，后面就不能再继续使用，如果是设置类型函数则可以
    ```

    

## Javascript内置对象



### String



- `charAt`:获取字符串中指定下标的字符

  ```javascript
  var str="hello world";
  			str.charAt(6)//w
  ```

  

- `charCodeAt`：获取字符串中指定下标的ASCII码

  ```javascript
  var str="hello world";
  		
  			console.log(str.charCodeAt(6));//119
  ```

  

- `concat`：多个字符串拼接一个新字符串

  ```javascript
  var str="hello";
  			var str1="world";
  console.log(str.concat(str1));//helloworld
  ```

  

- `indexOf`:某个字符或字符串在指定字符串第一次出现的下标，没有的话返回-1

  ```javascript
  var str="hello";
  console.log(str.indexOf("ll"));//2
  console.log(str.indexOf("ll2"));//-1
  
  var str="1233485894949fjfjk3gkgk";
  			console.log(str.indexOf("3",4));//第二个参数是从此下标开始检索，默认不写为0，即从第一位开始检索
  ```

  

- `replace`:将字符串中某个字符串替换成另一个字符，返回一个新字符串，对原字符串无影响

  - 只替换第一个匹配的字符串，全局替换使用`replaceAll`

  ```javascript
  var str="hello";
  var newstr=str.replace("l","n");
  			console.log(newstr);//henlo
  ```

  

- `slice`:获取字符串中的一部分，截取字符串，不包含结束下标

  ```javascript
  字符串.slice(开始下标，结束下标)
  
  var str="hello";
  var newstr=str.slice(1,3);
  			console.log(newstr);//el
  ```

  

- `split`：按照指定的符号对字符串进行分割，将分割后的字符串全部放入到一个数组中，返回该新数组

  - 分隔符必须传，无默认分隔符，如果无分隔符，直接返回一个数据的数组

  ```javascript
  字符串.split("分隔符");
  
  var str="hello";
  var arr=str.split("l");
  			console.log(arr);//["he", "", "o"]
  
  var str="zhangsan&lisi&wangwu";
  var arr=str.split("&");
  			console.log(arr);//["zhangsan", "lisi", "wangwu"]
  ```

  

- `substr`：截取字符串

  ```javascript
  字符串.substr(子字符串开始下标,截取长度)//截取长度：字符串数量
  
  ```

- `subString`:截取字符串

  ```javascript
  字符串.substring(子字符串开始下标,字符串结束下标)//不包含结束下标
  ```

  

- `toLowerCase`:获取指定字符串的全小写格式的字符串，原字符串无影响

  ```javascript
  var str="HeLLo";
  var str1=str.toLowerCase();
  			console.log(str1);//hello
  ```

  

- `toUpperCase`：获取指定字符串的全大写格式的字符串，原字符串无影响

  ```javascript
  var str1=str.toUpperCase();
  			console.log(str1);//HELLO
  ```

  

- `startsWith`:判断某个字符串是否以指定字符串开头

  - 区分大小写

  ```javascript
  var str="HeLLo";
  
  console.log(str.startsWith("He"));//true
  console.log(str.startsWith("he"));//false
  ```

  

- `endsWith`：判断某个字符串是否以指定字符串结尾

  ```javascript
  console.log(str.endsWith("0"));//false
  ```

  

- `trim`:去除字符串两端空格，返回新字符串，对原字符串无影响

  ```javascript
  var str=" HeLLo";
  console.log(str.trim());//HeLLo
  ```

  

- `match`



## 正则表达式



### 概念



#### 背景



- 当需要对各种数据（用户名，邮箱，密码，手机号）进行验证时，为了验证用户输入是否合法，会写大量代码处理，这样导致代码量过大，需要一个更好的数据验证方案-正则表达式



#### 概念



- 正则表达式本质上一个特殊的字符串，它是按照一定格式书写，能够用来对其他字符串进行判断验证，可以用来判断某个字符串是否符合我们的条件，这种字符串就是一个正则表达式

  

- 正则表达式需要我们学习语法编写字符串，用javascript提供的api用来对其它字符串进行判断，判断是否满足正则表达式的条件

  

### 语法



#### 使用



```javascript
var 正则表达式变量名=/正则表达式/;
正则表达式变量名.test(待判断的字符串)；

//判断字符串是否是一个数字
var str="a";
var reg=/[0-9]/;
reg.test(str);//false
```

- 书写正则表达式后，可以用javascript提供的`test()`来判断某个字符串是否满足正则表达式，`test()`放回布尔型数据，`true`表示满足，`false`表示不满足



#### 使用流程



1.先根据验证要求写出对应的正则表达式

2.再利用`正则表达式.test(要验证的数据)`来进行判断



#### 注意点



- 正则表达式是从左往右按照顺序来判断，即也会判断字符串的书写顺序



#### 基础语法



- `[0-9]`：表示匹配一个数字
- `[a-z]`：表示匹配小写字母
- `[A-Z]`：表示匹配大写字母
  - `[123abc]`：表示匹配一次123abc 6个字符中的其中一个
  - `[a-zA-Z]`：表示匹配全部字母
  - `[0-9a-zA-Z]`：表示匹配一个数字或字母
- `{m,n}`：表示匹配前一项的次数，至少m次，最多n次。最多的话需要时在匹配整个字符串的时候才有效，m和n必须符合字符串中**连续**出现匹配字符串的次数，可以在开头，中间和结尾
  - 匹配5个数字：`[0-9]{5}`
  - 匹配至少5个数字：`[0-9]{5,}`
  - 匹配最多5个数字：`[0-9]{,5}`
  - 匹配最少2个，最多5个数字：`[0-9]{2,5}`

- `^`：表示从开头开始匹配
  - 数字开头：`^[0-9]`
  - 字母开头：`^[a-zA-Z]`

- `$`：表示匹配以什么结束
  - 数字结尾：`[0-9]$`
  - 三个字母结束：`[a-zA-Z]{3}$`
  - 至少2个数字结尾：`[0-9]{2,}$`

- `/^$/`：表示匹配整个字符串
  - 18位数字：`^[0-9]{18}$`
  - james bond：`^james bond$`

- `(a|b|c)`：包含匹配abc中的一个
- `(a|b)bc`：包含匹配abc或bbc中的一种
- `james bond`:是否完整包含james bond



### 高级语法



#### 语法扩展



- `\d`：表示匹配一个数字，等同于`[0-9]`
  - 匹配手机号：`^1[3-9]\d{9}$`
  - 匹配5-10个数字：`\d{5,10}`
  - 匹配身份证：`^\d{15}|\d{18}$`
- `\w`：表示匹配一个单词字符，等同于`[0-9a-zA-Z_]`
  - 匹配10个字母或数字或_:`\w{10}`
  - 匹配5到9个单词字符：`\w{5,9}`
- `*`：表示匹配前一项出现的次数为0次，1次，无数次，即可有可无,等同于`{0,}`
  - 匹配任意数量的字母：`[a-zA-Z]*`
  - 匹配任意数量的数字：`\d*`
- `+`匹配前一项出现的次数至少1次，等同于`{1,}`
  - 匹配至少一个数字：`\d+`
- `?`:匹配前一项1次或0次
  - 匹配一个数字后可以跟一个字母或无：`\d{1}[a-zA-Z]?`

- 匹配+或？或*需要转译：符号前加`\`
  - 匹配一个数字+一个数字：`[0-9]/+[0-9]`



#### 正则表达式模式



- 不同正则表达式模式对于正则表达式有不同作用，默认模式为`u`
- 常用模式
  - `u`：只匹配最近的一项
  - `i`：不考虑大小写
  - `g`：全局匹配

- 指定模式

  ```javascript
  var 正则表达式=/正则表达式/模式
  
  var str="we are family";
  			var newstr=str.replace(/ /g,"-");
  			console.log(newstr);
  ```

  

#### 正则表达式在字符串中应用



- 字符串中的部分API支持正则表达式

  

  - `match`:判断某个字符串是否符合某个正则表达式,返回正则表达式匹配的字符串是一个对象，但可以通过下标的方式来获取

    - 想要返回全部匹配结果，正则表达式变为全局模式

    ```javascript
    字符串.match(正则表达式);
    
    var str="dhddkdkd15811285042fdjksljfdsk";
    			var reg=/1[3-9]\d{9}/;
    			var phone=str.match(reg);
    			console.log(phone[0]);//15811285042
    
    var str="dhddkdkd15811285042fdjksl18618180537jfdsk";
    			var reg=/1[3-9]\d{9}/g;
    			var phone=str.match(reg);
    			console.log(phone);[15811285042,18618180537]
    
    var str="张三 james bond 李四 mary 王武 tony 赵六 jobs";
    			var reg=/\w+[ ]*\w+/g;
    			var arr=str.match(reg);
    			console.log(arr);
    ```

    

  - `split`：支持以正则表达式作为分隔符

    ```javascript
    var str="张三@李四$王武#赵六@@@田七&&王八";
    			var reg=/[@$#&]+/;
    			var arr=str.split(reg);
    			console.log(arr);
    
    var str="?name=zhangsan&age=12";
    			var reg=/[&]+/;
    			var newstr=str.slice(1);
    			var arr=newstr.split(reg);
    			console.log(arr);
    ```

    

  - `replace`

    ```javascript
    var str="we are family";
    			var newstr=str.replace(/ /g,"-");
    			console.log(newstr);
    ```

    

## 原生对象



### 基本概念



#### 背景

- 如何描述学生或商品等复合型数据，每个学生有姓名，年龄，性别等数据，如果用一维数组方式访问很不方便，需要原生对象来进行描述这种复合型数据

  

#### 概念

- Javascript专属的一种专门用于表示复合型数据的一个数据结构，是以属性的方式来表示复合型数据的某个数据，容易理解，数据统一管理

  

### 原生对象基本应用



#### 定义对象

```javascript
var 对象变量名 = {};//定义一个空的原生对象
var 对象变量名={
  属性名1：属性值1,
   属性名2：属性值2,
   属性名n：属性值n
  
}//定一个带有数据的原生对象

var students={
				name:"zhangsan",
				age:12,
				gender:"male"
			}
```



#### 获取或设置对象中的属性

```javascript
//获取：
对象名.属性名;
//设置：
对象名.属性名=新数据;

var name=student.name;
			student.name="lisi";
			student.age=18;
```

- 当属性为变量时，获取方式为`对象名[属性名]`;

  ```javascript
  data={
    [searchtype]:searchvalue
  }
  ```

  

### 对象数组



#### 定义和使用

- 一个数组中的每个数据都是一个原生对象

  ```javascript
  var arr=[对象1,对象2,对象3...对象n];
  
  var latiao = {
  				price: 12,
  				storage: 1000,
  				sale: 20
  			}
  			var tesla = {
  				price: 210000,
  				storage: 100,
  				sale: 30
  			}
  			var pants = {
  				price: 300,
  				storage: 100,
  				sale: 1
  			}
        
     var arr = [latiao, tesla, pants];
  ```

  

- 使用：通过下标来使用

  ```javascript
  arr[0].price=200;
  ```

  

#### 应用：完成商品的排序

```javascript
var arr = [latiao, tesla, pants];

			arr.sort(function(latiao, tesla) {
				return tesla.sale - latiao.sale;
			});
			console.log(arr);
```



## canvas



### 基础概念



#### canvas绘图技术



- 概念：因为Javascript在HTML5之前缺乏实现复杂动画和几何图形的绘制技术，在HTML5版本新增了canvas绘图技术
- canvas绘图技术利用HTML5提供的`<canvas>`标签作为画布，利用Javascript配套的API来实现绘制几何图形，绘制图形配合Javascript定时器实现复杂动画



#### 画布



- 页面上可以使用`<canvas>`来充当画布的角色，对于页面canvas就是一个普通的块级标签，canvas标签本身提供了`width`和`height`属性来设置画布大小

- 不要用css设置尺寸

  ```javascript
  <canvas width="1000" height="300"></canvas>
  ```

  

#### 画笔



- Javascript会针对每个画布都会提供一个专属的画笔，在程序中，会作为一个对象存在，该对象提供了一系列的API用于进行绘制操作，该画笔原生提供，不能用jQuery操作

  ```javascript
  // 获取画笔
  // 1获取画布
  var canvas=document.querySelector("css选择器")；
  var 画笔变量名=canvas.getContext("2d");
  //通过画笔进行绘制
  画笔变量名.函数名();
  
  <canvas width="1000" height="300" id="demo"></canvas>
  
  var canvas=document.querySelector("#demo");
  			var crayon=canvas.getContext("2d");
  			crayon.函数名();
  ```

  

#### canvas绘图技术一般流程



1 在页面上设置画布：`<canvas></canvas>`

2 在Javascript中获取画笔

3 利用画笔提供的API来进行绘图操作，画笔获取一次即可重复使用

   3-1:调用`beginPath()`开启绘制路径

   3-2:调用 `moveTo()`确定画笔的绘制位置

   3-3:调用`lineTo()`勾勒子路径

   3-4:调用`closePath()`闭合子路径

   3-5:调用`stroke()`绘制路径，显示在页面上



#### canvas中的坐标系



- 以画布左上角为原点，向右x轴为正，向下y轴为正



#### canvas路径



- 路径：一条闭合的线条，一般一个路径是由几条子路径构成
- 子路径：一个具体的线条，几条子路径连接起来闭合形成完整路径
- canvas是通过`beginPath()`来表示开始绘制的新路径，`cLosePath()`会将目前已绘制的子路径进行闭合，形成一条完整的路径。即会在`beginPath()`和`cLosePath()`之间绘制子路径。当绘制完最后一条子路径后，调用`cLosePath()`会自动将第一条子路径的起点和最后一条子路径的终点进行连接形成一条完整的路径



### 绘图操作



#### API：

- https://www.w3cschool.cn/html5/q2ybmfle.html



#### 基本操作



- `beginPath()`：开启绘制一条路径
- `closePath()`：关闭当前绘制的路径，会将该条路径进行闭合



#### 绘制几何图形-线条相关



- `moveTo(x,y)`：将画笔移动到指定坐标

- `lineTo(x,y)`：勾勒一条直线（子路径），直线的起点是画笔的位置，终点是指定的x和y坐标。如果需要显示该条子路径，需要调用`stroke()`来进行真正的绘制子路径

- `stroke()`：绘制当前已经勾勒出的子路径

- `strokeStyle`：设置线条颜色

- `lineWidth`：线条宽度

- `fill()`：对图形进行填充

- `fillStyle`：设置填充颜色

  ```javascript
  画笔变量名.strokeStyle="颜色";
  画笔变量名.lineWidth="5";
  画笔变量名.fill();
  画笔变量名.fillStyle="颜色";
  
  crayon.strokeStyle="red";
  crayon.lineWidth=5;
  crayon.fillStyle="blue";
  crayon.fill();//先设置填充颜色，再设置是否填充
  ```

  

  ```javascript
  var canvas=document.querySelector("#demo");
  			var crayon=canvas.getContext("2d");
  			crayon.beginPath();
  			crayon.moveTo(0,0);
  			crayon.lineTo(0,44);
  			crayon.lineTo(33,55);
  			crayon.closePath();
  			crayon.stroke();
  ```

  

#### 绘制集合图形-曲线



- `arc`：勾勒一段曲线

  ```javascript
  画笔变量名.arc(圆心坐标x,圆心坐标y,半径,开始角度，结束角度，是否逆时针);//默认顺时针
  
  crayon.beginPath();
  			crayon.arc(100,100,100,0,2*Math.PI);
  			crayon.lineWidth=5;
  			crayon.strokeStyle="blue";
  			crayon.fillStyle="red";
  			crayon.fill();
  			crayon.stroke();
  			crayon.closePath();
  ```

  - canvas中，以`Math,PI`作为180度，90度为`Math.PI/2`，37度为`37*Math.PI/180`

    ```javascript
    //benz logo
    var canvas=document.querySelector("#demo");
    			var crayon=canvas.getContext("2d");
    			crayon.beginPath();
    			crayon.arc(100,100,50,0,2*Math.PI);
    			crayon.closePath();
    			crayon.stroke();
    			crayon.moveTo(100,100);
    			crayon.lineTo(100,50);
    			crayon.closePath();
    			crayon.stroke();
    			crayon.moveTo(100,100);
    			crayon.lineTo(140,130);
    			crayon.closePath();
    			crayon.stroke();
    			crayon.moveTo(100,100);
    			crayon.lineTo(60,130);
    			crayon.closePath();
    			crayon.stroke();
    ```

    

#### 其他API



- `clearRect`：清理画布中指定区域，即清理绘制痕迹

  ```javascript
  画笔变量名.clearRect(清理区域左上角x坐标，清理区域左上角y坐标，清理区域宽度，清理区域高度);
  
  crayon.clearRect(0,0,canvas.innerWidth,canvas.innerHeight)
  ```

  

### 练习



#### 思路

- 利用随机圆心生成小圆，然后利用定时器不断改变每个小圆点圆心位置，达到随机移动的目的。
- 再判断两个点圆心是否小于指定的一个数字，是就针对这两个点圆心来绘制线条。
- 给鼠标设置移动事件，保存鼠标移动的 x和y坐标，依此为圆心，指定一个半径。
- 判断所有点，是否在这个圆以内，如果是则以两个点为圆心为坐标生成线条



#### 随机点绘制

- 每个点状态需要保存。每个点需要使用一个原生对象保存，并把所有的点保存到数组中统一绘制



#### 随机点移动

- 随机移动的原理就是不断改变点的圆心位置

- 再利用定时器不断的绘制（清屏）

- 边界的判断：点移动范围不能超过边界

  

## 移动端



### 移动段开发概念



#### 移动端开发

- 区别于传统页面开发，移动端开发是指利用移动端设备的特性及css3提供的各种相对单位来实现移动端页面布局开发

- 移动设备是指便携的移动电子设备，包括手机，平板，小屏幕电脑等

  

#### 为什么不直接使用相应式布局

- 布局不匹配：pc端一般屏幕较大，可以显示更多的东西，而移动设备屏幕空间有限，只能显示部分内容
- 代码量太大：针对pc移动端会写不同版本的css代码



### 屏幕的基本概念



#### 屏幕的的尺寸-英寸

- 英寸是长度单位，1英寸约等于2.54厘米。
- 而手机中的英寸是指手机屏幕对角线长度为多少英寸。如iPhone6屏幕尺寸是4.7英寸，指iPhone6的屏幕对角线长度为4.7英寸
- http://uiiiuiii.com/screen



#### 像素

- 指屏幕上最小的方块，每个方块可以存放一种颜色。无数个像素的结合就可以形成图像
- 平时所说的分辨率指屏幕上有多少个方块（像素）



#### 设备物理像素（手机分辨率）

- iPhone6物理分辨率750*1334指的是屏幕水平方向有750个发光点，每个发光点可以作为一个像素，垂直方向有1334个发光点
- 设备物理像素是固定的



#### 设备独立像素（pc上称为逻辑像素）-dp

- 为了保证无论手机物理分辨率有大，为了保证页面效果得到统一展示，每个手机都有自己的设备独立像素，无论哪个手机每一个独立像素可以认为可以认为是一个css像素
- 每个手机的设备独立像素多少是不一样的，iPhone6，7，8独立像素都是375*667，iPhone12 pro是390*844
- 绝大多数手机独立像素宽：360 375 390 411 414
- 设备独立像素就是移动端页面所参考的100%宽度



#### dpi

- 设备独立像素比：子手机的独立像素和物理分辨率的比值，每个手机的dpi是固定的，比如iPhone12 pro max独立像素是428，物理分辨率是1284*2778，dpi就是3.0



### 视口（viewport）



- 布局视口

  - 因为手机一般屏幕较小，分辨率不同，为了能够正常显示所有的页面，包括pc端，所以移动端针对浏览器页面有个默认的页面宽度，大多数手机浏览器页面默认宽度为980px，有的是1024px。我们称默认的移动端浏览器页面展示模式为布局视口（layout viewport）

    

- 视觉视口（visual viewport）

  - 布局视口是为了正常显示pc端页面而做的调整，但对于屏幕本身是无法获取屏幕本身宽度来作为页面布局。而视觉视口是指以当前屏幕的宽度作为布局方式

  - 不同的dpi导致相同px页面在不同的手机下会有空隙或滚动条等

    

- 理想视口（ideal viewport）

  - 无论什么品牌手机，或那种分辨率，应当同样宽度的页面再不同手机上都会呈现一样的效果

  - 每个手机的理想视口是以设备自己的独立像素作为自己页面的100%宽度，一个css像素在每个手机上的效果都是一模一样的

  - 处于理想视口模式下，同样的页面内容在不同的手机上效果是一致的，唯一需要兼容处理的是每个手机的设备独立像素不一样

    - 绝大多数手机独立像素宽：**360 375 390 411 414 768 （pad）1024（pad）**

  - 开启理想视口模式

    ```html
     <meta name="viewport"content="width=device-width,initial-scale=1.0 user-scalable=no"> 
    ```

    - `<meta>`是在`<head>`中用于完成页面配置的标签，可以配置不同的设置，比如字符编码，设置移动端视口模式等
      - `name`：设置的配置项名称，如`name="viewport"`表示设置移动端是口模式，`name="keywords"`表示页面关键字
      - `content`：设置项的具体配置信息
      - `width=device-width`：页面宽度采取设备独立像素，即width：100%=设备的独立像素
      - `initial-scale=1.0`也是参考设备独立像素
      - `user-scalable`：是否允许用户缩放页面，取值为`yes`或`no`



### 移动端使用的像素单位



- em rem 

  - em：1em相当于父标签的`font-size`大小，如父标签的`font-size`为14px，那么1em等于14px，2em=28px

    - 父标签没有`font-size`，继续向上找`font-size`，如果主线标签都未设置，会参考浏览器的`font-size`。多数浏览器默认为16px

  - **rem**：指相对于`<html>`标签的`font-size`，不会被父标签`font-size`影响，即如果`<html>`标签的`font-size`为30px，那么页面上的所有后代标签1rem=30px

    

- vw vh(viewport-width viewport-height)

  - **vw**：css3提供的单位，1vw即视口宽度的1%，100vw是视口宽度100%

  - **vh**：css3提供的单位，1vh即视口高度的1%，100vh是视口高度100%

  - 理想视口情况下，视口宽度或高度就是浏览器的宽度及可视区域的高度

    

- px：绝对单位

  - 为了保证页面在不同手机下效果一致，需要使用理想视口



### 移动端布局技巧



#### 纲要

- 通过设置`<html>`不同的`font-size`及`rem`来进行屏幕布局及适配方案，对于一些特殊的位置，可以配合vw，vh来实现



#### 页面布局

- 必须采用理想视口
- 建议页面尺寸采用`rem`
- 对列表之类使用弹性布局（推荐）
- 文字也是使用`rem`来设置



#### 屏幕适配

- 主要适配以下独立像素（理想视口宽度）
  - 360，375，390，411，414，768，1024

- 适配方案：根据不同屏幕宽度来设置`<html>`不同的`font-size`
  - 使用媒体查询
  - 利用javascript动态检测屏幕宽度来计算得到合适的`font-size`



#### 关于图像

- 小图标尽量使用字体图标
- 背景图片可以设置`background-size`用rem
- `img`标签设置100%，父标签设置宽度



## HTML5应用



### 本地存储



#### 概念

- 一个程序需要保存用户或程序数据，一般用服务器进行保存。在前端部分如果想要保存数据在HTML5之前通过`cookie`技术保存，但安全性差，数据保存容量少，所以HTML5新增了本地存储可以实现本地存储大量数据
- HTML5新增了`localStorage`和`sessionStorage`及配套API来实现通过Javascript将数据保存至本地
- 根据保存时间不同分为`localStorage`和`sessionStorage`



#### localStorage

```java
// 保存数据
localStorage.setItem(`属性名`,`属性值`);
//读取数据
localStorage.getItem(`属性名`);
//删除某个数据
localStorage.removeItem(`属性名`);
//删除所有数据
localStorage.clear();

<body>
		<input type="text"> <button type="button" onclick="save()">save</button>
		<button onclick="show()">show</button>
		<button onclick="del()">delete</button>
		<script>
			
			function save(){
				var data=document.querySelector("input").value;
				localStorage.setItem(`input`,data);
			}
			function show(){
				alert(localStorage.getItem(`input`));
			}
			function del(){
				localStorage.removeItem(`input`);
			}
		</script>
	</body>
```

- `localStorage`保存的数据有效期是永久，即关闭浏览器重新打开依然可以使用



#### sessionStorage



- 功能与`localStorage`一样

  ```javascript
  // 保存数据
  sessionStorage.setItem(`属性名`,`属性值`);
  //读取数据
  sessionStorage.getItem(`属性名`);
  //删除某个数据
  sessionStorage.removeItem(`属性名`);
  //删除所有数据
  sessionStorage.clear();
  
  <body>
  		<input type="text"> <button type="button" onclick="save()">save</button>
  		<button onclick="show()">show</button>
  		<button onclick="del()">delete</button>
  		<script>
  			
  			function save(){
  				var data=document.querySelector("input").value;
  				sessionStorage.setItem(`input`,data);
  			}
  			function show(){
  				alert(sessionStorage.getItem(`input`));
  			}
  			function del(){
  				sessionStorage.removeItem(`input`);
  			}
  		</script>
  	</body>
  ```

  - 保存的时间是当前标签页关闭时



#### localStorage与sessionStorage区别



- `localStorage`保存数据时永久保存
- `sessionStorage`保存数据是临时的，标签页关闭会消失
- 无论为`localStorage`和`sessionStorage`都只能保存字符串数据



### 拖拽



#### 概念

- 是HTML5新增特性，HTML5增强了Javascript对于dom元素的操作，额外的提供了专属的时间以及配套API来实现拖拽操作



#### 流程

- 谁会被拖拽
  - 给被拖拽的HTML标签设置`draggable=true`
- 放置在那个哪个标签：作为放置标签
  - 给放置标签添加`dragover`事件，取消事件默认行为，以此来取消不可放置的限制
- 放置后完成什么操作
  - 给放置标签设置`drop`事件，当拖拽操作结束后会针对放置元素触发该事件

- 实现数据在事件之间传递

  ```javascript
  //1 在事件中保存数据
  event对象名.dataTransfer.setData("属性名","属性值");
  //2 在另一个事件中读取数据
  event对象名.dataTransfer.getData("属性名");//属性值
  
  function demo1(e){
    e.dataTransfer.setData("class","item1");
  }
  
  function demo2(e){
    var classname=e.dataTransfer.getData("class");
    console.log(classname);//item1
  }
  ```

  

#### 相应API

- `draggstart`：当拖拽操作发生时，拖拽元素会触发该事件
  - 一般在该事件中利用`e.dataTransfer.setData`保存拖拽元素的id或class，在发生放置事件设置事件（`drop`）的标签上利用`e.dataTransfer.getData`来获取保存的数据

- `offsetX&offsexY`：获取鼠标在某个标签中的偏移量，offsetX指的是鼠标和标签左边的距离，offsetY是鼠标和标签顶部距离

  ```javascript
  event对象名.offsetX或event对象名.offsetY；
  ```

  

## 数据交互



### 将对象或对象数组里的数据放在页面上



#### 流程

- 确定数据是数组还是单独对象
  - 如果是对象，直接新增标签，将对象中某些属性通过`${}`加入到标签内部的`innerHTML()`中
  - 再将新标签追加到想要的标签中
- 如果是对象数组，需要先对数组进行遍历，每次遍历取到的是一个对象，对每个遍历的对象进行同样操作
  - 如果是对象，直接新增标签，将对象中某些属性通过`${}`加入到标签内部的`innerHTML()`中
  - 再将新标签追加到想要的标签中



### 将网络上数据放在程序里，再放在页面上（使用流程）



#### 通过ajax技术获取网络数据

- 概念：ajax是javascript可以向服务器发送数据请求，并接收服务器返回的技术

- 语法：

  ```javascript
  $.ajax({
  					"url":"服务器网络地址，即获取数据的地址",
  					"success":function(data){
  						//当接收服务器数据时自动触发该函数
  						//返回的数据保存在data中，函数的内容就是对data进行处理，比如新建标签
  					}
  				})
  
  
  $.ajax({
  									"url":"https://",
  									"success":function(data){
                      console.log(data.goods)//获取的是一个数组
  										var arr=data.goods;
  										for(var i=0;i<arr.length;i++){
  											var good=arr[i];
  											showdata(good);
  										}
  									}
  								})
  ```

  - jQuery获取的是一个对象，所有的数据会作为对象的属性来存在

- 流程：
  - 根据网络地址利用ajax语法来获取数据
  - 在`success`里面对获取的数据进行操作



### 本地存储中的对象数据处理



#### 将对象转为指定字符串

```javascript
var str=JSON.stringify(对象名);//str就是该对象的字符串形式
```

- 本地存储只能存字符串，所以需要将对象转化为字符串



#### 将制定字符串转为对象

```javascript
var obj=JSON.parse(字符串);
```

- 转为对象的字符串必须是对象转为的字符串，一般字符串不可以







# Node.js



## 基础知识



### 服务器

- B/S架构：Browser（浏览器）/Server（服务器）
- C/S架构：Client（客户端）/Server（服务器）



### 网络协议

- 网络协议指计算机为了能够在网络中进行数据的交换，从而去建立一个规则标准



#### TCP/*IP协议*

- TCP/IP协议成为网络通讯协议，是互联网中最基本协议
- TCP/IP协*是一个协议组合，该协议下还包含很多小协议
  - HTTP（HTTPS）
  - TCP
  - IP
  - DNS
  - ...



#### 浏览器输入URL后发生什么



##### 1.域名解析

- 域名：通常所说的网址，如baidu.com
- 解析：通过DNS服务器将baidu.com解析为202.108.22.5的IP地址，并通过IP地址找到并访问服务器

##### 2.建立TCP连接

- TCP：传输控制协议，用于保证计算机之间数据传递完整和安全性

- 三次握手：TCP通过三次握手机制来保证数据传输完整和安全

  ![](/Users/mujiabin/Documents/HBuilderProjects/practise/nodejs/img/:Users:mujiabin:Documents:HBuilderProjects:practise:nodejs:Users:mujiabin:Downloads:20200829115116478.png)

##### 3.客户端发送请求，服务端处理请求

- TCP连接建立成功后，浏览器可以利用http协议向服务器发送请求
- 服务器收到请求后开始处理请求，处理完成后，服务器将处理结果返回给客户端

##### 4.关闭TCP连接

- 客户端接收到服务端发送的数据后需要通过TCP协议来断开与服务器的连接

- 四次挥手

  ![2020082912160196](/Users/mujiabin/Documents/HBuilderProjects/practise/nodejs/img/:Users:mujiabin:Documents:HBuilderProjects:practise:nodejs:Users:mujiabin:Downloads:20200829121601962.png)

##### 5.浏览器渲染页面

- 浏览器接收到服务器响应数据后，开始对数据进行解析并渲染



### 常用命令



- `cd`：进入某个目录（文件夹）
  - 后面可以跟路径
  - 后面可以跟子文件夹（该文件夹必须是**当前路径**下子路径）
  - `cd ..`：返回上一级目录

- `node`：运行Javascript文件，文件中不能运行DOM,BOM内置函数及API

  ```javascript
  mujiabin@mujiabindeMacBook-Air practise % cd nodejs   
  
  mujiabin@mujiabindeMacBook-Air nodejs % node nodejs01    



## Node.js



### 概念



- Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时。
  - JavaScript 运行时：Javascript代码运行环境
  - Chrome V8 引擎：Javascript引擎
    - 浏览器内核：渲染引擎和Javascript引擎
      - 渲染引擎负责解析编译HTML和CSS代码
      - Javascript引擎负责解析和编译Javascript代码

- Node.js让Javascript代码可以在服务端运行
- Node.js单线程，只处理请求，后将请求分配给不同的业务逻辑单元

![98c6bcbca8bc489888ddb3bdcf6c2484](/Users/mujiabin/Documents/HBuilderProjects/practise/nodejs/img/:Users:mujiabin:Downloads:98c6bcbca8bc489888ddb3bdcf6c2484.png)



### 模块化



- 每一个Javascript文件都是独立的模块，默认情况下模块之间是无关联的，即无法进行数据交换
  - 但是如果在前端（浏览器）不同Javascript文件被同一HTML文件同时引用，是可以关联的

- 以前模块化是后端概念，前端无模块化概念，从ES6开始，前端也引入模块化概念

  

  - 前端模块化
  
    
    
    - HTML引入Javascript文件，`type="module"`
    
    ```javascript
    <script src="nodejs01.js" type="module"></script>
    <script src="nodejstest.js" type="module"></script>
    ```
    
    
    
    - 引入Javascript变为HTML中引入一个入口Javascript文件，后在此Javascript文件中再引入多个Javascript
    
      ```javascript
      <script src="index.js" type="module" ></script>
      
      //index.js，js引入js：直接引入nodejs02，nodejs02可以运行，但不涉及与index.js的数据交互
      import "./nodejs02.js";//同级目录引入js文件需要加“./”
      ```
    
    
    
    - 暴露`export default`
    
      ```javascript
      //nodejs01.js
      
      function foo(){
        console.log(`hello`);
      }
      var a =1;
      export default {
      	  a:a,
        foo:foo
        }
      ```
    
      - 引入 `import`
    
      ```javascript
      //nodejs02.js
      
      import aobj from "./nodejs01.js";
      console.log(aobj.a);
      aobj.foo();
      ```
    
      
    
    - 暴露`export`
    
      ```javascript
      //nodejs01.js
      
      export var a=1;
        export function foo(){
      	  console.log(`hello`);
        }
        export let b=2;
      ```
    
      - 引入 `import`
    
        ```javascript
        //nodejs02.js
        
        import {a as aa,foo,b} from "./nodejs01.js";
        console.log(aa);
        foo();
        console.log(b);
        ```
    
    
    
  - 后端模块化
  
    - CommonJS
  
      - ECMAScript是一种规范，Javascript是这个规范的实现
      - CommonJS是一种规范，Nodejs是这个规范的实现
  
    - Javascript引入Javascript：`require`
  
      ```javascript
      //nodejs02引入nodejs01
      require("./nodejs01");
      console.log("node02js");
      ```
  
      
  
    - 暴露
  
      ```javascript
      var num=100;
        function foo(){
      	  console.log("hello");
        }
        console.log("node01js");
        /* module.exports.num=num;
        module.exports.foo=foo(); */
        module.exports={
      	  num,
      	  foo
        }
      ```
  
      
  
    - 引入
  
      ```javascript
      /* const bjs=require("./nodejs01"); */
      const{num:number,foo}=require("./nodejs01");
      /* console.log("node02js",bjs.num,bjs.foo); */
      console.log(number,foo);
      ```
  
      
  
    - 注意
      - 当使用`require`加载某个模块时，除了第一次加载会运行该文件以外（第一次运行万完后会进行缓存），后续的加载都会从缓存读取该文件内容，即同一文件被`require`多次，只会执行一次
      - `require`中的Javascript文件后缀名可以省略
      - `require`路径如果只有模块名，说明引入的是第三方下载的模块或者`Nodejs`自带的模块

### 文件系统



```javascript
const fs=require("fs");//引入内置文件模块，fs此时式一个对象
```



#### 读取文件



- 异步

  ```javascript
  fs.readFile("./nodejs01.js","utf-8",function(err,data){
  	//异步代码：在同步代码后执行
  	console.log("err",err);
  	console.log("data",data);
  	if(err){
  		console.log("failed");
  	}else{
  		console.log("success");
  	}
  })
  ```

  - 隐式转换 ：`if()`括号中值为 ：0， ``， undefined， null， NaN， false 时表示括号中布尔值为false，其余括号中任意值表示布尔值都为true

    

- 同步

  ```javascript
  const result= fs.readFileSync("./nodejs01.js","utf-8");
  console.log("........");
  console.log(result);
  
   try{
  	const result= fs.readFileSync("/nodejs01.js","utf-8");
  	console.log("sucess");
  }catch(e){
  	//TODO handle the exception
  	console.log("........");
  	console.log("failed");
    	console.log(e);
  }
  ```

  

#### 写文件



- 异步

  ```javascript
  fs.writeFile("./index.html","//success",function(err){
  	if(err){
  		console.log("failed")
  	}else{
  		console.log("success")
  	}
  })
  ```

  - 新内容覆盖旧内容，如果文件路径不正确，会根据错误路径创建一个新文件并写入

    - 路径中有文件夹则会报错，即：会自动创建文件，不会自动创建文件夹

      

- 同步

  ```javascript
  fs.writeFileSync("./index.html","//success");
  
  fs.writeFileSync("./test.txt","test");
  console.log("......");
  console.log("success"); 
  
  try{
  	fs.writeFileSync("/test.txt","test");
  }catch(e){
  	//TODO handle the exception
  	console.log("failed");
  	console.log(e);
  }
  ```

  

#### 文件中追加内容



- 异步

```javascript
fs.appendFile("/index.html","//success",function(err){
	if(err){
		console.log("failed")
	}else{
		console.log("success")
	}
})
```



- 同步

  ```javascript
  try{
  	fs.appendFileSync("/test.txt","\ntest2");
  }catch(e){
  	//TODO handle the exception
  	console.log("failed");
  	console.log(e);
  }
  ```

  

#### 复制内容



- 异步

  ```javascript
  fs.copyFile("./index.html","./index.js",function(err){
  	if(err){
  		console.log("failed")
  	}else{
  		console.log("success")
  	}
  })
  ```

  - 新内容覆盖旧内容，如果文件路径不正确，会根据错误路径创建一个新文件并写入

    - 路径中有文件夹则会报错，即：会自动创建文件，不会自动创建文件夹

      

- 同步

  ```javascript
  fs.copyFileSync("./index.js","./test.txt");
  
  try{
  	fs.copyFileSync("/index.js","./test.txt");
  }catch(e){
  	//TODO handle the exception
  	console.log("failed");
  	console.log("err",e);
  }
  ```

  

#### 删除文件



- 异步

  ```javascript
  fs.unlink("./index.html",function(err){
  	if(err){
  		console.log("failed")
  	}else{
  		console.log("success")
  	}
  })
  ```

  

- 同步

  ```javascript
  fs.unlinkSync("test.txt");
  
  try{
  	fs.unlinkSync("test.txt");
  }catch(e){
  	//TODO handle the exception
  	console.log("failed");
  	console.log(e);
  }
  ```

  

#### 重命名



- 异步

  ```javascript
  fs.rename("./index1.html","./index.html",function(err){
  	if(err){
  		console.log("failed")
  	}else{
  		console.log("success")
  	}
  })
  ```

  - 可以用来作为文件移动，但是需要保证移动到的文件夹存在

    

- 同步

  ```javascript
  fs.renameSync("./index1.js","./index.js");
  
  try{
  	fs.renameSync("/index1.js","./index.js");
  }catch(e){
  	//TODO handle the exception
  	console.log("failed");
  	console.log(e);
  }
  ```

  

#### 创建文件夹



- 异步

  ```javascript
   fs.mkdir("./public/a",function(err){
  	if(err){
  		console.log("failed")
  	}else{
  		console.log("success")
  	}
  })
  ```

  

- 同步

  ```javascript
  try{
  	fs.mkdirSync("./public1");
  }catch(e){
  	//TODO handle the exception
  	console.log("failed");
  	console.log(e);
  }
  ```

  

#### 删除文件夹



- 异步

  ```javascript
   fs.rmdir("./public1", err => {
  	if (err) {
  		console.log("failed",err)
  	} else {
  		console.log("success")
  	}
  }) 
  ```

  - 文件夹下有内容无法删除，`rmdir`只能删除空文件夹

    

- 同步

  ```javascript
  try{
  	fs.rmdirSync("./public1");
  }catch(e){
  	//TODO handle the exception
  	console.log("failed");
  	console.log(e);
  }
  ```

  

#### 读取文件夹内容



- 异步

  ```javascript
   fs.readdir("./public",(err,data)=>{
  	if (err) {
  		console.log("failed",err)
  	} else {
  		console.log("success",data)
  	}
  })
  ```

  - 只能读取一层内容，呈现方式为数组形式

    

- 同步

  ```javascript
  console.log(fs.readdirSync("../node"));
  
  
  ```

  

#### 判断文件夹是否存在



- 异步

  ```javascript
  fs.access("/public",function(err){
  	if (err) {
  		console.log("failed",err)
  	} else {
  		console.log("success")
  	}
  })
  ```

  

- 同步

  ```javascript
  try{
  	fs.accessSync("/public");
  	console.log("exsit");
  }catch(e){
  	//TODO handle the exception
  	console.log("failed");
  	console.log(e);
  }
  ```

  

#### 查看文件夹状态



- 异步

  ```javascript
   fs.stat("./public",function(err,stats){
  	if(err){
  		console.log("failed",err)
  	}else{
  		const isfile=stats.isFile();
  		const isdir=stats.isDirectory()
  		console.log(isfile,isdir);
  	}
  })
  ```

  - `isFile`：是文件,`true`or`false`

  - `isDirectory`：是文件夹,`true`or`false`

    

- 同步

  ```javascript
  console.log(fs.statSync("./public").isFile());
  console.log(fs.statSync("./public").isDirectory());
  ```

  

### 异步



- 同步：同一时间段内只能做一件事
- 异步：同一时间段内可以同时做多件事
- Javascript是一个单线程语言



#### AJAX



- 可以实现与服务器的异步通信
- 局部刷新页面



#### 异步解决方案的发展



- 回调函数
- `Promise`(ES6)
- `generator`(ES7)
- `async/await`(ES7)：异步终极方案



#### Promise



- 所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，`Promise` 是一个对象，从它可以获取异步操作的消息。

- `Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态

- 一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了

- `Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。

  - **resolve函数的作用**：将`Promise`对象的状态从“未完成”变为“成功”（即从 `pending` 变为 `resolved`），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。
  - **reject函数的作用**：将`Promise`对象的状态从“未完成”变为“失败”（即从 `pending` 变为 `rejected`），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

  - `then`方法可以接收两个回调函数作为参数，第一个回调函数是`Promise`对象的状态变为resolved(成功)时调用，第二个回调函数是`Promise`对象的状态变成`rejected`(失败)时调用，**第二个函数是可选的，可以不提供**。这两个函数都接收`Promise`对象传出的值作为参数。

```javascript
new Promise(resolve=>{
	setTimeout(function(){
		console.log("1");
	},1000);
	resolve("2");
}).then(x=>{
	console.log(x);
})

const p= new Promise((resolve,reject)=>{
	$.ajax({
		url:"./nodejs01.js",
		success(msg){
			resolve(msg);
		}
	})
	//异步代码
	/* resolve();
	reject(); */
})

p.then(function(msg){
	$.ajax({
		url:"./nodejs01.js",
		data:{
			id:msg.id
		},
		success(msg){
			
		}
	})
},function(//reject参数){})
 
//多次嵌套       
p.then(function(msg) {
	return new Promise(function(resolve, reject) {
		$.ajax({
			url: "./nodejs01.js",
			data: {
				id: msg.id
			},
			success(msg) {

			}
		})
	})

}).then(function(msg) {

})

```



#### async/await



- `async`用于定义一个异步函数，返回值是一个`Promise`对象

- `await`一般用于等待一个`promise`对象，实际上就是等待一个异步处理结果

  - `await` 关键字 只能放在` async` 函数内部，` await`关键字的作用 就是获取 `Promise`中返回的内容， 获取的是`Promise`函数中`resolve`或者`reject`的值
    - 如果`await` 后面并不是一个`Promise`的返回值，则会按照同步程序返回值处理

  ```javascript
  function foo(num){
  	return new Promise(resolve=>{
  		console.log(num);
  		resolve(num);
  	})
  }
  async function bar(){
  	const p1=await foo(1);
  	const p2=await foo(2);
  	const p3=await foo(3);
  	
  }
  bar();
  console.log(4);
  
  const p=function(x,time){
  	return new Promise(resolve=>{
  		setTimeout(function(){
  			resolve(x);
  		},time);
  		
  	}) 
  }
  async function foo(){
  	const p1=await p(1,1000);
  	console.log(p1);
  	const p2=await p(2,1000);
  	console.log(p2);
  	const p3=await p(3,1000);
  	console.log(p3);
  	
  }
  foo();
  
  const p = new Promise((resolve, reject) => {
  	$.ajax({
  		url:"./nodejs01.js",
  		success(msg){
  			resolve({id:1});
  		}
  	})
  	
  })
  function ajax2(msg){
  	$.ajax({
  			url: "./nodejs01.js",
  			data: {
  				id: msg.id
  			},
  			success(msg) {
  	
  			}
  		})
  }
  async function foo() {
  	const msg = await p;
  	ajax2(msg);
  	//console.log(msg);
  }
  foo();
  ```

  

### 路径



- 引入路径模块

  ```javascript
  const path= require("path");
  ```

  

#### 当前绝对路径

```javascript
console.log(__dirname);
```



#### 获取路径



- 路径最后一部分`basename()`

  ```javascript
  console.log(path.basename(__dirname));
  ```

  

- `basename`以外的其他路径`dirname()`

  ```javascript
  console.log(path.dirname(__dirname));
  ```

  

- `extname()`扩展名

  ```javascript
  console.log(path.extname(__dirname));
  ```

  

#### 路径组合



- 相对路径拼接`join()`

  ```javascript
  console.log(path.join("a","b","c"));// a/b/c
  console.log(path.join("a","b","..","c"));// a/c
  ```

  

- 绝对路径拼接`resolve()`

  ```javascript
  console.log(path.resolve("a","b","c"));
  console.log(path.resolve("a","b","..","c"));
  ```

  

#### 路径拆分



- `parse()`

  - 得到一个对象，使用时可以通过对象属性方法调用

  ```javascript
  console.log(path.parse(mypath));
  path.parse(mypath).root;
  path.parse(mypath).ext;
  path.parse(mypath).name;
  path.parse(mypath).base;
  path.parse(mypath).dir;
  ```

  

### http



- 引入`http`模块

  ```javascript
  const http=require("http");
  ```

  

- 创建服务器

  ```javascript
  const server= http.createServer(function(req,res){
  	fs.readFile("./index.html","utf-8",(err,data)=>{
  		console.log(data);
  		res.write(data);
  		res.end();
  	});
  });
  ```

  - `request（req）`：请求对象，请求相关的对象和方法

  - `response（res）`：响应对象，响应相关的对象和方法

    

- 端口

  - 通过IP地址找到计算机，如果我们还想找到该及计算机的某个应用程序，需要知道应用程序对应的端口号

  - 端口范围：0-65535，建议3000以上，如8080，http默认端口80

    ```javascript
    server.listen(3000,()=>{
    	console.log("server success");
    });
    ```

    

### npm



- npm：包管理器
  - 用户从npm服务器下载别人编写的第三方包到本地使用
  - 将自己编写的包上传到npm服务器供别人使用



#### 安装

- 安装nodejs时会一起下载安装

- 通过`npm -v`检查是否安装npm

  ```javascript
  npm -v
  ```

  



#### 基本使用



- 下载包

  - 局部安装（项目内下载）

    ```javascript
    npm  install 安装包名 --save 
    npm  i 安装包名 --save //save早期版本不加“--save”会下载包，但不会写入package.json，最新版本可以不加“--save”，也会写入package.json
    ```

  - 全局安装（任何程序都可以引入使用）

    ```javascript
    npm  install 安装包名 --g
    ```

    

  -  通过npm下载的所有包，都会放到`node_modules`文件中

  - 可以通过淘宝镜像下载加快下载速度，更改命令：

    ```
    npm config set registry https://registry.npm.taobao.org/
    ```

    

- 卸载包

  ```javascript
  npm uninstall 安装包名//同时在package.json中删除记录
  ```

  

#### package.json



- 每一个项目中在根目录中应该有一个`package.json`用来对当前项目进行说明描述，包括项目名称，项目版本，项目依赖文件等

- 项目初始化：生成`package.json`文件,在项目根目录执行下面命令

  ```javascript
  npm init
  npm init -y//采用默认
  ```

- 下载项目所有依赖文件

  ```javascript
  npm i //根据package.json下载项目依赖文件
  ```

  

### express



- 官网 https://www.expressjs.com.cn

- express本身是一个基于nodejs的服务端框架

  

#### 应用程序生成器



- express-generator，帮助开发者快速创建一个express项目

- 执行以下命令全局安装express-generator

  ```javascript
  npm i express-generator -g
  ```

  

#### express项目创建



- 通过express-generator创建

```javascript
express 项目根目录名称
```

- 进入项目根目录下载项目依赖包

  ```javascript
  npm i
  ```

- 启动项目

  ```javascript
  npm start
  ```

- 浏览器访问项目

  ```javascript
  ip地址/localhost:3000
  ```

  

- 更改启动命令

  - app,js文件中

  ```javascript
  //module.exports = app;注释此条代码
  //新增
  
  app.listen(3000,()=>{
  	console.log("3000 port start");
  })
  ```

  - 下载插件nodemon后全局安装

    ```javascript
    //nodemon app.js 通过nodemon运行app.js后，每次更改文件保存后会自动重启
    ```

    

### Mongodb



#### 定义

- 数据库：用于数据的管理，保证数据的持久化

- 分类

  - 关系型：Mysql

  - 非关系型：Mongodb

  ![截屏2023-02-08 11.49.42](/Users/mujiabin/Documents/HBuilderProjects/practise/nodejs/img/截屏2023-02-08 11.49.42.png)

#### 使用

- 命令行操作

  - Mac终端：进入`cd /usr/local/bin/mongosh`

  - 查看当前服务器中所有数据库

    ```
    show dbs
    ```

  - 查看当前指向数据库

    ```
    db
    ```

  - 新建或切换数据库

    ```
    use 数据库名称//区分大小写
    ```

  - 查看当前数据库所有集合

    ```
    show collections
    ```

  - 向集合中添加数据（如果集合不存在，会自动创建集合）

    ```
    db.集合名称.insert({name:"zhangsan",age:30,gender:"male"})
    db.users.insertOne({name:"zhangsan",age:30,gender:"male"})
    ```

  - 查看某个集合所有数据

    ```
    db.集合名称.find()
    db.集合名称.find().pretty()
    模糊查询：find({name:{$regex:`李`,$options:`$i`}})，name属性中包含“李”的的所有数据,$options:`$i`不区分大小写，$regex:``空字符串匹配所有内容
    ```
    
    - 复杂查询：https://www.runoob.com/mongodb/mongodb-query.html
    
      

- 可视化工具操作

  - MongoDB Compass
  - 连接：`localhost:27017`

- 通过后端代码中操作

  - Mongoose:是Nodejs提供的一个用于便捷操作MongoDB的库

  - 下载

    ```
    npm i mongoose --save
    ```

    

  - 连接

    - 将express项目与mongodb连接：app.js文件增加

      ```
      //连接mongodb
      var mongoose = require('mongoose');
      const dbURI="mongodb://localhost:27017/express";//express为要连接具体数据库的名称
      mongoose.connect(dbURI,{useNewUrlParser:true,useUnifiedTopology:true});
      //项目与数据库连接成功时触发事件
      mongoose.connection.on("connected",function(){
      	console.log(dbURI+`数据库连接成功`)
      })
      ```

      

  - 集合操作
    - 配置结构及模型

  ```javascript
  //1 定义集合中有哪些属性及属性值的类型-结构schema
  const {Schema, model}=require("mongoose");
  const userschema= new Schema({
  	username:String,
  	userpass:String，
  	classid: {
  		type: Schema.Types.ObjectId,
  		ref: `clamodel` //要关联的集合模型名称
  	} //一对一
  	/* classid: [{
  		type: Schema.Types.ObjectId,
  		ref: `` //要关联的集合模型名称
  	}], */ //关联为一对多时，classid属性值为数组,需要加上数组中括号：[]
  })
  //2 定义数据集合的模型,将结构schema和数据库的集合关联起来
  //model("模型名称"，userschema，“数据库中集合名称”)
  const usermodel= model("usermodel",userschema,"users");//如果“数据库中集合名称”不屑写，默认为"模型名称"s
  ```

- 操作数据

  - 查找查询，返回一个数组，数组内部为一个个符合条件的对象

    - 按条件查询

    - 查询所有数据

      ```
      usermodel.find({username:"zhangsan"})
      usermodel.find()
      ```

    - ` populate`关联查询，参数为关联的`key`，返回的是`find（）`全部内容，其中`classid`对应属性值为以对象形式保存的另一张表的整条数据

    - `limit()`限制返回条数,`skip()`跳过多少条数据

      ```javascript
      const data = await stumodel.find({
      		[searchtype]: searchname//对象内属性为变量，例如searchtype为变量，需要加“[]”
      	}).populate({//多层嵌套：1.stumodel关联clamodel的classid
      		path: `classid`,
      		populate: {//多层嵌套：2.clamodel关联teamodel的teaid
      			path: `teaid`
      		}
      	}).limit(pagesize - 0).skip((currentpage - 1) * pagesize);//pagesize-0-字符串转数字，pagesize和currentpage为预先定义的变量
      
      
      //如果stumodel同时关联clamodel和teamodel，关联关系在stumodel中设置
      stumodel.find().populate(`classid`).populate(`teachesid`)
      ```

      - 模糊查询

        ```javascript
        find({
          name:{$regex:`李`,$options:`$i`}
        })//name属性中包含“李”的的所有数据,$options:`$i`不区分大小写，$regex:``空字符串匹配所有内容,
        ```

        - 要注意模糊查询属性值数据类型，比如`Objectid`不支持模糊查询

  - 新增

    ```
    usermodel.create({username:"123",userpass:"123"})
    ```

    

  - 删除

    ```
    usermodel.deleteOne({username:"123"})//删除一个
    usermodel.deleteAll({username:"123"})//全部删除
    ```

    

  - 修改

    ```
    usermodel.updateOne({username:"123"},{username:"456"})//两个对象参数，前面对象为查询条件，后面参数为修改值
    ```

    

  - 注释：

    - 以上所有方法都是异步方法，且这些方法返回值都是promise对象，因此需要await去等待操作结果，或其他异步函数处理方法，如回调函数
    - 增删改查对应内容应与schema内定义的结构一致，如schema内定义username及userpass，则增删改查内容与之需保持一致，不可出现为在schema内定义的结构

    ```
    router.post('/login',async function(req, res, next) {
    	const user=req.body;
    	const result= await usermodel.find(user);
    	if(result.length>0){
    		res.send({
    			message:"success",
    			status:1
    		})
    	}else{
    		res.send({
    			message:"failed",
    			status:0
    		})
    	}
    ```

    

    

- 三层架构（routes-service-dao）

  ![a66e0d1c14a44cfc812e57c51fd8f3a5](/Users/mujiabin/Documents/HBuilderProjects/practise/nodejs/img/:Users:mujiabin:Downloads:a66e0d1c14a44cfc812e57c51fd8f3a5.png)

  - 项目根目录新建service目录和dao目录

  - app.js引入连接数据库模块

    ```javascript
    require(`./dao/database`);

  - dao目录下新建database.js文件建立项目与数据库连接

    ```javascript
    var mongoose = require('mongoose');
    mongoose.connect('mongodb://localhost/myDB');
    mongoose.connection.on(`connected`,function(){
    	console.log(`数据库连接成功`)
    });
    ```

    

  - dao目录下新建models目录，放置不同数据结构定义及实例化model模型

  - dao-models下新建usersModel.js

    ```javascript
    const {Schema, model}=require("mongoose");
    const userschema= new Schema({
    	username:String,
    	password:String,
    })
    //2 定义数据集合的模型,将结构schema和数据库的集合关联起来
    //model("模型名称"，userschema，“数据库中集合名称”)
    const usermodel= model("usermodel",userschema,"users");
    module.exports.usermodel=usermodel;//将usermodel暴露出供dao使用
    ```

    

  - app.js配置ajax请求路径
  
    ```javascript
    //用于配置ajax请求的一级路径
    app.use('/index', indexRouter);
    app.use('/users', usersRouter);
    app.use('/movies', moviesRouter);
    app.use('/class', classRouter);
    app.use('/teachers', teachersRouter);
    
    require(`./dao/database`);
    var indexRouter = require('./routes/index');
    var usersRouter = require('./routes/users');//一级路径
    var moviesRouter = require('./routes/movies');
    var classRouter = require('./routes/class');
    var teachersRouter = require('./routes/teachers');
    ```
  
    
  
  - 在html页面发送ajax请求
  
    ```javascript
    $.ajax({
    					url: "/users/login",//users为一级路径；login为一级路径下二级路径，匹配表现层router.post里面第一个参数
    					type: "get",//get类型一般用于获取数据，post则用于提交数据并获取数据
    					data: searchdata
    ```
    
    
  
  - 表现层，routes下user.js
  
    ```javascript
    const {login}= require(`../service/usersService`);//引入usersService暴露的对象并解构
    router.post('/login', async function(req, res, next) {// `/login`为users下二级路径，匹配ajax中url的二级路径
    	const user=req.body;
    	const data= await login(user);//将user传给usersService层,并接收usersService层返回的数据
    	res.send(data);
    	}); */
    ```
  
    
  
  - 服务层，service下service.js
  
    ```javascript
    //引入dao层暴露的对象并解构
    const {login}=require(`../dao/usersDao`);//const {login}中login是此文件内的全局变量
    
    //暴露一个login函数返回一个对象供user.js调用
    module.exports.login=async function(user){
    	//module.exports.login中的login是暴露对象的一个属性
    	const data=await login(user);//调用第三层userDao暴露的login方法或函数并接收第三层传回的结果
    	if(data.length>0){
    		return {
    			message:"login success",
    			status:1
    		}
    		}else{
    			return {
    				message:"login failed",
    				status:0
    			}
    	}
    }
    ```
  
    
  
  - 持久层
  
    ```javascript
    //引入usermodel暴露的对象并结构
    const{usermodel}= require(`./models/usersModel`);
    //暴露login函数返回一个对象给userService调用
    module.exports.login = async function(user) {
    	const data = await usermodel.find(user); //查询数据库通过data接收
    	//console.log("333",data);
    	
    	return data; //将结果返回第二层
    }
    ```
  
    
    
  - app.js配置ajax访问路径
  
    ```javascript
    //用于配置ajax请求的一级路径
    app.use('/index', indexRouter);
    app.use('/users', usersRouter);
    app.use('/movies', moviesRouter);
    app.use('/class', classRouter);
    app.use('/teachers', teachersRouter);
    
    require(`./dao/database`);
    var indexRouter = require('./routes/index');
    var usersRouter = require('./routes/users');
    var moviesRouter = require('./routes/movies');
    var classRouter = require('./routes/class');
    var teachersRouter = require('./routes/teachers');
    ```



### 上传文件



- 借助三方包`multer`在/utils/文件下建立一个用于上传和移动文件的模块工具handlefiles.js

  ```javascript
  npm i multer
  ```

  ```javascript
  const multer = require(`multer`);
  const fs = require(`fs`);
  const path = require(`path`);
  
  /* 
  图片上传：
  接收一个option对象作为参数，包含三个属性
  参数说明：
  path:图片上传路径
  key：与前端formdata.append(`file`, files[0])第一个参数field那么匹配，即“file”
  size：图片最大限制，单位kb
   
   */
  function uploadfiles(options = {}) {
  	//解构options并赋给默认值
  	const {
  		path = `./public/temp`, key = `file`, size = 1000
  	} = options;
  	//设置multer参数，配置diskStorage来控制文件存储的位置即文件名等
  	const storage = multer.diskStorage({
  		//确定图片存储位置
  		destination: function(req, file, cb) {
  			//目录不存在自动创建目录
  			try {
  				fs.accessSync(path)
  			} catch (e) {
  				//TODO handle the exception
  				fs.mkdirSync(path)
  			}
  			cb(null, path);
  		},
  		//确定文件存储时名字，如果使用原名，可能造成再次上传同一张照片时发生冲突
  		filename: function(req, file, cb) {
  			var changename = new Date().getTime() + `-` + file.originalname;
  			cb(null, changename);
  		}
  	})
  	const limits = {
  		//限制文件大小100kb
  		filesize: 1024 * size,
  		//限制文件数量5个
  		files: 5
  	}
  	//生成专门用于处理上传的一个工具，可以传入storage，limits等配置
  	const upload = multer({
  		storage,
  		limits
  	});
  	//返回多文件上传配置信息，同样适用于但文件上传
  	return upload.array(key);
  }
  
  /* 
  复制文件
  接收一个option对象作为参数，包含三个属性
  参数说明：
  frompath：源文件路径
  topath：复制过去新路径
  filename：文件名
   */
  
  function copyfiles(options = {}) {
  	const {
  		frompath = `./public/temp`, topath = `./public/img`, filename
  	} = options;
  	let sourcefile = path.join(frompath, filename);
  	let destpath = path.join(topath, filename);
  	try {
  		fs.accessSync(topath)
  	} catch (e) {
  		//TODO handle the exception
  		fs.mkdirSync(topath)
  	}
  }
  
  /* 
  移动文件
  接收一个option对象作为参数，包含三个属性
  参数说明：
   frompath：源文件路径
   topath：复制过去新路径
   filename：文件名
   */
  function movefiles(options = {}) {
  	//对参数解构并设默认值
  	const {
  		frompath = `./public/temp`, topath = `./public/img`, filename
  	} = options;
  	var sourcefile = path.join(frompath, filename);
  	var destpath = path.join(topath, filename);
  	//topath目录不存在创建目录
  	try {
  		fs.accessSync(topath)
  	} catch (e) {
  		//TODO handle the exception
  		fs.mkdirSync(topath)
  	}
  	fs.renameSync(sourcefile, destpath);
  	return {
  		path: destpath
  	}
  }
  
  /* 
  接收一个字符串
  参数说明：
   filepath：要删除文件的路径
   例子：removefiles(`./public/temp`)
   */
  function removefiles(filepath = `./public/temp`) { //filepath要删除的文件路径
  	let stats = fs.statSync(filepath);
  	//判断是否是文件
  	if (stats.isFile()) {
  		//删除文件
  		fs.unlinkSync(filepath)
  	} else if (stats.isDirectory()) {
  		let filearr = fs.readdirSync(filepath);
  		filearr.forEach(file => {
  			removefiles(path.resolve(filepath, file))
  		})
  		fs.rmdirSync(filepath);
  	}
  }
  
  module.exports = {
  	uploadfiles,
  	copyfiles,
  	movefiles,
  	removefiles
  }
  ```

  

- 前端页面获取图片并上传

  ```javascript
  <div>
  					<label for="">上传图片</label>
  					<input type="file" id="uploadpic"><!-- 上传文件 -->
  					<div class="img-box">
  
  					</div>
  				</div>
  
  //上传图片
  			$(`#uploadpic`).change(function(event) { //找到上传图片标签添加change事件
  				//event.target等同与this
  				const files = this.files; //1.拿到图片，为一个数组，分别为每一张图片，想要对每一张操作files[i]
  				//2将图片添加到表单对象
  				const formdata = new FormData(); //通过构造函数创建一个表单对象
  				formdata.append(`file`, files[0]); //第一个参数为此条数据取个名字，第二个参数为真正要传的数据
  				//3 将表单对象通过ajax发送到服务器
  				$.ajax({
  					url: "/pics/upload",
  					type: "post",
  					data: formdata,
  					//下面三个属性都是保证图片数据完整传递到后端，不做转换
  					cache: false, //不读取缓存结果
  					contentType: false, //数据编码格式不使用jquery方式
  					processData: false, //图片不需要数据转换称其他格式，因为前后端传递数据默认都会转换成字符串，json格式
  					success(msg) {
  						console.log(msg);
  						$(`.img-box`).html(``);
  						$(`.img-box`).append(`
  						<img id="profilepic" src="./temp/${msg.data}" alt="">
  						`);
  						picname = msg.data;
  					}
  				})
  			})
  ```

  

- 建立一级路径用于文件上传，在`app.js`,`/routes/`新建模块并在`/service/`,`/dao/`,`dao/models`已有模块内调用

  - app.js

    ```javascript
    var picsRouter = require('./routes/pics');
    
    app.use('/pics', picsRouter);
    ```

    

  - /routes/pics.js

    ```javascript
    var express = require('express');
    var router = express.Router();
    const {
    	uploadfiles
    } = require(`../utils/handlefiles`)
    
    router.post('/upload', async function(req, res, next) {
    	const upload = uploadfiles({
    		path: `./public/temp`, //相对于app.js路径，图片上传后存储路径
    		key: `file`, //匹配前端formdata.append(`file`, files[0])第一个参数;
    		size: 1000 //单位kb
    	})
    	upload(req, res, (err) => {
    		if (err) {
    			console.log(`pic upload failed`)
    		} else {
    			console.log(`pic upload success`, req.files);
    			res.send({
    				message: `success`,
    				status: 1,
    				data: req.files[0].filename
    			})
    		}
    	})
    });
    
    module.exports = router;
    ```

    

  - 与已有模块结合代码见项目响应模块pic部分

    

### 数据加密



#### 分类

- 可逆
- 不可逆：常用
  - 有规律：MD5
  - 无规律：bcrypt



#### MD5



- ./utils/crypto.js

```javascript
const crypto = require(`crypto`); //nodejs内置模块，不用下载

/* 
 @md5加密模块(加密固定，不可逆)
 @param str string要加密的字符串
 @param secret string要加密的密钥(要记住密钥，否则无法解密)
 return string 加密后的字符串
 */
//secret密钥用于混淆，可以在此处更换，也可在程序调用时通过传参数更换，此处为一个默认值
module.exports.getMd5 = function(str, sectet = "9vApxLK5G3PAsJrM") {
	const md5 = crypto.createHash("md5");
	return md5.update(str + sectet).digest("hex");
}
```



- 调用md5加密

  ```javascript
  router.post('/reg', async function(req, res, next) {
  	//const username= req.body.username;
  	const {
  		username,
  		password
  	} = req.body;
  	const newpassword = getMd5(password, `abcdefghijklmn`); //后面参数为自定义密钥，用于混淆,可以传也可以不传，不传会用./utils/crypto.js中默认密钥
  
  	//await insert(user);
  	const data = await reg2({
  		username,
  		password: newpassword
  	});
  	res.send(data);
  ```

  

#### bcrypt



```
npm i bcrypt
npm i bcryptjs
```



- 使用

  ```javascript
  onst bcrypt = require(`bcrypt`);
  ```

  - 加密

    ```javascript
    const newpassword= bcrypt.hashSync(password, 10) //第一个参数为要加密的字符串，第二个参数为加密强度，10为适中，数字越大强度越大，但加密过程会耗时长
    ```

    

  - 验证

    ```javascript
    const result= bcrypt.compareSync(password,data[0].password)//将用户输入密码与数据库存储的密码做比较,true or false
    ```

    

### 用户身份认证



#### JWT与session



- 前后端分离的应用中，后端为model层，为前端提供访问的api。为了用户与服务端传输数据安全可靠，服务端认证十分重要
- 常见服务端认证：
  - 基于cookie认证：session
  - 基于token（令牌）认证：JWT，localstorage，目前用的很多



#### 身份认证（鉴权）流程



##### session:服务端本地存储，永久保存

- 用户输入登录信息
- 服务端验证是否正确，如果正确创建session并存入数据库
- 服务端向客户端返回带有session id的cookie
- 接下来每次客户端请求都会带上这个cookie，服务端会把session id与数据库中的session id做比较，如果有效则处理该请求
- 用户退出登录，服务端和客户端都会销毁session

- 注释：session与sessionStorage不是一回事



##### JWT：jsonwebtoken

```javascript
npm i jsonwebtoken //生成token
npm i express-jwt //验证token
```

- 需要控制在"express-jwt": "^6.1.1",以下，否则工具语法不生效
  - 在package.json内将express-jwt版本改为6.1.1然后npm i

- 用户输入登录信息

- 服务端验证是否正确，如果正确返回一个已签名的token（加密字符串）

  ```javascript
  if (data.status) {
  		const result = bcrypt.compareSync(password, data.data[0].password) //将用户输入密码与数据库存储的密码做比较
  		if (result) {
  			const token = jwt.sign({
  					username
  				}, //要保存的信息
  				`abcd`, //密钥，混淆用
  				{
  					expiresIn: 60000
  				} //token有效期，单位默认为秒，
  			)
  ```

  

- 前端将token存在localStorage中，但也可存在sessionStorage或cookie中

  ```javascript
  success: function(msg) {
  						if (msg.status) {
  							alert("login success");
  							localStorage.setItem(`token`, msg.token)
  ```

  

- 接下来每次客户端请求都会带上这个token，服务端验证token，如果有效则处理该请求

  -  请求页面

  ```javascript
  /* 
  			 请求四部分组成：
  			 请求头，
  			 请求行，
  			 空行，
  			 请求体
  			 */
  			islogin();
  
  			function islogin() {
  				$.ajax({
  					url: `users/islogin`,
  					type: `get`,
  					//请求头，
  					headers: {
  						authorization: `bearer ` + localStorage.token //express-jwt要求格式，bearer后面一个空格，不要忽略
  					},
  					success(msg) {
  						console.log(msg);
  					}
  				})
  			}
  ```

  - utils/jwt.js

    ```javascript
    const expressJWT = require(`express-jwt`);
    
    const jwtAuth = expressJWT({
    	secret: `abcd`, //token生成密钥一致
    	algorithms: [`HS256`], //设置jwt算法为hs256
    	credentialsRequired: false //无token请求是否解析
    }).unless({
    	path: [`/users/login`, `/users/reg`, `/users/isexsit`] //设置不需要验证token的路径
    })
    
    module.exports = jwtAuth;
    ```

    ![7c6059731b9aec03473027131b841c46](/Users/mujiabin/Documents/HBuilderProjects/practise/nodejs/img/:Users:mujiabin:Downloads:7c6059731b9aec03473027131b841c46.png)

  - app.js

    ```javascript
    const jwtAuth = require(`./utils/jwt`);
    
    //一级路径前验证token
    app.use(jwtAuth);//身份认证生效，如果不需要则注释掉此行代码
    ```

    

  - user.js

    ```javascript
    router.get('/islogin', async function(req, res, next) {
    	//获取token，拿到用户信息
    	const headerstoken = req.get(`authorization`);
    	const token = headerstoken.split(" ")[1];
    	const {
    		username
    	} = jwt.verify(token, TOKEN_KEY); //abcd解码密钥,解码出为一个对象
    
    	res.send({
    		msg: "身份认证成功",
    		status: 1,
    		data: username
    	})
    });
    //客户端ajax拿到返回对象解析根据业务逻辑处理使用
    //TOKEN_KEY:utils下新增模块const.js, 保存全局常量，其余jwt用到密钥直接调用
    const TOKEN_KEY = `abcd`;
    module.exports = {
    	TOKEN_KEY
    };
    ```

    

  - 全局ajax

    ```javascript
    //index.html
    //全局设置ajax请求头
    			/* $.ajaxSettings.beforeSend = function(xhr, request) {
    				xhr.setRequestHeader(`authorization`, `bearer ` + localStorage.token)
    			} */
    			//全局设置ajax
    			$.ajaxSetup({
    				headers: {
    					authorization: `bearer ` + localStorage.token
    				},
    				error(err) {
    					if (err.status == 401) {
    						alert(`还未登陆，请先登陆`);
    						location.href = `./login.html`
    					}
    				}
    			})
    ```

    - 全局ajax设置后，下面ajax只需要设置自己单独使用的变量参数即可

- 用户退出登录，客户端会销毁token，此步骤与服务端无关



#### 区别

- session将用户状态保存在服务端，JWT保存在客户端
- session基于cookie实现，每次请求都会带上cookie，取出响应字段与服务端做对比来实现身份认证；JWT将token附在http请求头部上，由服务端check signature即可实现，无需担心cookie存在的CORS问题



#### 优缺点



- 扩展性
  - 分布式应用，session需要多机数据共享，因此需要保存在数据库胡redis；JWT只需要保存在客户端即可
- 无状态
  - JWT不会在服务端保存任何状态，restful api原则即是无状态，发请求时会带有参数的响应，不会产生其他影响，用户认证状态引入这种附加影响破坏了这一原则，另外JWT载菏中可以存储一些常用信息，用于交换信息，有效使用可以降低查询数据库次数
- 安全性
  - JWT的payload是base64编码，没有加密，因此不可存敏感数据，session存储服务端，相对安全
- 性能
  - 由于JWT无状态，所有信息都会放在JWT中，如果还要进行数据交换，载荷会更大，经过编码后JWT很长，cookie大小为4k，可能放不下，所以JWT会放在localStorage中，用户在访问时JWT在http header中，可能导致header比body还要大；session很短的字符串，因此开销较小



### moment



- 服务端时间插件

  ```javascript
  npm i moment
  ```



- 使用

  ```javascript
  const moment = require(`moment`);
  
  const stuschema = new Schema({
  	username: String,
  	userage: String,
  	usergender: String,
  	picname: String,
  	time: {
  		type: String, //也可用Date属性，但mongo Date类型不是我们想要的效果
  		//default: `2023-09-18 11:00` //如果前端未传数据，就是用这个
  		default: moment().format(`YYYY-MM-DD HH:mm`) //或YYYY年MM月DD日
  	},
  	classid: {
  		type: Schema.Types.ObjectId,
  		ref: `clamodel` //要关联的集合模型名称
  	} //一对一
  ```

  

### RESTful



- REST：表现层状态转换，实际是一种接口的命名规范

  - url（资源路径）用来定义资源名称

  - type（资源类型）用来定义资源操作

    - 请求类型：
      - get：获取或查询
      - post：新增
      - put：修改
      - delete：删除
      - 如果传递的数据有唯一值（_id），将_id放在url路径上

    ```javascript
    //前端请求
    $.ajax({
    					url: `/index`,
    					type: "add",
    //后端表现层
    router.post('/', async function(req, res, next) {
    	const stu = req.body;
    	//console.log(stu);
    	const data = await add(stu);
    
    //前端请求-删除
    $.ajax({
    					url: `/index/`,
    					type: "delete",
      
      $.ajax({
    					url: `/index/`+_id,
    					type: "delete",
    //后端表现层
    router.delete('/', async function(req, res, next) {
    	const stu = req.body;
    	//console.log(stu);
    	const data = await delete(stu);
      
      router.delete('/:接收_id的变量名', async function(req, res, next) {
    	const stu = req.params;//req.params用来接收一级路径后面的变量名
    	//console.log(stu);
    	const data = await delete(stu);
    
      
    ```

    

### 跨域



#### 同源策略

xhr：XMLHttpRequest，ajax核心对象

- 同源策略：是**浏览器**端一个安全策略

  - 一个请求至少三部分组成，协议（如http），ip地址，端口，当我门在一个页面中向服务器发请求时，页面地址和请求地址的协议，ip，端口三者中有一个不同则为跨域
  - 同源策略要求页面和页面中的请求的协议，ip，端口保持一致

  

#### 跨域解决方案



- JSONP

  ```javascript
  //前端请求
  $.ajax({
  					url:`http://192.168.1.14:3000/getstu`,
  					dataType:`jsonp`,
    
   //后端
    
    res.jsonp(data);
  ```

  - 自己测试时可以复制一份app.js到根目录，将3000端口换为其他端口启动，用3000端口请求访问3001服务器

  - JSONP只能解决get请求跨域

  - 另外：<script>,<img>,<link>标签天生支持跨域

    

- CORS

  ```javascript
  var allowCrossDomain=function(res,req,next){
    //允许跨域访问的请求源，“*”表示任意域名，指定源的访问将“*”变为请求源地址
    res.header("Access-Control-Allow-Origin","*");
    //允许跨域访问的请求头，如果需要处理token，还需要加上authorization，以此类推，需要什么属性就要加上
     res.header("Access-Control-Allow-Headers","X-Request-With,Origin,Content-Type,Accept");
    //允许跨域访问的请求类型，如果需要其他类型，继续添加即可
    res.header("Access-Control-Allow-Methods","PUT,GET,POST,DELETE,OPTIONS");
    //统一cookie发送到服务器，如果发送cookie，Access-Control-Allow-Origin不能设置“*”
    res.header("Access-Control-Allow-Credentials","true");
    next();
  };
  app.use(allowCrossDomain);
  ```

  - 将代码复制到**被访问**服务器的app.js文件的`var app=express()`之后，或者一级路径之前

    - 简单配置：**实测有效**

      ```javascript
      //安装cors依赖包
      npm i cors
      //app.js添加配置
      var cors=require('cors');
      app.use(cors());
      
      ```

      

  - 请求源：协议+ip+端口

  - ajax请求url换为跨域地址

    

- 代理服务器

  - 只有浏览器会有同源策略问题，服务器访问服务器，手机app访问服务器无跨域问题

  - 搭建代理服务器-只做转发

    - 新建express服务器，命名为proxy并启动，将前端代码配置好在public文件夹内

    - 安装http-proxy-middleware,将express作为中间层，即客户端请求到中间层，中间层借助http-proxy-middleware将请求转发到目标服务器

    - 代理服务器端口号不能与目标服务器端口号相同，比如目标服务器端口号3000，代理需设置不同端口，如8000

    - app.js中，一级路径配置之前添加代码

      ```javascript
      const {
      	createProxyMiddleware
      } = require(`http-proxy-middleware`);
      const options = {
      	target: `http://localhost:3000`, //目标服务器
      	changeOrigin: true, //默认为false，是否需要改变原主机头为目标url
      	pathRewrite: { //重写请求
      		"^/api": `/` //所有以/api开头的请求都会被改写为“/”，注意："^/api"双引号，单引号报错
      	}
      }
      app.use(`/api`, createProxyMiddleware(options));//var app = express();之后,其实是配置/api的一级路径，遇到/api的请求就转发走
      
      //前端
      $.ajax({
      					url: "/api/index/get",//url: "/index/get"，原请求前+/api
      ```

      

  - 搭建代理服务器-处理后转发

    - 下载request和request-promise插件

    - 在需要转发的模块引入

      ```javascript
      //注册模块
      
      const rp = require(`request-promise`);
      
      router.post('/reg', async function(req, res, next) {
      	const newpassword = req.body.password.（加密操作）
      	const data = await rp({ //通过request-promise向目标服务器发请求,可以看成是后端的ajax
      		method: `POST`,
      		uri: `http://localhost:3000/users/reg`,
      		body: {
      			username: req.body.username,
      			password: newpassword
      		},
      		json: true // 后端返回json格式
      	})
      	//可以再对拿到的data进行一些处理后再返回客户端
      	res.send(data); //data拿到是目标服务器返回的结果
      });
      ```

      



# Vue



## 前端框架



### 框架和库



- 库：更侧重于某个功能点，库之间没有排他性，一个项目中可以引入多个库混合使用，
  - 例如jQuery在操作节点，lodash在数据操作

- 框架：给项目一个完整的解决方案，通常框架间不会混合使用
  - Vue.js,React,Angular
    - Angular：09年
    - React：13年，Facebook内部框架并开源
    - Vue.js：14年

## Vue3



- 官网：https://v2.cn.vuejs.org/v2/guide/



### 安装



#### 1.安装脚手架工具（Vue CLI）



- 查看cli版本号

```bash
vue -V
```



- 安装cli

  ```bash
  npm install -g @vue/cli 
  ```

  - mac系统命令前加sudo

    

#### 2.创建项目



- 创建项目名称
  - mac系统命令前加sudo

```bash
sudo vue create 项目名称
```

- 创建模式，首次选择自定义模式，如已有保存过的模式可以选择
  -  Manually select features

- 选择插件
  - 只选择babel，做语法转换，把代码转换成浏览器可视别的代码
- 选择Vue版本
  - 选vue3.x
- 选择插件配置代码位置
  - 选第一个，单独创建：In dedicated config files

- 是否保存配置供后续使用
  - 保不保存都可以，看个人需要



#### 3 启动项目



- 进入项目根目录

  ```bash
  cd vue3
  ```

  

-  启动

  - Mac系统加sudo

  ```bash
  sudo npm run serve
  ```

  

- 启动成功

  ```bash
  DONE  Compiled successfully in 8386ms 
  
  App running at:
    - Local:   http://localhost:8080/ 
    - Network: http://192.168.31.94:8080/
  ```

  - 更改项目文件夹需要在文件夹`显示简介-共享与权限`中给予文件夹及以下全部文件读写权限

#### 4 项目目录



- `package.json/package-lock.json`：精简版/全部版项目依赖包列表
  - `dependencies`：开发及上线都需要的依赖包
  - `devDependencies`：开发需要的依赖包

- `node_modules`目录：存储所有依赖包

  - "dependencies"，"devDependencies"列出的依赖包，以及这些依赖包自身运行还需要的依赖包

- `public`目录：

  - Index.html：默认首页
    - 每次编译webpack会自动将main.js内容引入Index.html中

- `src`目录：所有要写的代码都会在此目录下

  - `assets`目录：

  - `components`目录：子组件存放

  - `App.vue`：index核心vue

  - `Main.js`：新建vue实例，引入子组件，渲染App.vue并挂载到Index.html

    ```vue
    import Vue from(`vue`);
    import App from(`./App.vue`);
    //关闭生成提示
    Vue.config.productionTip = false;
    创建一个vue的实例对象
    new Vue({
    	//渲染方法，渲染App.vue文件中的内容放入内存
    	render: h => h(App),
    }).$mount(`#app`)//把渲染好内容放置到#app的标签内
    ```

    

- `.browserslistrc`:本项目针对浏览器配置
- `babel.config`：babel插件配置



### 单文件组件



- vue项目中，出现一种以`.vue`后缀的文件，这种文件称为单文件组件，即每一个文件都是一个组件
- 通过组件可以灵活复用，减少重复代码
  - 快速写vue布局插件，`vetur`，`Vue3 Snippets`



#### 组件使用



- Index.html

  - 每次编译index.html会引用main.js的内容

  ```vue
  <div id="app"></div>
  ```



- main.js

  ```vue
  //创建一个vue的实例对象
  import {
  	createApp
  } from 'vue';
  import App from './App.vue';
  
  createApp(App).mount('#app');
  
  //关闭生成提示
  Vue.config.productionTip = false;
  
  //创建一个vue的实例对象
  /* new Vue({
  	//渲染方法，渲染App.vue文件中的内容放入内存
  	render: h => h(App),
  }).$mount(`#app`) //把渲染好内容放置(挂载)到#app的标签内 */
  ```

  

- App.vue

  ```vue
  <template>
  	<div>
  		<!-- //template只接收一个子组件，所以最佳方式是用一个div包裹所有组件 -->
  		<h1>App.vue</h1>
  		<Test1></Test1><!-- //3 渲染子组件 -->
  		<Login></Login>
  		<a href="../public/login.html"></a>
  	</div>
  </template>
  
  <script>
  	//1 引入子组件
  	import Test1 from './components/basicCom/Test1.vue';
  	//2 配置注册子组件
  	export default {
  		components: {
  			Test1
  		}
  	}
  </script>
  ```

  

- 子组件-test1.vue

  ```vue
  <template>
  	<h2>子组件</h2>
  </template>
  ```

  

### 实例



- 每个 Vue 应用都是通过用 `Vue` 函数创建一个新的 **Vue 实例**开始的

```vue
<body>
		<script src="js/vue.js"></script>
		<script>
			var vm = new vue({
       //data值的类型只能是对象，或function方法，而方法return一个对象
        data: {}//function(){
        
        return {}
      }
      });//创建一个实例
		</script>
	</body>
```



#### data

- `data`用于保存当前Vue实例中所需要的所有数据,每一个组件都有data属性

- `data`值的类型只能是对象，或function方法，而方法return一个对象
- 对象内数据可以是任何数据类型：字符串，数字，对象，数组。。。
- 在后续学完“组件”后，`data`只能是返回对象的function方法
- `data`会将内部数据都加入到响应式系统中，当数据发生变化时，页面自动更新

```vue
<script>
			data: {
					num:100,
					msg:`hello world`
				}
				data:function(){
					return{
						num:100,
						msg:`hello world`
					}
				}
</script>
```



#### el

- element简写,属性为一个字符串，用于挂载目标的选择器

- `el`用于当前Vue实例挂载的作用目标或范围

  - 即定义的Vue实例内的`data`及其他方法作用在哪个标签节点范围
  - 注意：不要将<body>设置为挂载目标,因为Vue渲染后会将挂载目标替换掉

  ```vue
  <div id="app">
  			<div>1</div>
  		</div>
  		<div>2</div>
  
  <script>
  var vm = new vue({
  				el:`#app`,
    //说明此实例作用与<div id="app">，而内部子div也同样适用，但是div2则不适用
  				data: function() {
  
  					return {
  						num: 100,
  						msg: `hello world`
  					}
  				}
  			});
    </script>
  ```

  

### 模版语法



- vue中提供了`{{}}`进行数据动态渲染

  - `{{}}`中只可以写javascript表达式，简单理解为：**表达式有运行结果且只有一个结果**，如`map`就是可以使用，`if。。。else`不可以
  - `{{}}`只能在标签内容使用，不能在标签内容外使用

  ```vue
  <template>
  	<h1>hello,{{name}}</h1>
  </template>
  
  <script>
  	export default {
  		data() {
  			return {
  				name: `zhangsan`,
  				age: 20,
  				gender: `male`
  			}
  		},
  	}
  </script>
  ```

  - 三元表达式
  
    - condition ? result1 : result2
  
    ```vue
    <td>{{item.usergender=='男' ? item.usergender : item.usergender='女' }}</td>
    ```
  
    

### 事件绑定



- vue在标签中提供了`v-on:`来绑定事件
  - `ref`属性：标签中ref属性设置一个自定义值，而通过“$refs.自定义值”可以获得这个节点
    - “$refs”会获得一个对象

```vue
<button v-on:click="name=`lisi`">改名字</button>
	<button v-on:click="age++">加年龄</button>

<input type="text" ref="newnumber" v-on:blur="age=$refs.newnumber.value">
```



### 循环



- vue在标签中提供了`v-for:`来循环事件

  - v-bind:key必须是数字或对象，不可以是其他数据类型，且不能重复而且固定不变，所以index不能作为key
  - v-for可以遍历的数据类型：数字，数组，对象，字符串

  ```vue
  <div>
  		<h1 v-for="item in 5" v-bind:key="item">hello</h1>
  		<h1 v-for="item in friends" v-bind:key="item">{{item}}</h1>
  		<button v-for="(item,index) in friends" v-bind:key="item">{{item}}</button>
  	</div>
  <script>
  	export default {
  		data() {
  			return {
  				friends: [1, 2, 3, 4, 5]
  			}
  		},
  	}
  </script>
  
  <tr>
  			<td>编号</td>
  			<td>姓名</td>
  		</tr>
  		<tr v-for="(item,index) in friends">
  			<td>{{item.fid}}</td>
  			<td>{{item.name}}</td>
  		</tr>
  
  export default {
  		data() {
  			return {
  				friends: [{
  						fid: `01`,
  						name: `zhangsan`
  					},
  					{
  						fid: `02`,
  						name: `lisi`
  					},
  					{
  						fid: `05`,
  						name: `wangwu`
  					}
  
  				]
  			}
  		},
  	}
  ```

  

### 条件渲染



- vue在标签中提供了`v-if:`，`v-else-if`，`v-else`来控制标签的显示和隐藏，与原生javascript逻辑一致

  - v-if与v-for一起时，v-for优先级更高

  ```vue
  <template>
  	<div>
  		<button v-on:click="isshow=!isshow">切换显示</button>
  		<h1 v-if="isshow">是否渲染1</h1>
  		<h2 v-else-if="true">是否渲染3</h2>
  		<h1 v-else>是否渲染2</h1>
  	</div>
  </template>
  
  <script>
  	export default {
  		data() {
  			return {
  				isshow: true
  			}
  		}
  	}
  </script>
  ```

  

- `template`

  - 虚拟节点，在浏览器端不显示此标签，为了将一组标签一起操作更方便
  -  循环遍历的时候v-bind:key不能加在template标签上，应该加在真实标签上

  ```vue
  <template v-if="isshow">
  			<h1>123</h1>
  			<h1>123</h1>
  			<h1>123</h1>
  		</template>
  ```

  

### 指令



- Vue的标签里提供了以`v-`开头的特殊属性，称之为指令。**指令都是用在标签身上**，例如

  - `v-on`：绑定事件，简写为`@`

  - `v-for`：循环遍历

  - `v-if`,`v-else`,`v-else-if`：条件判断

  - `v-test`：标签赋值渲染，会把标签原本内容覆盖

    ```vue
    <template>
      <h1 v-text="name">我叫</h1>//会把“我叫”覆盖
    </template>
    
    <script>
    export default {
    data() {
        return {
            name:`zhangsan`
        }
    },
    }
    </script>
     
    ```

    

  - `v-html`：标签赋值渲染，会把标签原本内容覆盖，可以解析html标签

    ```vue
    <template>
      <h1 v-html="name"></h1>
      
    </template>
    
    <script>
    export default {
    data() {
        return {
            //name:`zhangsan`
            name:`<a href="">zhangsan</a>`
        }
    },
    }
    </script>
    
    ```

    

  - `v-show`：控制元素是否显示，显示隐藏切换频繁时用此指令，不频繁还是用`v-if`

    ```vue
    <h1 v-show="false">v-show</h1>//false时不显示，但前端还会渲染，只是多了一个display：none
    
    <button v-show="isshow" @click="isshow=!isshow">显示/隐藏</button>
    <script>
    export default {
    data() {
        return {
            //name:`zhangsan`
            name:`<a href="">zhangsan</a>`,
            isshow:true
        }
    },
    }
    </script>
    ```

    

  - `v-bind`：动态绑定一个多个属性，简写：“:”，如`v-for`，key绑定多个不同值或者为变量

    - 即如果希望标签自带原生属性的**值**为变量或不固定，需要在这些原生属性前加`v-bind`
    - 特殊情况：当绑定属性值为本地相对路径时，需要在属性值前加上`Require`；但如果是网络绝对地址则不需要，因为webpack编译机制导致

    ```vue
    <a v-bind:href="link">url</a>
    
    <script>
    export default {
    data() {
        return {
            //name:`zhangsan`
            name:`<a href="">zhangsan</a>`,
            isshow:true,
            link:`http://www.baidi.com`
        }
    },
    }
    </script>
    
    <img :src="logo" alt="">//<img :src="require(`../../assets/logo.png`)" alt="">
    logo:require(`../../assets/logo.png`)
    
    ```

    

### 样式



#### 静态样式



- 默认作用所有组件，即全局样式

  

- 作用于当前组件:`scoped`

  - 原理：给当前组件添加一个自定义属性，而后设置自定义属性的css值

  ```vue
  <style scoped>
  h1{
      color: red;
  }
  </style>
  ```

  

- 引入css

  ```vue
  //引入全局样式，即使设置scoped
  <style scoped>
  @import "./basic.css";
  </style>
  
  //引入组件内部样式
  <style scoped src="./basic.css">
  </style>
  ```

  

#### 动态样式



- 添加动态属性到标签
  - class加v-bind变为动态
  - 属性名变为对象{属性名：true/false}，可以添加多个class，对象里用逗号隔开，class属性值为布尔型

```vue
<template>
<div>
 <h1 :class="{red:isred,bigfont}">样式</h1>
  <button @click="isred=!isred,bigfont=!bigfont"></button>
</div>
 
</template>

<script>
export default {
data() {
    return {
        isred:true,
        bigfont:true
        
    }
},
}
</script>

<style>
/* @import "./basic.css"; */
.red{
    color: red;
}
.bigfont{
    font-size: large;
}
</style>
```



- 内连样式

  ```vue
   <h2 :style="{color:colorred}">内连样式</h2>
  <script>
  export default {
  data() {
      return {
          isred:true,
          bigfont:true,
          colorred:`red`
          
      }
  },
  }
  </script>
  ```

  

- 数组

  ```vue
  <h1 :class="[colorclass,fontclass]">数组样式</h1>
  
  data() {
      return {
          colorclass:"red",
          fontclass:"bigfont"
          
      }
  }
  
  <style>
  .red{
      color: red;
  }
  .bigfont{
      font-size: large;
  }
  </style>
  ```

  

### 事件处理



- `methods`

  - `methods`中想要使用`data`中的数据变量或调用`methods`的其他函数，前面都需要加上`this.`

  ```vue
  <template>
    <div>
      <button @click="sayhello"></button>
    </div>
  </template>
  
  <script>
  export default {
  data() {
      return {
          name:`zhangsan`
      }
  },
  methods: {
      sayhello(){
          console.log(this.name)；
          this.sayhi();
      },
      sayhi(){
          console.log(`hi`);
      }
  },
  }
  </script>
  
  ```

  

  - 事件修饰符

    - `event.preventDefault()`:`事件.prevent`，阻止标签默认事件

    ```vue
    <a href="http:www.baidu.com" @click.prevent="sayhello">link</a>
    ```

    - `event.stopPropagation()`:`事件.stop`，阻止冒泡

    - 可以串联，也可以单独使用不触发事件

       ```vue
       <a @click.stop.prevent="doThat"></a>
       <a @click.stop.prevent></a>
       ```

      

  - 按键修饰符

    - 输入内容按回车触发事件
    - 不止回车，tab，esc。。。都可以

    ```vue
    <input @keyup.enter="submit" />
    submit(){
            console.log(`enter`)
        }
    ```

    

  - 事件传递参数

    ```vue
    <button @click="sayhi(`lisi`)"></button>
    
    methods: {
        sayhi(param){
            console.log(`hi`+param);
        }
    },
    ```

    - 事件对象
      - vue在绑定事件时，没有加“（）”，事件处理函数默认第一个参数获取到的就是事件处理对象，即`event`
      - 如果有“（）”，或者传了参数，还想获取事件对象，则需要传参数多加一个`$event`

```vue
<button @click="sayhi"></button>

methods: {
    sayhi(event){
        console.log(event);//拿到事件对象
    }
},

<button @click="sayhi(`lisi`,$event)"></button>

methods: {
    sayhi(param,event){
        console.log(`hi`+param);
    }
},
```



### 计算属性



- 使用场景：使用源数据得出一个新数据，一般考虑使用计算属性
- 每一个vue组件都有`computed`属性
- 一个方法（函数），返回一个结果，结果可以拿来用在模版区域，`{{}}`,或`v-if`。。。
- 计算属性会依赖一或多个源数据，在源数据基础上计算得到一个新数据
- 计算属性对源数据使用不会改变源数据
- 首次执行，而后只要源数据发生变化就会重新执行
- 计算属性具有缓存功能，源数据不变，多次使用计算属性只会执行一次

```vue
<template>
  <div>
    <label for="">{{fullname}}</label>
  </div>
</template>

<script>
export default {
data() {
    return {
        firstname:`zhang`,
        lastname:`san`
    }
},
computed:{
    fullname:function(){
     return this.firstname+this.lastname
    } 
    
}
}
</script>

```

- 计算属性的`set`

  - 每一个计算属性都有一个`get`方法，相当于完整写法

    ```vue
    computed:{
        fullname:{
            get(){
                return this.firstname+this.lastname
            }
        }
        
    }
    ```

    - 计算属性默认无`set`方法，如果希望修改计算属性结果，需要手动添加`set(param)`方法获取到要修改的值，然后`set`中更改源数据具体值

      ```vue
       <button @click="fullname=`li`"></button>
      
      computed:{
          fullname:{
              get(){
                  return this.firstname+this.lastname
              },
              set(param){
                  this.firstname=param[0],
                  this.lastname=param[1]
              }
          }
          
      }
      ```

      

### 侦听器



#### 基础语法



- 每一个组件都有一个`watch`属性，用来设置组件的侦听器，与`data`，`methods`，`computed`同级

  ```vue
  export default{
  watch:{
   侦听数据名(newvalue,oldvalue){接收两个参数：变化后的值，变化前的值
  //侦听数据发生变化
  }
  }
  }
  
  <template>
   <div>
       <h1>{{num}}</h1>
    <button @click="num++"></button>
   </div>
  </template>
  
  <script>
  export default {
  data() {
      return {
          num:1
      }
  },
  watch:{
      num(){
          console.log(`num change`)
      }
  }
  }
  </script>
  
  <style>
  
  </style>
  ```

  

#### 侦听引用类型数据



- 默认情况下`watch`无法侦听到饮用数据类型内部变化，只有引用类型地址发生变化，`watch` 对应的侦听函数才会执行，例如：数组和对象内的数据发生变化，侦听器内函数无法执行

  ```vue
  <h1>{{students.age}}</h1>
    <button @click="students.age++">addage</button>
  
  watch:{
      students(){
          console.log(`students change`)//无法执行console.log,因为students数据地址并没改变
      }
  }
  ```

  

- 如何解决

  

  - 单独侦听某个属性

    ```vue
    watch:{
        num(){
            console.log(`num change`)
        },
        "students.age"(){//对象内键都是字符串，可以省略引号，但当键内有特殊符号，如“.”"-"这些就不能省略；如果键是一个变量，需要加[]
            console.log(`students change`)
        }
    }
    ```

    - 对象内键都是字符串，可以省略引号，但当键内有特殊符号，如“.”"-"这些就不能省略；
    - 如果键是一个变量，需要加`[]`

    

  - 深度侦听

    ```vue
    watch:{
        students:{//students 变为一个对象
            handler(){//handler为真正侦听函数
                console.log(`深度侦听`)
            },
            deep:true//深度侦听
        }
    }
    ```

    

#### 立即侦听



- 默认侦听器在页面首次进入不会执行，只会在数据发生变化执行，如果希望在页面首次刷新时执行，可以设置立即侦听

  ```vue
  students:{
          handler(){
              console.log(`深度侦听`)
          },
          immediate:true//立即侦听
      }
  ```

  

### 表单处理



- 双向数据绑定：`v-model`绑定一个数据变量，获取输入框的值只要获取绑定数据变量即可

  ```vue
  //input-text
  <div>
      <h1>{{msg}}</h1>//输入框输入内容变化，此处也会实时跟着变化
      <input type="text" v-model="msg">
    </div>
  
  data() {
      return {
          msg:`model value`
      }
  },
  
  //input-radio
  <h1>{{gender}}</h1>
      <input type="radio" v-model="gender" value="male"><label for="male">male</label>
      <input type="radio" v-model="gender" value="female"><label for="female">female</label>
  
  data() {
      return {
          gender:`male`
      }
  },
  
  //radio-checkbox-布尔型
   <h1>{{agree}}</h1>
      <input type="checkbox" v-model="agree"><label for="">同意以上协议</label>
  
  data() {
      return {
          agree:false
      }
  },
  
  //radio-checkbox-多选型
  <h1>{{habit}}</h1>
      <input type="checkbox" v-model="habit" value="sports"><label for="">sports</label>
      <input type="checkbox" v-model="habit" value="travle"><label for="">travel</label>
      <input type="checkbox" v-model="habit" value="movie"><label for="">movie</label>
  
  data() {
      return {
          habit:[]
      }
  },
  
  //select
  <h1>{{city}}</h1>
      <select v-model="city">
          <option value="beijing">beijing</option>
          <option value="shanghai">shanghai</option>
          <option value="tianjin">tianjin</option>
      </select>
  
  data() {
      return {
          city:``
      }
  },
  ```

  

  #### v-model常用修饰符
  
  
  
  - `.lazy`：失去焦点后触发数据同步
  
    ```vue
    <input type="text" v-model.lazy="msg">
    ```
  
    
  
  - `.number`：使用`parseFloat`处理
    - 输入内容转数字输出，如果转不了会保留数字部分，其余不会同步
    - 如果输入内容都为不能转数字的，会原值输出
  
  - `.trim`：自动处理首尾空格



### 数据变化监测



- 在Vue中，把数据设置在data中，Vue把data加载到响应式系统中。后续使用中，Vue内部会实时监测data中数据的变化，一旦发生变化，Vue会自动更新页面，此更新与`watch`无关

- 有几种特殊情况操作数据时Vue内部无法检测到，当数据发生改变后页面不会主动更新

  

#### 对象

- 对于对象属性的**新增**和**删除**无法检测

- **vue3以上版本无此情况，之前vue2及更早可以通过其他语法来实现**

  ```vue
  //旧版本页面无法更新
  <h1>{{ students }}</h1>
      <button @click="add">add</button>
  
   data() {
      return {
        students:{
  name: `zhangsan`
        } ,
      };
    },
    methods: {
      add(){
          this.students.age=20;
          delete this.students.name;
          console.log(this.students)
      }
    },
  
  //旧版本解决方法
  
   methods: {
      add(){
          this.students={
              ...students,
              age:20
          };//方法一
   this.$set(this.students,`age`,20);//方法二
   Object.assign({},this.students,{age:20})//方法三，把后面多个对象内的属性合并到第一个对象并返回第一个对象
          delete this.students.name;
          console.log(this.students)
      }
    },
  ```

  

#### 数组

- 对于数组的**长度**和**下标**操作无法检测

  ```vue
   data() {
      return {
        person:[`lisi`,`wangwu`]
      };
    },
  
  methods: {
      shuzu(){
          this.person[0]=`zhao`;//针对下标vue2以下无法实现数据检测
          this.$set(this.person,0,`zhao`)//解决方案1
          this.person.length=0;//清空数组针对长度vue2以下无法实现数据检测
          this.person.splice(0);//解决方案
      }
    },
  ```

  

### 生命周期函数



- 在组件的生命过程中，Vue在组件不同生命阶段设置了不同的函数，当组件到达某个生命阶段时会触发响应函数

  ```vue
  <template>
    <div>
      <h1>生命周期函数</h1>
      <button @click="num++">{{num}}</button>
      <button @click="$destroy()">destroy</button>
    </div>
  </template>
  
  <script>
  export default {
      data() {
          return {
              num:1
          }
      },
      //创建阶段
  beforeCreate() {
      console.log(`创建前执行`)
  },
  created() {
      console.log(`创建完成执行`)
  },
  //挂载阶段，创建好的组件渲染到页面中
  beforeMount() {
      console.log(`挂载前执行`);
  },
  mounted() {
      console.log(`挂载完成执行`);
  },
  //组件更新阶段，组件用到的数据发生变化才会执行,如上面例子，只有点击button时才会触发
  beforeUpdate() {
      console.log(`组件更新前执行`);
  },
  updated() {
      console.log(`组件更新完成执行`);
  },
  //组件销毁阶段，销毁完成后之前更新将不再执行
  beforeDestroy() {
      console.log(`组件销毁钱执行`)
  },
  destroyed() {
      console.log(`组件销毁完成执行`)
  },
  }
  </script>
  
  <style>
  
  </style>
  ```

  

- 常用

  - `created`，用于加载网络请求，因为在之前无法获取`data`中的数据

    - 在页面渲染之前，最早可以获取的时间点
    - 当然在`mounted`加载也可以

    - 在vue3中`created`被取消，只能在`mounted`发送网络请求



- 子组件

  - 父组件引入

    ```vue
    <Child></Child>
    <script>
    import Child from './Child';
    export default {
        components:{
            Child
        },
    ```

    

  ```vue
  <template>
    <div>
      <h1>生命周期函数</h1>
      <button @click="num++">{{num}}</button>
  
      <Child></Child>
    </div>
  </template>
  
  <script>
  import Child from './Child';
  export default {
      components:{
          Child
      },
      data() {
          return {
              num:1
          }
      },
      //创建阶段
  beforeCreate() {
      console.log(`child创建前执行`)
  },
  created() {
      console.log(`child创建完成执行`)
  },
  //挂载阶段，创建好的组件渲染到页面中
  beforeMount() {
      console.log(`child挂载前执行`);
  },
  mounted() {
      console.log(`child挂载完成执行`);
  },
  //组件更新阶段，组件用到的数据发生变化才会执行,如上面例子，只有点击button时才会触发
  beforeUpdate() {
      console.log(`child组件更新前执行`);
  },
  updated() {
      console.log(`child组件更新完成执行`);
  },
  //组件销毁阶段，销毁完成后之前更新将不再执行
  beforeDestroy() {
      console.log(`child组件销毁钱执行`)
  },
  destroyed() {
      console.log(`child组件销毁完成执行`)
  },
  }
  </script>
  
  <style>
  
  </style>
  ```

  

  - 父组件加载时，在父组件的`mounted`之前加载子组件的前四步，即：`beforeCreate`，`create`，`beforeMount`，`mounted`
  - 父子组件更新，各自根据数据变化更新，互相不影响
  - 父组件销毁前，子组件执行销毁，完成后父组件执行销毁；子组件销毁不影响父组件



### Prop



- 父组件向子组件传值

  - 父组件

    - 如果想传过去的值不为字符串，需要在属性前加`:`，以保证子组件接收值的数据类型正确
    - 子组件只能使用父组件传过来的数据，不能修改

    ```vue
    <template>
      <div>
        <h1>父组件</h1>
        <Child :name='name' :age='20' :bool='true'></Child>
      </div>
    </template>
    
    <script>
    import Child from './Child.vue';
    
    export default {
    components:{
        Child
    },
    data() {
        return {
            name:`zhangsan`
        }
    },
    
    }
    </script>
    
    <style>
    
    </style>
    ```

    

  - 子组件

    - 以数组形式接收，可以不全部接收

    ```vue
    <template>
      <div>
        <h2>子组件</h2>
        <p>你好{{name}},年龄{{age}}</p>
      </div>
    </template>
    
    <script>
    
    
    export default {
     props:[`name`,`age`],
    }
        
    
    </script>
    
    <style>
    
    </style>
    ```

    

- 验证

  - 以对象形式接收数据

  ```vue
  export default {
   //props:[`name`,`age`],
   props:{
    name:String,
    age:Number//也可以在前端渲染，但是会在浏览器控制台报错
    //[Number,String]，可以接收多个数据类型，以数组形式
    gender:{
      required:true//必传属性，也可以在前端渲染，但是会在浏览器控制台报错
    }
    gender:{
      default:`male`//设置默认值，如果不传，用默认值，
    },
   friends:{
      default:function(){
      return {}//[]如果默认值时数组或对象，必须以函数返回值形式设置
   },
   classname:{
      validator:function(value){
          //自定义验证规则，value是父组件classname传过来的值,返回布尔值表示是否通过验证
          return //返回true false
      }
    }
  }
  ```

  

### 自定义事件



- 父组件自定义事件(方法，函数)，供子组件调用

  - 父组件

    ```vue
    <Child @fatherevent="sayhello"></Child>
    
    methods: {
      sayhello(){
        console.log(`父组件hello`)
      }
    },
    ```

    

  - 子组件

    ```vue
    子组件直接调用 
    <button @click="$emit(`fatherevent`)">子组件触发父组件事件</button>
    
    //子组件js调用
    <button @click="childevent">子组件js调用</button>
    methods: {
      childevent(){
        this.$emit(`fatherevent`)
      }
     },
    ```

    

- 应用场景

  - 子组件要修改父组件数据

    - 例如：点击子组件某个元素能够修改父组件中数据

      ```vue
      //父组件
      <Child @add="add"></Child>
      methods: {
        add(){
          this.num++
        }
      },
      
      //子组件
      <button @click="add"></button>
      methods: {
        add(){
          this.$emit(`add`)
        }
       },
      ```

      

  - 子组件给父组件传值

    ```vue
    //父组件
    <Child @add="add"></Child>//这里父组件add方法不要带参数
    data() {
        return {
            num:1
        }
    },
    methods: {
      add(param){
        this.num+=param
      }
    },
    //子组件
    button @click="add">子组件传值给父组件</button>
    methods: {
      add(){
        this.$emit(`add`,10)
      }
     },
    ```

    

### 事件总线



- 场景：非父子组件自定义事件调用传值

  -  vue3已经去除事件总线模块，需要手动下载mitt包

    ```vue
    npm install mitt --save
    ```

    

- 配置：

  - 添加bus.js

    ```vue
    import mitt from 'mitt';
    export const bus = mitt();
    ```

    

  - 抛出组件

    ```vue
    <template>
      <div>
        <button @click="add">bus+1</button>
      </div>
    </template>
    
    <script>
    import { bus } from "./bus";//必须引入bus.js且bus名与bus.js暴露的变量名一致
    
    export default {
      methods: {
        add() {
          bus.emit("add");//抛出时this替换为bus
        },
      },
    };
    </script>
    
    <style>
    </style>
    ```

    

  - 接收组件

    ```vue
    <template>
      <div>
        <p>{{num}}</p>
      </div>
    </template>
    
    <script>
    import {bus} from './bus';//必须引入bus.js且bus名与bus.js暴露的变量名一致
     
    export default {
    data() {
        return {
            num:1
        }
    },
    mounted() {
      //将函数挂载在事件总线，mounted时载入但不执行，需要在抛出组件触发此事件时执行
        bus.on('add',()=>{
           this.num++//此处this如果在箭头函数下则无问题，像function(){}普通函数写法下this指向会出错
        })
    },
    }
    </script>
    
    <style>
    
    </style>
    ```

    

### 动态组件&keepalive



- `component`

  - 未切换的组件会被销毁，点击重新创建
  - `component`标签加在`keep-alive`标签中，未切换的组件不会被销毁，生命周期函数还存在，并在第一次切换进入时创建

  ```vue
  <template>
    <div>
  <div>
      <button @click="currenttab='TabA'">TabA</button>
       <button @click="currenttab='TabB'">TabB</button>
        <button @click="currenttab='TabC'">TabC</button>
  </div>
  <div>
      <keep-alive>
       <component :is='currenttab'></component>
      </keep-alive>
     
  </div>
    </div>
  </template>
  
  <script>
  import TabA from './TabA.vue'
  import TabB from './TabB.vue'
  import TabC from './TabC.vue'
  export default {
  components:{
  TabA,TabB,TabC
  },
  data() {
      return {
          currenttab:TabA 
      }
  },
  }
  </script>
  
  <style>
  
  </style>
  ```

  

  - `keep-alive`组件中的标签还新增两个属性，`activated`,`deactivated`，可配合需求在切换进入和离开时设置响应代码

    ```vue
    <template>
      <div>
        <h1>TabA</h1>
      </div>
    </template>
    
    <script>
    export default {
    activated() {
        console.log(`激活`)
    },
    deactivated() {
        console.log(`挂起`)
    },
    }
    </script>
    
    <style>
    
    </style>
    ```



- 设置是否缓存

  - `include`，设置需要缓存的组件，其余都不缓存，支持正则表达式表示多个组件`:include=`

  -  `exclude`，设置不需要缓存的组件，即除了设置的组件外都需要缓存，支持正则表达式表示多个组件`:include=`

    ```vue
    <keep-alive include="TabA" exclude="TabC">//:include="/TabA|TabC/"正则表达式缓存多个
         <component :is='currenttab'></component>
        </keep-alive>
    ```

    

### 插槽



- 父组件给子组件传递数据，组件，节点

  - 父组件

    ```vue
    <template>
      <div>
    <Child>
        <p>this is for childslot</p>
       <template v-slot:slot1>
            <p>this is for childslot1</p>
        </template>
         <template v-slot:slot2>
            <p>this is for childslot2</p>
        </template>
    </Child>
      </div>
    </template>
    
    <script>
    import Child from './Childslot.vue';
    export default {
    components:{
        Child
    }
    }
    </script>
    
    <style>
    
    </style>
    ```

    

  - 子组件

    - <slot>标签内会显示父组件渲染<child>标签内的所有内容
    - <slot>可以设置默认值，如果父组件没有传值时显示默认值，父组件传值后默认值不显示
    - 命名slot：子组件多个插槽，需要通过`name`属性命名区分，在父组件通过将传给不同<slot>的内容用<template>包裹，在<template>标签通过`<template v-slot:插槽名>`来区分传递

  ```vue
  <template>
    <div>
      <h1>子组件</h1>
      <slot>
     <p>this is for default</p>//插槽默认值
    </slot>
      
      
       <slot name="slot1"></slot>//具名插槽
      <hr>
       <slot name="slot2"></slot>
      
      
    </div>
  </template>
  
  <script>
  export default {
  
  }
  </script>
  
  <style>
  
  </style>
  ```

  

- 作用域插槽

  - 当渲染的数据在子组件中，渲染的节点在父组件中，通过作用域插槽将子组件数据传给父组件而后再在子组件<slot>处渲染出来展示

  - 父组件

    - 通过`v-slot=''`得到一个对象{stu:[...]}，其中stu是子组件通过自定义属性设置的属性名，后面的值为属性值。
      - 例子中子组件数据为一个数组，此处为了使用方便将接收到的数据结构后使用，也可以直接定义一个变量接收
    - 如果作用域插槽设置名字，与作用域不冲突：直接子组件设置`name`属性，父组件`v-slot:name值="变量接收子组件自定义属性名"`
    - 简写：`v-slot:`可以简写成`#`
    - 注意：插槽子组件可以**通过自定义属性向父组件传递数据**

    ```vue
    <template>
      <div>
    <Child>
        <template  v-slot='{stu}'>
             <ur>
            <li v-for="item in stu" :key="item.id">{{item.name}}</li>
        </ur>
        </template>
       
    </Child>
    <Child>
     <template  v-slot:slot1='{stu}'>
             <ol>
            <li v-for="item in stu" :key="item.id">{{item.name}}</li>
        </ol>
        </template>
    </Child>
      </div>
    </template>
    
    <script>
    import Child from './Childslot.vue';
    export default {
    components:{
        Child
    }
    }
    </script>
    
    <style>
    
    </style>
    ```

    

  - 子组件

    ```vue
    <template>
      <div>
        <h1>子组件</h1>
         <slot name='slot1' :stu='stu'></slot>
      </div>
    </template>
    
    <script>
    export default {
        data() {
            return {
                 stu: [
            { id: 1, name: `牟佳斌`, age: 41, gender: `男`, isshow: true },
            { id: 2, name: `牟彦丞`, age: 10, gender: `男`, isshow: true },
            { id: 3, name: `张秦宁`, age: 36, gender: `女`, isshow: true },]
            }
        },
    
    }
    </script>
    
    <style>
    
    </style>
    ```

    

### axios



#### 安装下载



- 项目根目录执行

  ```
  npm i axios
  ```

  

#### 使用



- 任何文件需要使用都需要引入axios

  ```vue
  import axios form 'axios'
  ```

  

- 发送请求

  - 在生命周期函数`created`或`mounted`内使用请求

  ```javascript
  export default {
  creaded(){
     asyac getstudata(){
               const res=await axios({
                          url:'http://'
                          method:'GET'
                          param：{
                                  _id=1,
                                 }；
  }
  }
  }
  
  ```

  - `url`：资源地址
  - `method`:请求类型，例如get，post，put，delete，大小写不区分，通常习惯大写
  - `params`：请求类型为get时发送参数
  - `data`：请求类型不是get时发送参数

- 返回结果

  - axios返回一个`promise`对象

  - 可以用`then()`接收返回对象数据`res.data`，`res`为整个返回对象

    ```javascript
    getstudata(){
                 const data=axios({
                            url:'http://'
                            method:'GET'
                            params：{
                                     _id=1,
                                    }).then((res)=>{
                                                 console.log(res.data)                                                                                        })；
    }
    ```

    

  - 也可用异步函数`await`和`async`接收，如上面代码，`res.data`为返回数据

    ```javascript
    asyac getstudata(){
                       const res=await axios({
                                 url:'http://'
                                 method:'GET'
                                 params：{
                                          _id=1,
                                         }；
                                 console.log(res.data)
    }
    ```

    

### axios封装



#### 提取基础路径



- 将axios请求url中的基础路径提取出来,后续再发送请求时不需要带上基础路径

  - 在`main.js`中引入axios并配置
  - 注意：此配置每个页面中还是需要引入axios

  ```javascript
  import axios from 'axios';
  axios.defaults.baseURL='http://...:3000'
  ```

  

### API封装



- 将项目中所有axios请求都集中到一起管理

- 操作步骤：

  - 在`src`目录下创建`http`目录，http可以自己命名

  - `http`目录下创建`moudule`目录，目录下创建不同js文件，存放不同数据请求

    - 考虑到服务端接口一级路径,如：students，classes，users。。。，每个js文件也按照这个逻辑创建

    - `students.js`

      ```javascript
      import axios from 'axios';
      const studentsapi={
        getstu(params){
          return axios({
            url:'/students/getstudents'
      method:'GET'
      params：params；
          })
        },
        addstu(){},
        deletestu(){}
      }
      export default studentsapi
      ```

      

  - `http`目录下创建`api.js`，用于`moudule`下所有请求进行汇总

    ```javascript
    import students from './moudules/students.js';
    import classes from './moudules/classes.js';
    const api={students,classes }
    export default api
    
    ```

    

- 具体页面请求

  ```vue
  <template>
    <div>
      <p>axios</p>
    </div>
  </template>
  
  <script>
  import api from '../../../src/http/api';
  export default {
  created() {
    this.getindexdata()
  },
  methods: {
    async getindexdata(){
        const res=await api.index.get();
        console.log(res);
    }
  },
      /* axios({
          url:'/index/get',
          method:'GET',
      }).then((res=>{
          console.log(res);
      })) */
  }
  </script>
  
  <style>
  
  </style>
  ```
  
  - 进一步优化，将`api`挂载到全局，在`main.js`引入`api`
  
  ```javascript
  import api from './http/api.js';
  app.config.globalProperties.$api = api;//将api对象添加Vue的$api属性上
  ```
  
  - 具体页面请求不需要在每个都引入`api`,只是每个页面请求都变为
  
    ```javascript
    this.$api.students.getstu()
    ```
  
    
  
  - 获取结果
  
    - 可以通过参数传递控制分页等，在`students.js`接收参数
  
    ```javascript
     const res=await this.$api.students.getstu(params)
    ```
  
    

## Vue 全家桶



- 除了Vue.js，Vue 配套了路由（Vue Router）和状态管理模式（VueX），这三个称之为全家桶



### 创建项目



- 按照之前项目安装流程，安装`Vue.js`及`cli`



#### 安装插件

- 到安装模式时选择手动安装，并选择`Babel`,`Router`,`VueX`,`CSS Pre-processors`四个插件



#### 路由历史模式

- 选择<no>，<yes>或<no>都可以，后期代码可改



#### css预处理器

- 选择 `Sass/SCSS(with dart-sass)`



#### 插件配置代码位置

- 都可以，单独或放在`packege.json`都可以



### 路由和SPA



#### SPA

- 单页面应用（Simple Page Application），整个应用程序只有一个`.html`页面



#### 前端路由

- 用来管理浏览器的url和页面组件之间的关系：通过对前端路由的配置来决定哪个url显示哪个组件



##### 旧项目安装路由（vue router）

- 项目根目录执行命令：

  ```bash
  vue add router
  ```

  - 该命令会自动下载路由需要的依赖包，同时会在项目目录中自动生成基础的路由配置及代码，但如果`npm i router`不会自动创建配置及代码



#### 创建前端路由



- `router/index.js`

  ```vue
  const routes = [];
  
  const router = createRouter({
    history: createWebHashHistory(),
    //路由配置
    routes:routes//简写为routes
  })
  
  export default router
  ```

  

  - 路由信息对象

    ```vue
    const routes = [
      {
        //路由信息对象
      path:'/',
      component:Home
      },
      {
        path:'/login',
        component:Login
        },
        {
          path:'/reg',
          component:Reg
          },
    
     
    ]
    ```

    - `path`:路由对应浏览器URL路径

    - `name`:路由名称，可以不填写

    - `component`:路由对应组件名称

      

- `main.js`

  ```vue
  //引入路由实例对象
  import router from './router'//完整写法：import router from './router/index.js'
  
  //后续在组件中通过this.$router获取此实例对象
  createApp(App).use(store).use(router).mount('#app')
  ```

  

- 路由模块渲染

  - `App.vue`

  ```vue
  <template>
  <div>
    <!--路由出口：当前路由组件渲染位置  -->
    <router-view>
  
    </router-view>
  </div>
  </template>
  ```

  

- 路由跳转

  

  - 标签跳转

    - Safari浏览器报错，但跳转有效，检查为迅雷插件问题，卸载后无问题
    - Chrome正常无问题

    ```vue
    <router-link to='/login'>去登陆</router-link>
    ```

    

  - JS跳转

    ```vue
    <router-view>
        <h1>首页</h1>
        <button @click="reg">去注册</button>
    </router-view> 
      
      export default {
        methods: {
            reg(){
                this.$router.push('/reg');
            }
        },
    }
    ```

    

#### 路由其他配置



- 路由懒加载

  - 如下例，只有当浏览器`url`匹配到`/login`时才会加载
    - 而<import Home from '../views/home/Home>是只要index.js被引用时就会加载

  ```vue
  component: () => import('../views/login/Login')
  
  const login=() => import('../views/login/Login')
  {
  path:'/login'
  component: login
  }
  
  
  {
      path: '/login',
      component: () => import('../views/login/Login')
      },
  ```

  - 页面使用频率低选择使用懒加载

    

- 路由重定向

  ```vue
   path:'/home',
   redirect:'/'
  ```

  - 浏览器访问`url`会被重定向到`redirect`地址

  - 一般写在路由信息对象第一个

    

- 通用路由

  ```vue
   path:'*',//vue2
   path:'/:pathMatch(.*)*',//vue3
   component:'/'
  ```

  - 浏览器访问`url`错误时，通配到指定页面

  - 一般写在路由信息对象最后一个

  - 一般用在404页面

    

- 路由模式

  

  - history模式

    - 连接hash前不再带有`#`
    - 打包上线时后端需要做额外配置

    ```vue
    import { createRouter, createWebHashHistory, createWebHistory } from 'vue-router'
    
    const router = createRouter({
      routes: routes,
      mode:'history'//vue2,默认为hash模式，加了mode：'history'为历史模式
      history: createWebHistory()//vue3历史模式
    })
    ```

    

  - hash模式：默认

    ```vue
    import { createRouter, createWebHashHistory, createWebHistory } from 'vue-router'
    
    const router = createRouter({
      routes: routes,
      history: createWebHashHistory()//vue3 hash模式
    })
    ```

    

#### 嵌套路由



- 创建

  - 创建好需要引入的子路由组件并在index.js引入
    - 需要注意的是需要子路由的通常会认为是页面，放在框架的`views`文件夹中，不放在`components` 文件夹中

  - 子路由路径不需要`/`，因为`/`表示根目录
  - 在一级路由下添加`children:[]`，`[]`内创建路由
    - 属性与一级路由属性一样，包含`path`,`name`,`component`或箭头函数懒加载

```vue
const routes = [
  {
    path: '/',
    redirect: '/home'
  },
  {
    path: '/home',
    component: Home,
    children:[
      {
        path:'stulist',
        component:Stulist
      },
      {
        path:'stuadd',
        component:Stuadd
      },
    ]
  },
  {
    path: '/login',
    component: login//() => import('../views/login/Login')
  },
  {
    path: '/reg',
    component: Reg
  },
  {
    path: '/:pathMatch(.*)*',
    component: err
  }
]
```



- 渲染

  ```vue
  <section>
          <router-view></router-view>
        </section>
  ```

  - 在父路由的vue上通过<router-view>渲染出来

    

- 跳转

  ```vue
  <dd><router-link to='/home/stuadd'>新增学生</router-link></dd>
            <dd><router-link to='/home/stulist'>学生列表</router-link></dd>
  ```

  - 跳转时子路由路径需要带上父路由



#### 动态路由



- 路由的路径中，有一部分是不固定的动态的，不管动态部分如何变化，指向的都是同一路由

  - 例如修改学生

    ```vue
    /home/editstu/001
    /home/editstu/002
    ```

    - 001，002是动态部分，可以用来传递参数



- 创建动态路由

  - `Index.js`中`component`对应的vue后面添加`:动态名称`

  ```vue
  {
          //:id为动态路由，匹配动态部分
          path:'stuedit/:id',
          component:Stuedit
        },
  ```

  

- 渲染动态路由

  - `:to`表示后面为动态
  - 跳转路径需要动态拼接

  ```vue
  router-link :to='"/home/stuedit/"+item._id'>
  
  router-link :to="‘/home/stuedit/${item._id}’“>
  ```

  

- 获取动态路由参数

  - 在路径页面通过`$route`获取
    - `$route`获取的是路由的**信息对象**，`$router`获取的是路由的**实例对象**

  ```vue
  created() {
      console.log(this.$route.params)
  },
  ```

  - 在路径页面通过`props`获取

    - 在路由配置时添加`props:true`

      ```vue
       {
              path:'stuedit/:id',
              component:Stuedit,
              props:true
            },
      ```

      

    - 在路径页面通过`props`获取

      ```vue
      props:['id'],
      created() {
          //console.log(this.$route.params)
          console.log(this.id)
      },
      ```

      

#### 路由扩展



- <router-link>

  | 属性         | 说明                                                         | 代码样例                                                     |
  | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | tag          | 渲染的标签，vue3不支持                                       | <router-link tag="button" :to='"/home/stuedit/"+item._id'>编辑</router-link> |
  | active-class | 设置被选中<router-link>的样式，"active"样式自己在下面设置即可 | <router-link active-class="active" to='/home/stuadd'>新增学生</router-link> |
  | replace      | 当前连接跳转新页面，浏览器不会有回退，即原页面无历史记录     | <router-link to='/home/stuadd' :replace="true">新增学生</router-link> |

  

- 路由跳转

  - 通过路由名称跳转

    ```html
    //html
    <router-link :to='{name:"stuadd"}'>新增学生</router-link>
    
    //js
    this.$router.push({name:"stuadd"})
    ```

    - 用路由名称可以不需要带上父级路由path，直接用子路由的`name`即可
    - `to`前面加`:`

    

- 路由传参

  - `query`

    - 传递
      - 配置路由不需要做任何更改，比如：http://localhost:8080/home/editstu?id=001,还是会进入http://localhost:8080/home/editstu这个路由

    ```html
    //html
    
    <router-link to="/home/editstu?id=001">新增学生</router-link>
    
    <router-link :to="{path:'/home/editstu',query:{id:001}}">新增学生</router-link>
    
    //js
    this.$router.push("/home/editstu?id=001")
    
    this.$router.push({path:'/home/editstu',query:{id:001}})
    ```

    

    - 接收

      ```javascript
      this.$route.query
      
      created(){
        this.$route.query.id
      }
      ```

      

